<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>FCLib: (Private)</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="classes.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<h1>(Private)<br>
<small>
[<a class="el" href="group__ElemDeath.html">Element Death</a>]</small>
</h1>
<p>
Collaboration diagram for (Private):
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DataTypes.html#g2a816f8eddef0c2d8c2e3a0393b1f52e">FC_ReturnCode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PrivateElemDeath.html#gc3fd8d8e63dbe6fb7f97d32380efeadd">_fc_recursive_IndividuallySegmentingNodes</a> (<a class="el" href="structFC__Subset.html">FC_Subset</a> subset, int compare, int shared_segdim, int numin, int *inset, int *numout, int **outset)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">helper function that recursively determines node ids that individually will result in greater segmentation than some comparison value  <a href="#gc3fd8d8e63dbe6fb7f97d32380efeadd"></a><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="gc3fd8d8e63dbe6fb7f97d32380efeadd"></a><!-- doxytag: member="elemdeath.c::_fc_recursive_IndividuallySegmentingNodes" ref="gc3fd8d8e63dbe6fb7f97d32380efeadd" args="(FC_Subset subset, int compare, int shared_segdim, int numin, int *inset, int *numout, int **outset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DataTypes.html#g2a816f8eddef0c2d8c2e3a0393b1f52e">FC_ReturnCode</a> _fc_recursive_IndividuallySegmentingNodes           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFC__Subset.html">FC_Subset</a>&nbsp;</td>
          <td class="paramname"> <em>subset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>compare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>shared_segdim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>inset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>numout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&nbsp;</td>
          <td class="paramname"> <em>outset</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
helper function that recursively determines node ids that individually will result in greater segmentation than some comparison value 
<p>
<b>Description:</b> <p>
helper function that recursively determines node ids that will individually result in greater segmentation than some comparison value<p>
Note:<ul>
<li>This uses recursion to test on big sets of elem first and only narrow it down to smaller set if the big sets segment first. i.e., It is assumed that if a whole group doesnt result in a greater segmenting, that the items of the group taken individually wont result in a greater segmenting. There is the possibility that there could be offsetting effects that occur within the bigger set that will cuase this to be a faulty assumption, particularly when the dead region is close to the boundary of the mesh. However, if this is used primarily for cases where we are looking for the mesh to be just about to break, then we expect that the num of elements that will satisfy the condition is small and so this should be ok.</li></ul>
<p>
<dl compact><dt><b><a class="el" href="todo.html#_todo000011">Todo:</a></b></dt><dd><ul>
<li>will we want less segmentation too.</li></ul>
</dd></dl>
<b>Modifications:</b> <ul>
<li>9/20/05 ACG created in response to thinking that its better to return the segmenting rather than the nonsegmenting nodeset so dont have to do inversion of the set later. replaces _fc_maximalNonSegmentingNodeset</li><li>9/22/05 ACG added shared segdim</li><li>10/09/05 ACG explicitly check that 1 element set doesnt result in less segmentation (rather than just equal). will continue to loop for larger sets resulting in less segmentation (for instance if whole set of neighbors subsumes the live regions, still want to delve down into individual bits) </li></ul>

<p>
Definition at line <a class="el" href="elemdeath_8c-source.html#l01268">1268</a> of file <a class="el" href="elemdeath_8c-source.html">elemdeath.c</a>.
<p>
References <a class="el" href="elemdeath_8c-source.html#l01268">_fc_recursive_IndividuallySegmentingNodes()</a>, <a class="el" href="subset_8c-source.html#l01234">fc_addArrayMembersToSubset()</a>, <a class="el" href="subset_8c-source.html#l00218">fc_copySubset()</a>, <a class="el" href="subset_8c-source.html#l01589">fc_deleteSubset()</a>, <a class="el" href="subset_8c-source.html#l01713">fc_getMeshFromSubset()</a>, <a class="el" href="base_8c-source.html#l00354">fc_getReturnCodeText()</a>, <a class="el" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52e4905abab801292d8b6338a89462b8e22">FC_INPUT_ERROR</a>, <a class="el" href="subset_8c-source.html#l01652">fc_isSubsetValid()</a>, <a class="el" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52ee4bf428a2cdead5d4e3e3391a2cdab0d">FC_MEMORY_ERROR</a>, <a class="el" href="library_8h-source.html#l00096">fc_printfErrorMessage</a>, <a class="el" href="library_8h-source.html#l00162">fc_printfLogMessage</a>, <a class="el" href="elemdeath_8c-source.html#l00778">fc_subsetSegmentsMesh()</a>, and <a class="el" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52e27738acee5b8b2ef61be6e9b14a26613">FC_SUCCESS</a>.
<p>
Referenced by <a class="el" href="elemdeath_8c-source.html#l01268">_fc_recursive_IndividuallySegmentingNodes()</a>, and <a class="el" href="elemdeath_8c-source.html#l01072">fc_subsetPlusNeighborGreaterSegmentationMesh()</a>.<div class="fragment"><pre class="fragment"><a name="l01276"></a>01276  {
<a name="l01277"></a>01277   <a class="code" href="group__DataTypes.html#g2a816f8eddef0c2d8c2e3a0393b1f52e">FC_ReturnCode</a> rc;
<a name="l01278"></a>01278   <a class="code" href="structFC__Mesh.html">FC_Mesh</a> mesh;
<a name="l01279"></a>01279   <a class="code" href="structFC__Subset.html">FC_Subset</a> testSubset;
<a name="l01280"></a>01280   <span class="keywordtype">int</span> numSegment;
<a name="l01281"></a>01281   <span class="keywordtype">int</span> i;
<a name="l01282"></a>01282 
<a name="l01283"></a>01283   <span class="comment">//defaults</span>
<a name="l01284"></a>01284   *numout = 0;
<a name="l01285"></a>01285   <span class="keywordflow">if</span> (outset)
<a name="l01286"></a>01286     *outset = NULL;
<a name="l01287"></a>01287 
<a name="l01288"></a>01288   <span class="comment">// Test input (shared_segdim checked in fc_segment)</span>
<a name="l01289"></a>01289   <span class="keywordflow">if</span> (!<a class="code" href="group__Subset.html#g4ceb4c71219255a80166405a22773952">fc_isSubsetValid</a>(subset) || !numout || !outset ||
<a name="l01290"></a>01290       numin &lt; 0 || (!inset  &amp;&amp; numin != 0)){
<a name="l01291"></a>01291     <a class="code" href="group__Library.html#gb41a63cb101314fb41df98cef504a556">fc_printfErrorMessage</a>(<span class="stringliteral">"%s"</span>, <a class="code" href="group__DataTypes.html#g97ca6452d8a5b6625a2c02166dc87bb7">fc_getReturnCodeText</a>(<a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52e4905abab801292d8b6338a89462b8e22">FC_INPUT_ERROR</a>));
<a name="l01292"></a>01292     <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52e4905abab801292d8b6338a89462b8e22">FC_INPUT_ERROR</a>;
<a name="l01293"></a>01293   }
<a name="l01294"></a>01294 
<a name="l01295"></a>01295 
<a name="l01296"></a>01296   <a class="code" href="group__Library.html#g523b10264df36531b23de2260393db30">fc_printfLogMessage</a>(<span class="stringliteral">"recursive segmenting nodes"</span>);
<a name="l01297"></a>01297   
<a name="l01298"></a>01298   <span class="comment">//  printf("\tChecking set (%d) ",numin);</span>
<a name="l01299"></a>01299   <span class="comment">//  for (i = 0; i &lt; numin; i++){</span>
<a name="l01300"></a>01300   <span class="comment">//    printf("%d ", inset[i]);</span>
<a name="l01301"></a>01301   <span class="comment">//  }</span>
<a name="l01302"></a>01302   <span class="comment">//  printf("\n");</span>
<a name="l01303"></a>01303   
<a name="l01304"></a>01304   <span class="keywordflow">if</span> (numin == 0){
<a name="l01305"></a>01305     <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52e27738acee5b8b2ef61be6e9b14a26613">FC_SUCCESS</a>;
<a name="l01306"></a>01306   }
<a name="l01307"></a>01307 
<a name="l01308"></a>01308   <span class="comment">//now lets get a copy of the subset to play with</span>
<a name="l01309"></a>01309   rc = <a class="code" href="group__Subset.html#g095c5b064f4ae81a17682666aadd420b">fc_getMeshFromSubset</a>(subset,&amp;mesh);
<a name="l01310"></a>01310   <span class="keywordflow">if</span> (rc != <a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52e27738acee5b8b2ef61be6e9b14a26613">FC_SUCCESS</a>){
<a name="l01311"></a>01311     <a class="code" href="group__Library.html#gb41a63cb101314fb41df98cef504a556">fc_printfErrorMessage</a>(<span class="stringliteral">"cant get mesh"</span>);
<a name="l01312"></a>01312     <span class="keywordflow">return</span> rc;
<a name="l01313"></a>01313   }
<a name="l01314"></a>01314 
<a name="l01315"></a>01315   rc = <a class="code" href="group__Subset.html#g8d62de2aecacfe4938e68a08153fd3c1">fc_copySubset</a>(subset,mesh,<span class="stringliteral">"test_subset"</span>,&amp;testSubset);
<a name="l01316"></a>01316   <span class="keywordflow">if</span> (rc != <a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52e27738acee5b8b2ef61be6e9b14a26613">FC_SUCCESS</a>){
<a name="l01317"></a>01317     <a class="code" href="group__Library.html#gb41a63cb101314fb41df98cef504a556">fc_printfErrorMessage</a>(<span class="stringliteral">"cant copy subset"</span>);
<a name="l01318"></a>01318     <span class="keywordflow">return</span> rc;
<a name="l01319"></a>01319   }
<a name="l01320"></a>01320   
<a name="l01321"></a>01321   <span class="comment">//now see if adding if the whole set does anything</span>
<a name="l01322"></a>01322   rc = <a class="code" href="group__Subset.html#g47d34843c8d66c114c2c81e3a1fc14e4">fc_addArrayMembersToSubset</a>(testSubset,numin,inset);
<a name="l01323"></a>01323   <span class="keywordflow">if</span> (rc != <a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52e27738acee5b8b2ef61be6e9b14a26613">FC_SUCCESS</a>){
<a name="l01324"></a>01324     <a class="code" href="group__Library.html#gb41a63cb101314fb41df98cef504a556">fc_printfErrorMessage</a>(<span class="stringliteral">"cant add ids to subset"</span>);
<a name="l01325"></a>01325     <span class="keywordflow">return</span> rc;
<a name="l01326"></a>01326   }
<a name="l01327"></a>01327 
<a name="l01328"></a>01328 
<a name="l01329"></a>01329   rc =  <a class="code" href="group__ElemDeath.html#gdbc1ba9eb6514c630e5d4ff817f89cb3">fc_subsetSegmentsMesh</a>(testSubset,shared_segdim,NULL,
<a name="l01330"></a>01330                      &amp;numSegment,NULL);
<a name="l01331"></a>01331   <span class="keywordflow">if</span> (rc != <a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52e27738acee5b8b2ef61be6e9b14a26613">FC_SUCCESS</a>){
<a name="l01332"></a>01332     <a class="code" href="group__Library.html#gb41a63cb101314fb41df98cef504a556">fc_printfErrorMessage</a>(<span class="stringliteral">"failed to segment"</span>);
<a name="l01333"></a>01333     <span class="keywordflow">return</span> rc;
<a name="l01334"></a>01334   }
<a name="l01335"></a>01335 
<a name="l01336"></a>01336   rc = <a class="code" href="group__Subset.html#gfdcc399692041499cc461916a9973558">fc_deleteSubset</a>(testSubset);
<a name="l01337"></a>01337 
<a name="l01338"></a>01338   <span class="comment">//compare is passed in so we dont have to recalc it each time, but it better</span>
<a name="l01339"></a>01339   <span class="comment">//be correct</span>
<a name="l01340"></a>01340   <span class="keywordflow">if</span> (numSegment == compare){ 
<a name="l01341"></a>01341     <span class="comment">//    printf("elements as a group do not divide any more (or less) (%d). maximal recursion - returning 0 elem\n",numSegment);</span>
<a name="l01342"></a>01342     <span class="comment">//then adding the vals doesnt cause any greater segmentation</span>
<a name="l01343"></a>01343     *numout = 0;
<a name="l01344"></a>01344   } <span class="keywordflow">else</span> {
<a name="l01345"></a>01345     <span class="keywordflow">if</span> (numin == 1){
<a name="l01346"></a>01346       <span class="keywordflow">if</span> (numSegment &lt;= compare){
<a name="l01347"></a>01347      <span class="comment">//     printf("single element %d doesnt divide more. maximal recursion - returning 1 elem\n",inset[0]);</span>
<a name="l01348"></a>01348      *numout = 0;
<a name="l01349"></a>01349       }<span class="keywordflow">else</span> {
<a name="l01350"></a>01350      <span class="comment">//     printf("single element %d divides. maximal recursion - returning 1 elem\n",inset[0]);</span>
<a name="l01351"></a>01351      *numout = 1;
<a name="l01352"></a>01352      *outset = (<span class="keywordtype">int</span>*)malloc(<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
<a name="l01353"></a>01353      <span class="keywordflow">if</span> (*outset == NULL){
<a name="l01354"></a>01354        <a class="code" href="group__Library.html#gb41a63cb101314fb41df98cef504a556">fc_printfErrorMessage</a>(<span class="stringliteral">"%s"</span>, <a class="code" href="group__DataTypes.html#g97ca6452d8a5b6625a2c02166dc87bb7">fc_getReturnCodeText</a>(<a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52ee4bf428a2cdead5d4e3e3391a2cdab0d">FC_MEMORY_ERROR</a>));
<a name="l01355"></a>01355        <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52ee4bf428a2cdead5d4e3e3391a2cdab0d">FC_MEMORY_ERROR</a>;
<a name="l01356"></a>01356      }
<a name="l01357"></a>01357      (*outset)[0] = inset[0];
<a name="l01358"></a>01358       }
<a name="l01359"></a>01359     }<span class="keywordflow">else</span>{
<a name="l01360"></a>01360       <span class="keywordtype">int</span> idiv = numin/2;
<a name="l01361"></a>01361       <span class="keywordtype">int</span> *seta, *setb;
<a name="l01362"></a>01362       <span class="keywordtype">int</span> *reta, *retb, nreta, nretb;
<a name="l01363"></a>01363 
<a name="l01364"></a>01364       <span class="comment">//      printf("this does divide - recursing\n");</span>
<a name="l01365"></a>01365 
<a name="l01366"></a>01366       seta = malloc(idiv*<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
<a name="l01367"></a>01367       setb = malloc((numin-idiv)*<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
<a name="l01368"></a>01368       <span class="keywordflow">if</span> ((seta == NULL &amp;&amp; idiv &gt; 0) || (setb == NULL &amp;&amp; numin-idiv &gt; 0)){
<a name="l01369"></a>01369      <a class="code" href="group__Library.html#gb41a63cb101314fb41df98cef504a556">fc_printfErrorMessage</a>(<span class="stringliteral">"%s"</span>, <a class="code" href="group__DataTypes.html#g97ca6452d8a5b6625a2c02166dc87bb7">fc_getReturnCodeText</a>(<a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52ee4bf428a2cdead5d4e3e3391a2cdab0d">FC_MEMORY_ERROR</a>));
<a name="l01370"></a>01370      <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52ee4bf428a2cdead5d4e3e3391a2cdab0d">FC_MEMORY_ERROR</a>;
<a name="l01371"></a>01371       }
<a name="l01372"></a>01372       <span class="keywordflow">for</span> (i = 0; i &lt; idiv; i++){
<a name="l01373"></a>01373      seta[i] = inset[i];
<a name="l01374"></a>01374       }
<a name="l01375"></a>01375       <span class="keywordflow">for</span> (i = 0; i &lt; numin-idiv; i++){
<a name="l01376"></a>01376      setb[i] = inset[i+idiv];
<a name="l01377"></a>01377       }
<a name="l01378"></a>01378 
<a name="l01379"></a>01379       <span class="comment">//      printf("\tcalling set A\n");</span>
<a name="l01380"></a>01380       rc = <a class="code" href="group__PrivateElemDeath.html#gc3fd8d8e63dbe6fb7f97d32380efeadd">_fc_recursive_IndividuallySegmentingNodes</a>(subset,compare,shared_segdim,
<a name="l01381"></a>01381                            idiv,seta,&amp;nreta,&amp;reta);
<a name="l01382"></a>01382       <span class="keywordflow">if</span> (rc != <a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52e27738acee5b8b2ef61be6e9b14a26613">FC_SUCCESS</a>){
<a name="l01383"></a>01383      <a class="code" href="group__Library.html#gb41a63cb101314fb41df98cef504a556">fc_printfErrorMessage</a>(<span class="stringliteral">"failed to get recursive segmenting nodes"</span>);
<a name="l01384"></a>01384      free(seta);
<a name="l01385"></a>01385      free(setb);
<a name="l01386"></a>01386      <span class="keywordflow">return</span> rc;
<a name="l01387"></a>01387       }
<a name="l01388"></a>01388 
<a name="l01389"></a>01389       <span class="comment">//      printf("\tcalling set B\n");</span>
<a name="l01390"></a>01390       rc = <a class="code" href="group__PrivateElemDeath.html#gc3fd8d8e63dbe6fb7f97d32380efeadd">_fc_recursive_IndividuallySegmentingNodes</a>(subset,compare,shared_segdim,
<a name="l01391"></a>01391                            numin-idiv,setb,&amp;nretb,&amp;retb);
<a name="l01392"></a>01392       <span class="keywordflow">if</span> (rc != <a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52e27738acee5b8b2ef61be6e9b14a26613">FC_SUCCESS</a>){
<a name="l01393"></a>01393      <a class="code" href="group__Library.html#gb41a63cb101314fb41df98cef504a556">fc_printfErrorMessage</a>(<span class="stringliteral">"failed to get recursive segmenting nodes"</span>);
<a name="l01394"></a>01394      free(seta);
<a name="l01395"></a>01395      free(setb);
<a name="l01396"></a>01396      <span class="keywordflow">return</span> rc;
<a name="l01397"></a>01397       }
<a name="l01398"></a>01398 
<a name="l01399"></a>01399       free(seta);
<a name="l01400"></a>01400       free(setb);
<a name="l01401"></a>01401       
<a name="l01402"></a>01402       *numout = nreta + nretb;
<a name="l01403"></a>01403       <span class="keywordflow">if</span> (*numout &gt; 0){
<a name="l01404"></a>01404      *outset = (<span class="keywordtype">int</span>*)malloc(*numout*<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
<a name="l01405"></a>01405      <span class="keywordflow">if</span> (*outset == NULL){
<a name="l01406"></a>01406        <span class="comment">//no cleanup in case of memory error</span>
<a name="l01407"></a>01407        <a class="code" href="group__Library.html#gb41a63cb101314fb41df98cef504a556">fc_printfErrorMessage</a>(<span class="stringliteral">"%s"</span>, <a class="code" href="group__DataTypes.html#g97ca6452d8a5b6625a2c02166dc87bb7">fc_getReturnCodeText</a>(<a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52ee4bf428a2cdead5d4e3e3391a2cdab0d">FC_MEMORY_ERROR</a>));
<a name="l01408"></a>01408        <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52ee4bf428a2cdead5d4e3e3391a2cdab0d">FC_MEMORY_ERROR</a>;
<a name="l01409"></a>01409      }
<a name="l01410"></a>01410      <span class="keywordflow">for</span> (i = 0; i &lt; nreta; i++){
<a name="l01411"></a>01411        (*outset)[i] = reta[i];
<a name="l01412"></a>01412      }
<a name="l01413"></a>01413      <span class="keywordflow">for</span> (i = 0; i &lt; nretb; i++){
<a name="l01414"></a>01414        (*outset)[i+nreta] = retb[i];
<a name="l01415"></a>01415      }
<a name="l01416"></a>01416      <span class="comment">//      if (*numout != 0) printf("\trecur: %d in %d out\n",numin,*numout);</span>
<a name="l01417"></a>01417      <span class="keywordflow">if</span> (reta) free(reta); <span class="comment">//they will be NULL otherwise</span>
<a name="l01418"></a>01418      <span class="keywordflow">if</span> (retb) free(retb);
<a name="l01419"></a>01419       }
<a name="l01420"></a>01420     }
<a name="l01421"></a>01421   }
<a name="l01422"></a>01422 
<a name="l01423"></a>01423   <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52e27738acee5b8b2ef61be6e9b14a26613">FC_SUCCESS</a>;
<a name="l01424"></a>01424 }
</pre></div>
<p>

</div>
</div><p>
<hr size="1"><address style="align: right;"><small>Generated on Wed Oct 31 11:10:02 2007 for FCLib by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1 </small></address>
</body>
</html>
