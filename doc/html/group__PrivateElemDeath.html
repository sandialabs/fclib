<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>FCLib: (Private)</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="classes.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>(Private)<br>
<small>
[<a class="el" href="group__ElemDeath.html">Element Death</a>]</small>
</h1>
<p>
<div class="dynheader">
Collaboration diagram for (Private):</div>
<div class="dynsection">
<center><table><tr><td><img src="group__PrivateElemDeath.gif" border="0" alt="" usemap="#group____PrivateElemDeath_map">
<map name="group____PrivateElemDeath_map">
<area shape="rect" href="group__ElemDeath.html" title="Dead element analysis routines and helper functions." alt="" coords="7,5,135,32"></map></td></tr></table></center>
</div>

<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DataTypes.html#g2a40aa471d085988d5b582669f766ce4">FC_ReturnCode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PrivateElemDeath.html#ge61c8cc3cc48b9b3665baf788682abf7">_fc_recursive_IndividuallySegmentingNodes</a> (<a class="el" href="structFC__Subset.html">FC_Subset</a> subset, int compare, int shared_segdim, int numin, int *inset, int *numout, int **outset)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">helper function that recursively determines node ids that individually will result in greater segmentation than some comparison value  <a href="#ge61c8cc3cc48b9b3665baf788682abf7"></a><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="ge61c8cc3cc48b9b3665baf788682abf7"></a><!-- doxytag: member="elemdeath.c::_fc_recursive_IndividuallySegmentingNodes" ref="ge61c8cc3cc48b9b3665baf788682abf7" args="(FC_Subset subset, int compare, int shared_segdim, int numin, int *inset, int *numout, int **outset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DataTypes.html#g2a40aa471d085988d5b582669f766ce4">FC_ReturnCode</a> _fc_recursive_IndividuallySegmentingNodes           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFC__Subset.html">FC_Subset</a>&nbsp;</td>
          <td class="paramname"> <em>subset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>compare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>shared_segdim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>inset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>numout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&nbsp;</td>
          <td class="paramname"> <em>outset</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
helper function that recursively determines node ids that individually will result in greater segmentation than some comparison value 
<p>
<b>Description:</b> <p>
helper function that recursively determines node ids that will individually result in greater segmentation than some comparison value<p>
Note:<ul>
<li>This uses recursion to test on big sets of elem first and only narrow it down to smaller set if the big sets segment first. i.e., It is assumed that if a whole group doesnt result in a greater segmenting, that the items of the group taken individually wont result in a greater segmenting. There is the possibility that there could be offsetting effects that occur within the bigger set that will cuase this to be a faulty assumption, particularly when the dead region is close to the boundary of the mesh. However, if this is used primarily for cases where we are looking for the mesh to be just about to break, then we expect that the num of elements that will satisfy the condition is small and so this should be ok.</li></ul>
<p>
<dl compact><dt><b><a class="el" href="todo.html#_todo000011">Todo:</a></b></dt><dd><ul>
<li>will we want less segmentation too.</li></ul>
</dd></dl>
<b>Modifications:</b> <ul>
<li>9/20/05 ACG created in response to thinking that its better to return the segmenting rather than the nonsegmenting nodeset so dont have to do inversion of the set later. replaces _fc_maximalNonSegmentingNodeset</li><li>9/22/05 ACG added shared segdim</li><li>10/09/05 ACG explicitly check that 1 element set doesnt result in less segmentation (rather than just equal). will continue to loop for larger sets resulting in less segmentation (for instance if whole set of neighbors subsumes the live regions, still want to delve down into individual bits) </li></ul>

<p>Definition at line <a class="el" href="elemdeath_8c-source.html#l01268">1268</a> of file <a class="el" href="elemdeath_8c-source.html">elemdeath.c</a>.</p>

<p>References <a class="el" href="elemdeath_8c-source.html#l01268">_fc_recursive_IndividuallySegmentingNodes()</a>, <a class="el" href="subset_8c-source.html#l02064">fc_addArrayMembersToSubset()</a>, <a class="el" href="subset_8c-source.html#l00351">fc_copySubset()</a>, <a class="el" href="subset_8c-source.html#l02482">fc_deleteSubset()</a>, <a class="el" href="subset_8c-source.html#l02741">fc_getMeshFromSubset()</a>, <a class="el" href="base_8c-source.html#l00355">fc_getReturnCodeText()</a>, <a class="el" href="base_8h-source.html#l00107">FC_INPUT_ERROR</a>, <a class="el" href="subset_8c-source.html#l02622">fc_isSubsetValid()</a>, <a class="el" href="base_8h-source.html#l00106">FC_MEMORY_ERROR</a>, <a class="el" href="library_8h-source.html#l00120">fc_printfErrorMessage</a>, <a class="el" href="library_8h-source.html#l00188">fc_printfLogMessage</a>, <a class="el" href="elemdeath_8c-source.html#l00778">fc_subsetSegmentsMesh()</a>, and <a class="el" href="base_8h-source.html#l00104">FC_SUCCESS</a>.</p>

<p>Referenced by <a class="el" href="elemdeath_8c-source.html#l01268">_fc_recursive_IndividuallySegmentingNodes()</a>, and <a class="el" href="elemdeath_8c-source.html#l01072">fc_subsetPlusNeighborGreaterSegmentationMesh()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l01276"></a>01276  {
<a name="l01277"></a>01277   <a class="code" href="group__DataTypes.html#g2a40aa471d085988d5b582669f766ce4" title="Possible function return values.">FC_ReturnCode</a> rc;
<a name="l01278"></a>01278   <a class="code" href="structFC__Mesh.html" title="Mesh Handle.">FC_Mesh</a> mesh;
<a name="l01279"></a>01279   <a class="code" href="structFC__Subset.html" title="Subset Handle.">FC_Subset</a> testSubset;
<a name="l01280"></a>01280   <span class="keywordtype">int</span> numSegment;
<a name="l01281"></a>01281   <span class="keywordtype">int</span> i;
<a name="l01282"></a>01282 
<a name="l01283"></a>01283   <span class="comment">//defaults</span>
<a name="l01284"></a>01284   *numout = 0;
<a name="l01285"></a>01285   <span class="keywordflow">if</span> (outset)
<a name="l01286"></a>01286     *outset = NULL;
<a name="l01287"></a>01287 
<a name="l01288"></a>01288   <span class="comment">// Test input (shared_segdim checked in fc_segment)</span>
<a name="l01289"></a>01289   <span class="keywordflow">if</span> (!<a class="code" href="group__Subset.html#g63bf248cb60435e458ea038036d6af90" title="Check that the handle refers to a valid subset.">fc_isSubsetValid</a>(subset) || !numout || !outset ||
<a name="l01290"></a>01290       numin &lt; 0 || (!inset  &amp;&amp; numin != 0)){
<a name="l01291"></a>01291     <a class="code" href="group__Library.html#g1473e77471cd1319f76eb9a32e4ad91f" title="Print an error message to stderr.">fc_printfErrorMessage</a>(<span class="stringliteral">"%s"</span>, <a class="code" href="group__DataTypes.html#g510d74cc1e13d4cdc5bde247a25d48e4" title="Return the name of the FC_ReturnCode&amp;#39;s value.">fc_getReturnCodeText</a>(<a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce464a3d55131c355cdf036f95d0d7e1a6e">FC_INPUT_ERROR</a>));
<a name="l01292"></a>01292     <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce464a3d55131c355cdf036f95d0d7e1a6e">FC_INPUT_ERROR</a>;
<a name="l01293"></a>01293   }
<a name="l01294"></a>01294 
<a name="l01295"></a>01295 
<a name="l01296"></a>01296   <a class="code" href="group__Library.html#g7e9664a8765cc08c313df880421c496b" title="Print a log message to stdout.">fc_printfLogMessage</a>(<span class="stringliteral">"recursive segmenting nodes"</span>);
<a name="l01297"></a>01297   
<a name="l01298"></a>01298   <span class="comment">//  printf("\tChecking set (%d) ",numin);</span>
<a name="l01299"></a>01299   <span class="comment">//  for (i = 0; i &lt; numin; i++){</span>
<a name="l01300"></a>01300   <span class="comment">//    printf("%d ", inset[i]);</span>
<a name="l01301"></a>01301   <span class="comment">//  }</span>
<a name="l01302"></a>01302   <span class="comment">//  printf("\n");</span>
<a name="l01303"></a>01303   
<a name="l01304"></a>01304   <span class="keywordflow">if</span> (numin == 0){
<a name="l01305"></a>01305     <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce46687acb19dbc2e15e6e89cdc39e8e18e">FC_SUCCESS</a>;
<a name="l01306"></a>01306   }
<a name="l01307"></a>01307 
<a name="l01308"></a>01308   <span class="comment">//now lets get a copy of the subset to play with</span>
<a name="l01309"></a>01309   rc = <a class="code" href="group__Subset.html#gddbb3a2f8c43289a3c3754f1546462bc" title="Get the parent mesh of the subset.">fc_getMeshFromSubset</a>(subset,&amp;mesh);
<a name="l01310"></a>01310   <span class="keywordflow">if</span> (rc != <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce46687acb19dbc2e15e6e89cdc39e8e18e">FC_SUCCESS</a>){
<a name="l01311"></a>01311     <a class="code" href="group__Library.html#g1473e77471cd1319f76eb9a32e4ad91f" title="Print an error message to stderr.">fc_printfErrorMessage</a>(<span class="stringliteral">"cant get mesh"</span>);
<a name="l01312"></a>01312     <span class="keywordflow">return</span> rc;
<a name="l01313"></a>01313   }
<a name="l01314"></a>01314 
<a name="l01315"></a>01315   rc = <a class="code" href="group__Subset.html#g8c233583d14e8205bbfe4aca0d196772" title="Copy subset to a new subset.">fc_copySubset</a>(subset,mesh,<span class="stringliteral">"test_subset"</span>,&amp;testSubset);
<a name="l01316"></a>01316   <span class="keywordflow">if</span> (rc != <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce46687acb19dbc2e15e6e89cdc39e8e18e">FC_SUCCESS</a>){
<a name="l01317"></a>01317     <a class="code" href="group__Library.html#g1473e77471cd1319f76eb9a32e4ad91f" title="Print an error message to stderr.">fc_printfErrorMessage</a>(<span class="stringliteral">"cant copy subset"</span>);
<a name="l01318"></a>01318     <span class="keywordflow">return</span> rc;
<a name="l01319"></a>01319   }
<a name="l01320"></a>01320   
<a name="l01321"></a>01321   <span class="comment">//now see if adding if the whole set does anything</span>
<a name="l01322"></a>01322   rc = <a class="code" href="group__Subset.html#g123bb2337bd35a1915aa736270ed3d40" title="Add members from an array to a subset.">fc_addArrayMembersToSubset</a>(testSubset,numin,inset);
<a name="l01323"></a>01323   <span class="keywordflow">if</span> (rc != <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce46687acb19dbc2e15e6e89cdc39e8e18e">FC_SUCCESS</a>){
<a name="l01324"></a>01324     <a class="code" href="group__Library.html#g1473e77471cd1319f76eb9a32e4ad91f" title="Print an error message to stderr.">fc_printfErrorMessage</a>(<span class="stringliteral">"cant add ids to subset"</span>);
<a name="l01325"></a>01325     <span class="keywordflow">return</span> rc;
<a name="l01326"></a>01326   }
<a name="l01327"></a>01327 
<a name="l01328"></a>01328 
<a name="l01329"></a>01329   rc =  <a class="code" href="group__ElemDeath.html#g332e59c8a844757b89063201843da456" title="returns the segments (and their number) that result from segmenting the mesh by the...">fc_subsetSegmentsMesh</a>(testSubset,shared_segdim,NULL,
<a name="l01330"></a>01330                      &amp;numSegment,NULL);
<a name="l01331"></a>01331   <span class="keywordflow">if</span> (rc != <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce46687acb19dbc2e15e6e89cdc39e8e18e">FC_SUCCESS</a>){
<a name="l01332"></a>01332     <a class="code" href="group__Library.html#g1473e77471cd1319f76eb9a32e4ad91f" title="Print an error message to stderr.">fc_printfErrorMessage</a>(<span class="stringliteral">"failed to segment"</span>);
<a name="l01333"></a>01333     <span class="keywordflow">return</span> rc;
<a name="l01334"></a>01334   }
<a name="l01335"></a>01335 
<a name="l01336"></a>01336   rc = <a class="code" href="group__Subset.html#g550d0636e4f35c29d6dbc427b3165a24" title="Delete a subset.">fc_deleteSubset</a>(testSubset);
<a name="l01337"></a>01337 
<a name="l01338"></a>01338   <span class="comment">//compare is passed in so we dont have to recalc it each time, but it better</span>
<a name="l01339"></a>01339   <span class="comment">//be correct</span>
<a name="l01340"></a>01340   <span class="keywordflow">if</span> (numSegment == compare){ 
<a name="l01341"></a>01341     <span class="comment">//    printf("elements as a group do not divide any more (or less) (%d). maximal recursion - returning 0 elem\n",numSegment);</span>
<a name="l01342"></a>01342     <span class="comment">//then adding the vals doesnt cause any greater segmentation</span>
<a name="l01343"></a>01343     *numout = 0;
<a name="l01344"></a>01344   } <span class="keywordflow">else</span> {
<a name="l01345"></a>01345     <span class="keywordflow">if</span> (numin == 1){
<a name="l01346"></a>01346       <span class="keywordflow">if</span> (numSegment &lt;= compare){
<a name="l01347"></a>01347      <span class="comment">//     printf("single element %d doesnt divide more. maximal recursion - returning 1 elem\n",inset[0]);</span>
<a name="l01348"></a>01348      *numout = 0;
<a name="l01349"></a>01349       }<span class="keywordflow">else</span> {
<a name="l01350"></a>01350      <span class="comment">//     printf("single element %d divides. maximal recursion - returning 1 elem\n",inset[0]);</span>
<a name="l01351"></a>01351      *numout = 1;
<a name="l01352"></a>01352      *outset = (<span class="keywordtype">int</span>*)malloc(<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
<a name="l01353"></a>01353      <span class="keywordflow">if</span> (*outset == NULL){
<a name="l01354"></a>01354        <a class="code" href="group__Library.html#g1473e77471cd1319f76eb9a32e4ad91f" title="Print an error message to stderr.">fc_printfErrorMessage</a>(<span class="stringliteral">"%s"</span>, <a class="code" href="group__DataTypes.html#g510d74cc1e13d4cdc5bde247a25d48e4" title="Return the name of the FC_ReturnCode&amp;#39;s value.">fc_getReturnCodeText</a>(<a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce4db79475c8e6c2fcf3e4e7979a4139658">FC_MEMORY_ERROR</a>));
<a name="l01355"></a>01355        <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce4db79475c8e6c2fcf3e4e7979a4139658">FC_MEMORY_ERROR</a>;
<a name="l01356"></a>01356      }
<a name="l01357"></a>01357      (*outset)[0] = inset[0];
<a name="l01358"></a>01358       }
<a name="l01359"></a>01359     }<span class="keywordflow">else</span>{
<a name="l01360"></a>01360       <span class="keywordtype">int</span> idiv = numin/2;
<a name="l01361"></a>01361       <span class="keywordtype">int</span> *seta, *setb;
<a name="l01362"></a>01362       <span class="keywordtype">int</span> *reta, *retb, nreta, nretb;
<a name="l01363"></a>01363 
<a name="l01364"></a>01364       <span class="comment">//      printf("this does divide - recursing\n");</span>
<a name="l01365"></a>01365 
<a name="l01366"></a>01366       seta = malloc(idiv*<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
<a name="l01367"></a>01367       setb = malloc((numin-idiv)*<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
<a name="l01368"></a>01368       <span class="keywordflow">if</span> ((seta == NULL &amp;&amp; idiv &gt; 0) || (setb == NULL &amp;&amp; numin-idiv &gt; 0)){
<a name="l01369"></a>01369      <a class="code" href="group__Library.html#g1473e77471cd1319f76eb9a32e4ad91f" title="Print an error message to stderr.">fc_printfErrorMessage</a>(<span class="stringliteral">"%s"</span>, <a class="code" href="group__DataTypes.html#g510d74cc1e13d4cdc5bde247a25d48e4" title="Return the name of the FC_ReturnCode&amp;#39;s value.">fc_getReturnCodeText</a>(<a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce4db79475c8e6c2fcf3e4e7979a4139658">FC_MEMORY_ERROR</a>));
<a name="l01370"></a>01370      <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce4db79475c8e6c2fcf3e4e7979a4139658">FC_MEMORY_ERROR</a>;
<a name="l01371"></a>01371       }
<a name="l01372"></a>01372       <span class="keywordflow">for</span> (i = 0; i &lt; idiv; i++){
<a name="l01373"></a>01373      seta[i] = inset[i];
<a name="l01374"></a>01374       }
<a name="l01375"></a>01375       <span class="keywordflow">for</span> (i = 0; i &lt; numin-idiv; i++){
<a name="l01376"></a>01376      setb[i] = inset[i+idiv];
<a name="l01377"></a>01377       }
<a name="l01378"></a>01378 
<a name="l01379"></a>01379       <span class="comment">//      printf("\tcalling set A\n");</span>
<a name="l01380"></a>01380       rc = <a class="code" href="group__PrivateElemDeath.html#ge61c8cc3cc48b9b3665baf788682abf7" title="helper function that recursively determines node ids that individually will result...">_fc_recursive_IndividuallySegmentingNodes</a>(subset,compare,shared_segdim,
<a name="l01381"></a>01381                            idiv,seta,&amp;nreta,&amp;reta);
<a name="l01382"></a>01382       <span class="keywordflow">if</span> (rc != <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce46687acb19dbc2e15e6e89cdc39e8e18e">FC_SUCCESS</a>){
<a name="l01383"></a>01383      <a class="code" href="group__Library.html#g1473e77471cd1319f76eb9a32e4ad91f" title="Print an error message to stderr.">fc_printfErrorMessage</a>(<span class="stringliteral">"failed to get recursive segmenting nodes"</span>);
<a name="l01384"></a>01384      free(seta);
<a name="l01385"></a>01385      free(setb);
<a name="l01386"></a>01386      <span class="keywordflow">return</span> rc;
<a name="l01387"></a>01387       }
<a name="l01388"></a>01388 
<a name="l01389"></a>01389       <span class="comment">//      printf("\tcalling set B\n");</span>
<a name="l01390"></a>01390       rc = <a class="code" href="group__PrivateElemDeath.html#ge61c8cc3cc48b9b3665baf788682abf7" title="helper function that recursively determines node ids that individually will result...">_fc_recursive_IndividuallySegmentingNodes</a>(subset,compare,shared_segdim,
<a name="l01391"></a>01391                            numin-idiv,setb,&amp;nretb,&amp;retb);
<a name="l01392"></a>01392       <span class="keywordflow">if</span> (rc != <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce46687acb19dbc2e15e6e89cdc39e8e18e">FC_SUCCESS</a>){
<a name="l01393"></a>01393      <a class="code" href="group__Library.html#g1473e77471cd1319f76eb9a32e4ad91f" title="Print an error message to stderr.">fc_printfErrorMessage</a>(<span class="stringliteral">"failed to get recursive segmenting nodes"</span>);
<a name="l01394"></a>01394      free(seta);
<a name="l01395"></a>01395      free(setb);
<a name="l01396"></a>01396      <span class="keywordflow">return</span> rc;
<a name="l01397"></a>01397       }
<a name="l01398"></a>01398 
<a name="l01399"></a>01399       free(seta);
<a name="l01400"></a>01400       free(setb);
<a name="l01401"></a>01401       
<a name="l01402"></a>01402       *numout = nreta + nretb;
<a name="l01403"></a>01403       <span class="keywordflow">if</span> (*numout &gt; 0){
<a name="l01404"></a>01404      *outset = (<span class="keywordtype">int</span>*)malloc(*numout*<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
<a name="l01405"></a>01405      <span class="keywordflow">if</span> (*outset == NULL){
<a name="l01406"></a>01406        <span class="comment">//no cleanup in case of memory error</span>
<a name="l01407"></a>01407        <a class="code" href="group__Library.html#g1473e77471cd1319f76eb9a32e4ad91f" title="Print an error message to stderr.">fc_printfErrorMessage</a>(<span class="stringliteral">"%s"</span>, <a class="code" href="group__DataTypes.html#g510d74cc1e13d4cdc5bde247a25d48e4" title="Return the name of the FC_ReturnCode&amp;#39;s value.">fc_getReturnCodeText</a>(<a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce4db79475c8e6c2fcf3e4e7979a4139658">FC_MEMORY_ERROR</a>));
<a name="l01408"></a>01408        <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce4db79475c8e6c2fcf3e4e7979a4139658">FC_MEMORY_ERROR</a>;
<a name="l01409"></a>01409      }
<a name="l01410"></a>01410      <span class="keywordflow">for</span> (i = 0; i &lt; nreta; i++){
<a name="l01411"></a>01411        (*outset)[i] = reta[i];
<a name="l01412"></a>01412      }
<a name="l01413"></a>01413      <span class="keywordflow">for</span> (i = 0; i &lt; nretb; i++){
<a name="l01414"></a>01414        (*outset)[i+nreta] = retb[i];
<a name="l01415"></a>01415      }
<a name="l01416"></a>01416      <span class="comment">//      if (*numout != 0) printf("\trecur: %d in %d out\n",numin,*numout);</span>
<a name="l01417"></a>01417      <span class="keywordflow">if</span> (reta) free(reta); <span class="comment">//they will be NULL otherwise</span>
<a name="l01418"></a>01418      <span class="keywordflow">if</span> (retb) free(retb);
<a name="l01419"></a>01419       }
<a name="l01420"></a>01420     }
<a name="l01421"></a>01421   }
<a name="l01422"></a>01422 
<a name="l01423"></a>01423   <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce46687acb19dbc2e15e6e89cdc39e8e18e">FC_SUCCESS</a>;
<a name="l01424"></a>01424 }
</pre></div>
<p>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Mon Oct 27 13:26:21 2008 for FCLib by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
