<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>FCLib: tools/gaplines.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="classes.html"><span>Data&nbsp;Structures</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>Globals</span></a></li>
  </ul></div>
<h1>tools/gaplines.c</h1><a href="gaplines_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> * Copyright (2000) Sandia Corporation. Under the terms of Contract</span>
<a name="l00003"></a>00003 <span class="comment"> * DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains</span>
<a name="l00004"></a>00004 <span class="comment"> * certain rights in this software.</span>
<a name="l00005"></a>00005 <span class="comment"> *</span>
<a name="l00006"></a>00006 <span class="comment"> * Redistribution and use in source and binary forms, with or without</span>
<a name="l00007"></a>00007 <span class="comment"> * modification, are permitted provided that the following conditions are met:</span>
<a name="l00008"></a>00008 <span class="comment"> *</span>
<a name="l00009"></a>00009 <span class="comment"> *   * Redistributions of source code must retain the above copyright</span>
<a name="l00010"></a>00010 <span class="comment"> *     notice, this list of conditions and the following disclaimer.</span>
<a name="l00011"></a>00011 <span class="comment"> *</span>
<a name="l00012"></a>00012 <span class="comment"> *   * Redistributions in binary form must reproduce the above copyright</span>
<a name="l00013"></a>00013 <span class="comment"> *     notice, this list of conditions and the following disclaimer in the</span>
<a name="l00014"></a>00014 <span class="comment"> *     documentation and/or other materials provided with the</span>
<a name="l00015"></a>00015 <span class="comment"> *     distribution.</span>
<a name="l00016"></a>00016 <span class="comment"> *</span>
<a name="l00017"></a>00017 <span class="comment"> *   * Neither the name of Sandia nor the names of any contributors may</span>
<a name="l00018"></a>00018 <span class="comment"> *     be used to endorse or promote products derived from this software</span>
<a name="l00019"></a>00019 <span class="comment"> *     without specific prior written permission.</span>
<a name="l00020"></a>00020 <span class="comment"> *</span>
<a name="l00021"></a>00021 <span class="comment"> *   * Modified source versions must be plainly marked as such, and must</span>
<a name="l00022"></a>00022 <span class="comment"> *     not be misrepresented as being the original software.</span>
<a name="l00023"></a>00023 <span class="comment"> *</span>
<a name="l00024"></a>00024 <span class="comment"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"</span>
<a name="l00025"></a>00025 <span class="comment"> * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</span>
<a name="l00026"></a>00026 <span class="comment"> * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</span>
<a name="l00027"></a>00027 <span class="comment"> * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE LIABLE FOR</span>
<a name="l00028"></a>00028 <span class="comment"> * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</span>
<a name="l00029"></a>00029 <span class="comment"> * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR</span>
<a name="l00030"></a>00030 <span class="comment"> * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER</span>
<a name="l00031"></a>00031 <span class="comment"> * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</span>
<a name="l00032"></a>00032 <span class="comment"> * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY</span>
<a name="l00033"></a>00033 <span class="comment"> * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH</span>
<a name="l00034"></a>00034 <span class="comment"> * DAMAGE.</span>
<a name="l00035"></a>00035 <span class="comment"> */</span>
<a name="l00036"></a>00036 <span class="comment"></span>
<a name="l00037"></a>00037 <span class="comment">/**</span>
<a name="l00038"></a>00038 <span class="comment"> * \file gaplines.c</span>
<a name="l00039"></a>00039 <span class="comment"> * \brief Look at gaps by creatings lines connecting the surfaces of </span>
<a name="l00040"></a>00040 <span class="comment"> *    two meshes.</span>
<a name="l00041"></a>00041 <span class="comment"> *</span>
<a name="l00042"></a>00042 <span class="comment"> * $Source: /usr/local/Repositories/fcdmf/fclib/tools/gaplines.c,v $</span>
<a name="l00043"></a>00043 <span class="comment"> * $Revision: 1.20 $ </span>
<a name="l00044"></a>00044 <span class="comment"> * $Date: 2006/09/28 06:34:39 $</span>
<a name="l00045"></a>00045 <span class="comment"> *</span>
<a name="l00046"></a>00046 <span class="comment"> * \description</span>
<a name="l00047"></a>00047 <span class="comment"> *</span>
<a name="l00048"></a>00048 <span class="comment"> *   First have to figure out where gaps might happen -- i.e. find surfaces of</span>
<a name="l00049"></a>00049 <span class="comment"> *   different measures that initially are abutted. Then create lines</span>
<a name="l00050"></a>00050 <span class="comment"> *   (initially of 0 length) between the surfaces. If the lines lengthen when</span>
<a name="l00051"></a>00051 <span class="comment"> *   the meshes are deformed, then you have a gap.</span>
<a name="l00052"></a>00052 <span class="comment"> *</span>
<a name="l00053"></a>00053 <span class="comment"> *   (In future, thinking of creating elements of zero volume so that we can</span>
<a name="l00054"></a>00054 <span class="comment"> *   better characterize number of volumes of gaps.)</span>
<a name="l00055"></a>00055 <span class="comment"> *</span>
<a name="l00056"></a>00056 <span class="comment"> *   Input</span>
<a name="l00057"></a>00057 <span class="comment"> *     - Two meshes &amp; their displacement seq vars</span>
<a name="l00058"></a>00058 <span class="comment"> *     - Min distance that points can be from each other and still be</span>
<a name="l00059"></a>00059 <span class="comment"> *       considered to be touching.</span>
<a name="l00060"></a>00060 <span class="comment"> *</span>
<a name="l00061"></a>00061 <span class="comment"> *   Assumptions: </span>
<a name="l00062"></a>00062 <span class="comment"> *     - Meshes do not interpenetrate (more than some very small amount). </span>
<a name="l00063"></a>00063 <span class="comment"> *     - Faces are planar</span>
<a name="l00064"></a>00064 <span class="comment"> *     - Can determine adjacent surfaces from initial geometry information.</span>
<a name="l00065"></a>00065 <span class="comment"> *</span>
<a name="l00066"></a>00066 <span class="comment"> *   Algorithm:</span>
<a name="l00067"></a>00067 <span class="comment"> *     - Get outside surfaces of each mesh - i.e. skin</span>
<a name="l00068"></a>00068 <span class="comment"> *     - For each mesh, find all vertices that are a) close to a skin face on</span>
<a name="l00069"></a>00069 <span class="comment"> *       the other mesh (close means than if you project the vertex to the </span>
<a name="l00070"></a>00070 <span class="comment"> *       face, it lies within or on boundary of face AND the distance along </span>
<a name="l00071"></a>00071 <span class="comment"> *       that projection is less than the min distance) and b) are in a skin </span>
<a name="l00072"></a>00072 <span class="comment"> *       face themselves that have the same orientation as the face on the </span>
<a name="l00073"></a>00073 <span class="comment"> *       other mesh. Keep track of the vertex, the faces on both meshes, and </span>
<a name="l00074"></a>00074 <span class="comment"> *       the parameterized location of the projected vertex within the face on</span>
<a name="l00075"></a>00075 <span class="comment"> *       the other mesh.</span>
<a name="l00076"></a>00076 <span class="comment"> *     - Create a new mesh which is lines from each vertex to the paramterized</span>
<a name="l00077"></a>00077 <span class="comment"> *       point in the corresponding face on the other mesh. (Line lengths </span>
<a name="l00078"></a>00078 <span class="comment"> *       should all be less than min distance chosen in 1.)</span>
<a name="l00079"></a>00079 <span class="comment"> *     - New! using Shapes, create subsets of the line mesh for each side-side</span>
<a name="l00080"></a>00080 <span class="comment"> *       grouping of gap lines.  </span>
<a name="l00081"></a>00081 <span class="comment"> *     - Create displacement variable for the line mesh.</span>
<a name="l00082"></a>00082 <span class="comment"> *     - Create variable which is the average normal of the two faces the</span>
<a name="l00083"></a>00083 <span class="comment"> *       line connects</span>
<a name="l00084"></a>00084 <span class="comment"> *</span>
<a name="l00085"></a>00085 <span class="comment"> *   Output:</span>
<a name="l00086"></a>00086 <span class="comment"> *     - Report #, and min, max, average and standard dev of line lengths per </span>
<a name="l00087"></a>00087 <span class="comment"> *       step for each set of lines and the overall set of lines. Also report </span>
<a name="l00088"></a>00088 <span class="comment"> *       normal and tangent components.</span>
<a name="l00089"></a>00089 <span class="comment"> *     - Write a gaplines dataset</span>
<a name="l00090"></a>00090 <span class="comment"> *</span>
<a name="l00091"></a>00091 <span class="comment"> * /modifications:</span>
<a name="l00092"></a>00092 <span class="comment"> *    - 01/05 Created, WSK.</span>
<a name="l00093"></a>00093 <span class="comment"> *    - 02/07/06 Had to update to changes in library.</span>
<a name="l00094"></a>00094 <span class="comment"> *    - 06/12/2006 WSD Making into an official tool.</span>
<a name="l00095"></a>00095 <span class="comment"> *    - 08/25/2006 WSD Adding normal &amp; tangent break down of gapline line</span>
<a name="l00096"></a>00096 <span class="comment"> *      lengths (with respect to face normals). Also added break down by sides</span>
<a name="l00097"></a>00097 <span class="comment"> *      using FC_Shape.</span>
<a name="l00098"></a>00098 <span class="comment"> *    - 08/31/2006 WSD Added ability to drop gap lines connected to dead</span>
<a name="l00099"></a>00099 <span class="comment"> *      elements. </span>
<a name="l00100"></a>00100 <span class="comment"> */</span>
<a name="l00101"></a>00101 <span class="preprocessor">#include &lt;string.h&gt;</span>
<a name="l00102"></a>00102 <span class="preprocessor">#include "<a class="code" href="fc_8h.html">fc.h</a>"</span>
<a name="l00103"></a>00103 <span class="preprocessor">#include "<a class="code" href="fcP_8h.html">fcP.h</a>"</span>
<a name="l00104"></a>00104 
<a name="l00105"></a>00105 <span class="comment">// hold info about death vars</span>
<a name="l00106"></a><a class="code" href="structdeathvarinfo.html">00106</a> <span class="keyword">typedef</span> <span class="keyword">struct</span>{
<a name="l00107"></a><a class="code" href="structdeathvarinfo.html#1ebd5a95b4c6e28486008caed06d2728">00107</a>   <span class="keywordtype">char</span>* name;
<a name="l00108"></a><a class="code" href="structdeathvarinfo.html#b70b406afadea0a12dda1670415c1249">00108</a>   <span class="keywordtype">char</span>* op;
<a name="l00109"></a><a class="code" href="structdeathvarinfo.html#27e8b3504f5a5b0ecefb58b992c31031">00109</a>   <span class="keywordtype">double</span> val;
<a name="l00110"></a>00110 } <a class="code" href="structdeathvarinfo.html">deathvarinfo</a>;
<a name="l00111"></a>00111 
<a name="l00112"></a><a class="code" href="gaplines_8c.html#cb3a46b4682216fa4a7faaa40e499a38">00112</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="gaplines_8c.html#cb3a46b4682216fa4a7faaa40e499a38">parseDeathVarSet</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv, <span class="keywordtype">int</span> *idx, <span class="keywordtype">int</span> *numvars,
<a name="l00113"></a>00113                    <a class="code" href="structdeathvarinfo.html">deathvarinfo</a>** deathvars) {
<a name="l00114"></a>00114   <span class="keywordtype">long</span> lcheck;
<a name="l00115"></a>00115   <span class="keywordtype">double</span> dcheck;
<a name="l00116"></a>00116   <span class="keywordtype">int</span> nvars;
<a name="l00117"></a>00117 
<a name="l00118"></a>00118   <span class="keywordtype">char</span>* end_ptr;
<a name="l00119"></a>00119   <span class="keywordtype">int</span> i,j;
<a name="l00120"></a>00120 
<a name="l00121"></a>00121   <span class="keywordflow">if</span> (*numvars !=0){
<a name="l00122"></a>00122     <a class="code" href="group__Library.html#gb41a63cb101314fb41df98cef504a556">fc_printfErrorMessage</a>(<span class="stringliteral">"Invalid deathvar syntax: already have death vars"</span>);
<a name="l00123"></a>00123     <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52e51d318f8c97c8b094cf9820b51e4fa83">FC_ERROR</a>;
<a name="l00124"></a>00124   }
<a name="l00125"></a>00125    
<a name="l00126"></a>00126 
<a name="l00127"></a>00127   i = *idx;
<a name="l00128"></a>00128   <span class="keywordflow">if</span> (argc &lt; *idx+1){
<a name="l00129"></a>00129     <a class="code" href="group__Library.html#gb41a63cb101314fb41df98cef504a556">fc_printfErrorMessage</a>(<span class="stringliteral">"Invalid deathvar syntax: cant get num vars"</span>);
<a name="l00130"></a>00130     <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52e51d318f8c97c8b094cf9820b51e4fa83">FC_ERROR</a>; <span class="comment">//cant get the num of vars</span>
<a name="l00131"></a>00131   }
<a name="l00132"></a>00132 
<a name="l00133"></a>00133   lcheck =  strtol(argv[i], &amp;end_ptr,10);
<a name="l00134"></a>00134   <span class="keywordflow">if</span> (*end_ptr == <span class="charliteral">'\0'</span>){ <span class="comment">//its a number</span>
<a name="l00135"></a>00135     nvars = (int)lcheck;
<a name="l00136"></a>00136   }<span class="keywordflow">else</span> { <span class="comment">//not a number</span>
<a name="l00137"></a>00137     <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52e51d318f8c97c8b094cf9820b51e4fa83">FC_ERROR</a>;
<a name="l00138"></a>00138   }
<a name="l00139"></a>00139 
<a name="l00140"></a>00140   <span class="keywordflow">if</span> (nvars == 0){
<a name="l00141"></a>00141     <a class="code" href="group__Library.html#gb41a63cb101314fb41df98cef504a556">fc_printfErrorMessage</a>(<span class="stringliteral">"Invalid deathvar syntax: no death vars"</span>);
<a name="l00142"></a>00142     <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52e51d318f8c97c8b094cf9820b51e4fa83">FC_ERROR</a>;
<a name="l00143"></a>00143   }
<a name="l00144"></a>00144 
<a name="l00145"></a>00145   <span class="keywordflow">if</span> (argc &lt; i+3*nvars+1){
<a name="l00146"></a>00146     <a class="code" href="group__Library.html#gb41a63cb101314fb41df98cef504a556">fc_printfErrorMessage</a>(<span class="stringliteral">"Invalid deathvar syntax: not enough args for num vars"</span>);
<a name="l00147"></a>00147     <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52e51d318f8c97c8b094cf9820b51e4fa83">FC_ERROR</a>;
<a name="l00148"></a>00148   }
<a name="l00149"></a>00149 
<a name="l00150"></a>00150   *deathvars = (<a class="code" href="structdeathvarinfo.html">deathvarinfo</a>*)malloc(nvars*<span class="keyword">sizeof</span>(<a class="code" href="structdeathvarinfo.html">deathvarinfo</a>));
<a name="l00151"></a>00151   <span class="keywordflow">if</span> (!deathvars){
<a name="l00152"></a>00152     <a class="code" href="group__Library.html#gb41a63cb101314fb41df98cef504a556">fc_printfErrorMessage</a>(<span class="stringliteral">"%s"</span>, <a class="code" href="group__DataTypes.html#g97ca6452d8a5b6625a2c02166dc87bb7">fc_getReturnCodeText</a>(<a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52ee4bf428a2cdead5d4e3e3391a2cdab0d">FC_MEMORY_ERROR</a>));
<a name="l00153"></a>00153     <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52ee4bf428a2cdead5d4e3e3391a2cdab0d">FC_MEMORY_ERROR</a>;
<a name="l00154"></a>00154   }
<a name="l00155"></a>00155 
<a name="l00156"></a>00156   i++;
<a name="l00157"></a>00157   <span class="keywordflow">for</span>(j = 0; j &lt; nvars; j++){
<a name="l00158"></a>00158     (*deathvars)[j].name = argv[i++];
<a name="l00159"></a>00159     (*deathvars)[j].op = argv[i++];
<a name="l00160"></a>00160     dcheck =  strtod(argv[i++], &amp;end_ptr);
<a name="l00161"></a>00161     <span class="keywordflow">if</span> (*end_ptr == <span class="charliteral">'\0'</span>){ <span class="comment">//its a number</span>
<a name="l00162"></a>00162       (*deathvars)[j].val = dcheck;
<a name="l00163"></a>00163     } <span class="keywordflow">else</span>{
<a name="l00164"></a>00164       <a class="code" href="group__Library.html#gb41a63cb101314fb41df98cef504a556">fc_printfErrorMessage</a>(<span class="stringliteral">"Invalid deathvar syntax: non-numerical value for cutoff"</span>);
<a name="l00165"></a>00165       <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52e51d318f8c97c8b094cf9820b51e4fa83">FC_ERROR</a>;
<a name="l00166"></a>00166     }
<a name="l00167"></a>00167   }
<a name="l00168"></a>00168 
<a name="l00169"></a>00169   *numvars = nvars;           
<a name="l00170"></a>00170   *idx = i-1;
<a name="l00171"></a>00171 
<a name="l00172"></a>00172   <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52e27738acee5b8b2ef61be6e9b14a26613">FC_SUCCESS</a>;
<a name="l00173"></a>00173 }
<a name="l00174"></a>00174 
<a name="l00175"></a>00175 <span class="comment">// get max edge length</span>
<a name="l00176"></a><a class="code" href="gaplines_8c.html#a4b9b7eb8ccadfa5bf7039cf115b7223">00176</a> <span class="keyword">static</span> <a class="code" href="group__DataTypes.html#g2a816f8eddef0c2d8c2e3a0393b1f52e">FC_ReturnCode</a> <a class="code" href="gaplines_8c.html#a4b9b7eb8ccadfa5bf7039cf115b7223">getMeshMaxEdgeLength</a>(<a class="code" href="structFC__Mesh.html">FC_Mesh</a> mesh, <span class="keywordtype">double</span>* max_len) {
<a name="l00177"></a>00177   <a class="code" href="group__DataTypes.html#g2a816f8eddef0c2d8c2e3a0393b1f52e">FC_ReturnCode</a> rc;
<a name="l00178"></a>00178   <a class="code" href="structFC__Variable.html">FC_Variable</a> lengths;
<a name="l00179"></a>00179   
<a name="l00180"></a>00180   rc = <a class="code" href="group__GeometricRelations.html#g942ca3d5601ded5ad4f6cde5ff3ec767">fc_getEdgeLengths</a>(mesh, &amp;lengths);
<a name="l00181"></a>00181   <span class="keywordflow">if</span> (rc != <a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52e27738acee5b8b2ef61be6e9b14a26613">FC_SUCCESS</a>)
<a name="l00182"></a>00182     <span class="keywordflow">return</span> rc;
<a name="l00183"></a>00183   rc = <a class="code" href="group__Statistics.html#gee43eccae3de226a5f60d8fabce7a613">fc_getVariableMinMax</a>(lengths, NULL, NULL, max_len, NULL);
<a name="l00184"></a>00184   <span class="keywordflow">return</span> rc;
<a name="l00185"></a>00185 }
<a name="l00186"></a>00186 
<a name="l00187"></a>00187 <span class="comment">// gets the first the orient of the first elem for that face</span>
<a name="l00188"></a>00188 <span class="comment">// assuming that skins will have unique parent element</span>
<a name="l00189"></a>00189 <span class="comment">// other faces are place holders</span>
<a name="l00190"></a><a class="code" href="gaplines_8c.html#5cd3a0ae146dbd7260b0fe8425d006e6">00190</a> <span class="keyword">static</span> <a class="code" href="group__DataTypes.html#g2a816f8eddef0c2d8c2e3a0393b1f52e">FC_ReturnCode</a> <a class="code" href="gaplines_8c.html#5cd3a0ae146dbd7260b0fe8425d006e6">calcFaceOrients</a>(<a class="code" href="structFC__Mesh.html">FC_Mesh</a> mesh, <span class="keywordtype">int</span> numFace, 
<a name="l00191"></a>00191                          <span class="keywordtype">int</span>* faceIDs, <span class="keywordtype">int</span>** faceOrients) {
<a name="l00192"></a>00192   <a class="code" href="group__DataTypes.html#g2a816f8eddef0c2d8c2e3a0393b1f52e">FC_ReturnCode</a> rc;
<a name="l00193"></a>00193   <span class="keywordtype">int</span> i, j;
<a name="l00194"></a>00194   <span class="keywordtype">int</span> numTotalFace;
<a name="l00195"></a>00195   <span class="keywordtype">int</span> numFacePerElem, *elemToFaceConns;
<a name="l00196"></a>00196   <span class="keywordtype">int</span>* elemFaceOrients;
<a name="l00197"></a>00197   <span class="keywordtype">int</span>* numElemPerFace, **elemParentsPerFace;
<a name="l00198"></a>00198   <a class="code" href="group__DataTypes.html#g5d0bf8bd47afb81d89d4c5d60c7d62b4">FC_ElementType</a> elemtype;
<a name="l00199"></a>00199 
<a name="l00200"></a>00200   <span class="comment">// gather info</span>
<a name="l00201"></a>00201   rc = <a class="code" href="group__Mesh.html#g0f4d7e58dc5936fc8f3824cbce0bf7c4">fc_getMeshNumFace</a>(mesh, &amp;numTotalFace);
<a name="l00202"></a>00202   <span class="keywordflow">if</span> (rc != <a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52e27738acee5b8b2ef61be6e9b14a26613">FC_SUCCESS</a>)
<a name="l00203"></a>00203     <span class="keywordflow">return</span> rc;
<a name="l00204"></a>00204   rc = <a class="code" href="group__Mesh.html#g3bb6165352ed68a9dd86957ebae28008">fc_getMeshElementType</a>(mesh, &amp;elemtype);
<a name="l00205"></a>00205   <span class="keywordflow">if</span> (rc != <a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52e27738acee5b8b2ef61be6e9b14a26613">FC_SUCCESS</a>)
<a name="l00206"></a>00206     <span class="keywordflow">return</span> rc;
<a name="l00207"></a>00207   numFacePerElem = <a class="code" href="group__DataTypes.html#g6362db4b2a63e7c5c397ee701c6e783d">fc_getElementTypeNumFace</a>(elemtype);
<a name="l00208"></a>00208   rc = <a class="code" href="group__Mesh.html#gce10d190e3467e0c32fd318b9a0a2a19">fc_getMeshElementToFaceConnsPtr</a>(mesh, &amp;elemToFaceConns);
<a name="l00209"></a>00209   <span class="keywordflow">if</span> (rc != <a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52e27738acee5b8b2ef61be6e9b14a26613">FC_SUCCESS</a>)
<a name="l00210"></a>00210     <span class="keywordflow">return</span> rc;
<a name="l00211"></a>00211   rc = <a class="code" href="group__Mesh.html#g50269cff01d472e3b30ed46d8b91738a">fc_getMeshElementFaceOrientsPtr</a>(mesh, &amp;elemFaceOrients);
<a name="l00212"></a>00212   <span class="keywordflow">if</span> (rc != <a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52e27738acee5b8b2ef61be6e9b14a26613">FC_SUCCESS</a>)
<a name="l00213"></a>00213     <span class="keywordflow">return</span> rc;
<a name="l00214"></a>00214   rc = <a class="code" href="group__PrivateMesh.html#gaaab766d8ce1d4e44e682b0f7aaf3d40">_fc_getMeshElementParentsOfFacesPtr</a>(mesh, &amp;numElemPerFace,
<a name="l00215"></a>00215                             &amp;elemParentsPerFace);
<a name="l00216"></a>00216   <span class="keywordflow">if</span> (rc != <a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52e27738acee5b8b2ef61be6e9b14a26613">FC_SUCCESS</a>)
<a name="l00217"></a>00217     <span class="keywordflow">return</span> rc;
<a name="l00218"></a>00218 
<a name="l00219"></a>00219   <span class="comment">// do it</span>
<a name="l00220"></a>00220   *faceOrients = (<span class="keywordtype">int</span>*)malloc(numTotalFace*<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
<a name="l00221"></a>00221   <span class="keywordflow">if</span> (!(*faceOrients))
<a name="l00222"></a>00222     <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52ee4bf428a2cdead5d4e3e3391a2cdab0d">FC_MEMORY_ERROR</a>;
<a name="l00223"></a>00223   <span class="keywordflow">for</span> (i = 0; i &lt; numFace; i++) {
<a name="l00224"></a>00224     <span class="keywordtype">int</span> elemID = elemParentsPerFace[faceIDs[i]][0];
<a name="l00225"></a>00225 
<a name="l00226"></a>00226     <span class="keywordflow">for</span> (j = 0; j &lt; numFacePerElem; j++) {
<a name="l00227"></a>00227       <span class="keywordflow">if</span> (elemToFaceConns[elemID*numFacePerElem+j] == faceIDs[i]) {
<a name="l00228"></a>00228      (*faceOrients)[faceIDs[i]] = elemFaceOrients[elemID*numFacePerElem+j];
<a name="l00229"></a>00229      <span class="keywordflow">break</span>;
<a name="l00230"></a>00230       }
<a name="l00231"></a>00231     }
<a name="l00232"></a>00232   }
<a name="l00233"></a>00233 
<a name="l00234"></a>00234   <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52e27738acee5b8b2ef61be6e9b14a26613">FC_SUCCESS</a>;
<a name="l00235"></a>00235 }
<a name="l00236"></a>00236 
<a name="l00237"></a>00237 
<a name="l00238"></a>00238 <span class="comment">// Given a mesh of lines and a displacement variable, calculate the lines</span>
<a name="l00239"></a>00239 <span class="comment">// as vectors by subtracting one displaced point from the other</span>
<a name="l00240"></a><a class="code" href="gaplines_8c.html#0c08829553c7fe4564d36fc982cb1bb1">00240</a> <span class="keyword">static</span> <a class="code" href="group__DataTypes.html#g2a816f8eddef0c2d8c2e3a0393b1f52e">FC_ReturnCode</a> <a class="code" href="gaplines_8c.html#0c08829553c7fe4564d36fc982cb1bb1">getLinesAsVectors</a>(<a class="code" href="structFC__Mesh.html">FC_Mesh</a> mesh, <a class="code" href="structFC__Variable.html">FC_Variable</a> displVar,
<a name="l00241"></a>00241                            <a class="code" href="structFC__Variable.html">FC_Variable</a> *lineVectors) {
<a name="l00242"></a>00242   <a class="code" href="group__DataTypes.html#g2a816f8eddef0c2d8c2e3a0393b1f52e">FC_ReturnCode</a> rc;
<a name="l00243"></a>00243   <span class="keywordtype">int</span> i, j;
<a name="l00244"></a>00244   <span class="keywordtype">int</span> numElem, numDim, numVperE = 2; <span class="comment">// assuming lines</span>
<a name="l00245"></a>00245   <span class="keywordtype">double</span>* displCoords;
<a name="l00246"></a>00246   <span class="keywordtype">int</span>* conns;
<a name="l00247"></a>00247   <span class="keywordtype">double</span>* vectors;
<a name="l00248"></a>00248 
<a name="l00249"></a>00249   rc = <a class="code" href="group__Mesh.html#g83a0b8188d49812c8d6d4c883cb8e9c4">fc_getMeshNumElement</a>(mesh, &amp;numElem);
<a name="l00250"></a>00250   <span class="keywordflow">if</span> (rc != <a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52e27738acee5b8b2ef61be6e9b14a26613">FC_SUCCESS</a>)
<a name="l00251"></a>00251     <span class="keywordflow">return</span> rc;  
<a name="l00252"></a>00252   rc = <a class="code" href="group__Mesh.html#geaea4205623196e6b1b58da0b4b82b20">fc_getMeshDim</a>(mesh, &amp;numDim);
<a name="l00253"></a>00253   <span class="keywordflow">if</span> (rc != <a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52e27738acee5b8b2ef61be6e9b14a26613">FC_SUCCESS</a>)
<a name="l00254"></a>00254     <span class="keywordflow">return</span> rc;
<a name="l00255"></a>00255   rc = <a class="code" href="group__GeometricRelations.html#g78716e2414d2a11d92097b70f5d8431c">fc_getDisplacedMeshCoords</a>(mesh, displVar, &amp;displCoords);
<a name="l00256"></a>00256   <span class="keywordflow">if</span> (rc != <a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52e27738acee5b8b2ef61be6e9b14a26613">FC_SUCCESS</a>)
<a name="l00257"></a>00257     <span class="keywordflow">return</span> rc;
<a name="l00258"></a>00258   rc = <a class="code" href="group__Mesh.html#g71ce3ca34963dcc548b6a7c38aa17fd9">fc_getMeshElementConnsPtr</a>(mesh, &amp;conns);
<a name="l00259"></a>00259   <span class="keywordflow">if</span> (rc != <a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52e27738acee5b8b2ef61be6e9b14a26613">FC_SUCCESS</a>)
<a name="l00260"></a>00260     <span class="keywordflow">return</span> rc;
<a name="l00261"></a>00261 
<a name="l00262"></a>00262   vectors = malloc(numElem*numDim*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l00263"></a>00263   <span class="keywordflow">if</span> (!vectors) {
<a name="l00264"></a>00264     <a class="code" href="group__Library.html#gb41a63cb101314fb41df98cef504a556">fc_printfErrorMessage</a>(<span class="stringliteral">"%s"</span>, <a class="code" href="group__DataTypes.html#g97ca6452d8a5b6625a2c02166dc87bb7">fc_getReturnCodeText</a>(<a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52ee4bf428a2cdead5d4e3e3391a2cdab0d">FC_MEMORY_ERROR</a>));
<a name="l00265"></a>00265     <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52ee4bf428a2cdead5d4e3e3391a2cdab0d">FC_MEMORY_ERROR</a>;
<a name="l00266"></a>00266   }
<a name="l00267"></a>00267   <span class="keywordflow">for</span> (i = 0; i &lt; numElem; i++) {
<a name="l00268"></a>00268     <span class="keywordtype">int</span> vert1 = conns[i*numVperE];
<a name="l00269"></a>00269     <span class="keywordtype">int</span> vert2 = conns[i*numVperE+1];
<a name="l00270"></a>00270     <span class="keywordflow">for</span> (j = 0; j &lt; numDim; j++) {
<a name="l00271"></a>00271       vectors[i*numDim+j] = displCoords[vert1*numDim+j] -
<a name="l00272"></a>00272                          displCoords[vert2*numDim+j]; 
<a name="l00273"></a>00273     }
<a name="l00274"></a>00274   }
<a name="l00275"></a>00275   free(displCoords);
<a name="l00276"></a>00276 
<a name="l00277"></a>00277   rc = <a class="code" href="group__Variable.html#g2f498c4fbd85d8094f0f640a17341cb3">fc_createVariable</a>(mesh, <span class="stringliteral">"line vectors"</span>, lineVectors);
<a name="l00278"></a>00278   <span class="keywordflow">if</span> (rc != <a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52e27738acee5b8b2ef61be6e9b14a26613">FC_SUCCESS</a>)
<a name="l00279"></a>00279     <span class="keywordflow">return</span> rc;
<a name="l00280"></a>00280   rc = <a class="code" href="group__Variable.html#g4491a3d96b7252fd5d0de54089d6838d">fc_setVariableDataPtr</a>(*lineVectors, numElem, numDim, <a class="code" href="group__DataTypes.html#gg63044bd7bb5313d8a79ea8a71f1b3040f4be04f2efb0e31c558b6146cf83f191">FC_AT_ELEMENT</a>,
<a name="l00281"></a>00281                     <a class="code" href="group__DataTypes.html#ggf4416c02a52bd37e799d442b985151b367e06c1812f7a0127035e27d14fd597d">FC_MT_VECTOR</a>, <a class="code" href="group__DataTypes.html#ggbbab9b2f35d4bc42e868e4f5853a6297806cef8a12ffc6ef267ac21addb95ab3">FC_DT_DOUBLE</a>, (<span class="keywordtype">void</span>*)vectors);
<a name="l00282"></a>00282   <span class="keywordflow">return</span> rc;
<a name="l00283"></a>00283 }
<a name="l00284"></a>00284 
<a name="l00285"></a>00285 <span class="comment">// find the shape and side that a face is in</span>
<a name="l00286"></a><a class="code" href="gaplines_8c.html#74fcd9342cefc46ed067f5f766289e82">00286</a> <span class="keyword">static</span> <a class="code" href="group__DataTypes.html#g2a816f8eddef0c2d8c2e3a0393b1f52e">FC_ReturnCode</a> <a class="code" href="gaplines_8c.html#74fcd9342cefc46ed067f5f766289e82">findShapeSide</a>(<span class="keywordtype">int</span> faceID, <span class="keywordtype">int</span> numShape, <a class="code" href="structFC__Shape.html">FC_Shape</a>* shapes,
<a name="l00287"></a>00287                        <span class="keywordtype">int</span>* shapeID, <span class="keywordtype">int</span>* sideID) {
<a name="l00288"></a>00288   <span class="keywordtype">int</span> i, j;
<a name="l00289"></a>00289   <span class="keywordflow">for</span> (i = 0; i &lt; numShape; i++) {
<a name="l00290"></a>00290     <span class="keywordflow">for</span> (j = 0; j &lt; shapes[i].<a class="code" href="structFC__Shape.html#0bf1533a6d673f68e4a2b2544f3920d2">numSides</a>; j++) {
<a name="l00291"></a>00291       <span class="keywordflow">if</span> (<a class="code" href="group__Subset.html#ge786dd4486b757ba00e4e78359a460bc">fc_isMemberInSubset</a>(shapes[i].faces[j], faceID)) {
<a name="l00292"></a>00292      *shapeID = i;
<a name="l00293"></a>00293      *sideID = j;
<a name="l00294"></a>00294      <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52e27738acee5b8b2ef61be6e9b14a26613">FC_SUCCESS</a>;
<a name="l00295"></a>00295       }
<a name="l00296"></a>00296     }
<a name="l00297"></a>00297   }
<a name="l00298"></a>00298 
<a name="l00299"></a>00299   *shapeID = -1;
<a name="l00300"></a>00300   *sideID = -1;
<a name="l00301"></a>00301   <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52e51d318f8c97c8b094cf9820b51e4fa83">FC_ERROR</a>;
<a name="l00302"></a>00302 }
<a name="l00303"></a>00303 
<a name="l00304"></a>00304 <span class="comment">// In one go, remove vals from sia1 and sia2 that are the same,</span>
<a name="l00305"></a>00305 <span class="comment">// and stick them in sia3</span>
<a name="l00306"></a><a class="code" href="gaplines_8c.html#8dbbc7f24e3ff9d7d456001329e56dc2">00306</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="gaplines_8c.html#8dbbc7f24e3ff9d7d456001329e56dc2">getRemoveSIAIntersection</a>(<a class="code" href="structFC__SortedIntArray.html">FC_SortedIntArray</a> *sia1,
<a name="l00307"></a>00307                          <a class="code" href="structFC__SortedIntArray.html">FC_SortedIntArray</a> *sia2, 
<a name="l00308"></a>00308                          <a class="code" href="structFC__SortedIntArray.html">FC_SortedIntArray</a> *sia3) {
<a name="l00309"></a>00309   <span class="keywordtype">int</span> i, j;
<a name="l00310"></a>00310   i = 0;
<a name="l00311"></a>00311   j = 0;
<a name="l00312"></a>00312   <span class="keywordflow">while</span> (i &lt; sia1-&gt;numVal &amp;&amp; j &lt; sia2-&gt;numVal) {
<a name="l00313"></a>00313     <span class="keywordflow">if</span> (sia1-&gt;<a class="code" href="structFC__SortedIntArray.html#60520a789b3d255c10053389b65bab10">vals</a>[i] &lt; sia2-&gt;<a class="code" href="structFC__SortedIntArray.html#60520a789b3d255c10053389b65bab10">vals</a>[j]) {
<a name="l00314"></a>00314       i++;
<a name="l00315"></a>00315     }
<a name="l00316"></a>00316     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (sia1-&gt;<a class="code" href="structFC__SortedIntArray.html#60520a789b3d255c10053389b65bab10">vals</a>[i] &gt; sia2-&gt;<a class="code" href="structFC__SortedIntArray.html#60520a789b3d255c10053389b65bab10">vals</a>[j]) {
<a name="l00317"></a>00317       j++;
<a name="l00318"></a>00318     }
<a name="l00319"></a>00319     <span class="keywordflow">else</span> {
<a name="l00320"></a>00320       <a class="code" href="group__SimpleDataObjects.html#g64768f52c122c1cd322cbebac85979f2">fc_addIntToSortedIntArray</a>(sia3, sia1-&gt;<a class="code" href="structFC__SortedIntArray.html#60520a789b3d255c10053389b65bab10">vals</a>[i]);
<a name="l00321"></a>00321       <a class="code" href="group__PrivateSimpleDataObjects.html#g3f093f8eb642611ba02681cb14fc91e5">_fc_deleteEntryFromSortedIntArray</a>(sia1, i);
<a name="l00322"></a>00322       <a class="code" href="group__PrivateSimpleDataObjects.html#g3f093f8eb642611ba02681cb14fc91e5">_fc_deleteEntryFromSortedIntArray</a>(sia2, j);
<a name="l00323"></a>00323       <span class="comment">// don't increment i or j</span>
<a name="l00324"></a>00324     }
<a name="l00325"></a>00325   }
<a name="l00326"></a>00326 }
<a name="l00327"></a>00327 
<a name="l00328"></a>00328 <span class="comment">// determine if line connecting elements is dead or not</span>
<a name="l00329"></a>00329 <span class="comment">// only one of the elements has to be dead</span>
<a name="l00330"></a><a class="code" href="gaplines_8c.html#924ef643e120d02e293b8afea03f1d69">00330</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="gaplines_8c.html#924ef643e120d02e293b8afea03f1d69">isItDead</a>(<span class="keywordtype">int</span> numDeathVar, <a class="code" href="structdeathvarinfo.html">deathvarinfo</a>* deathvarinfos, <span class="keywordtype">int</span> id1,
<a name="l00331"></a>00331               <span class="keywordtype">double</span>** data1, <span class="keywordtype">int</span> id2, <span class="keywordtype">double</span>** data2) {
<a name="l00332"></a>00332   <span class="keywordtype">int</span> i;
<a name="l00333"></a>00333   <span class="keywordtype">int</span> isItDead1 = 0, isItDead2 = 0;  <span class="comment">// start off assuming dead</span>
<a name="l00334"></a>00334 
<a name="l00335"></a>00335   <span class="keywordflow">for</span> (i = 0; i &lt; numDeathVar; i++) {
<a name="l00336"></a>00336     <span class="keywordtype">int</span> (*compare)(<span class="keywordtype">double</span>, <span class="keywordtype">double</span>);
<a name="l00337"></a>00337     <span class="keywordtype">char</span>* compare_str = deathvarinfos[i].<a class="code" href="structdeathvarinfo.html#b70b406afadea0a12dda1670415c1249">op</a>;
<a name="l00338"></a>00338 
<a name="l00339"></a>00339     <span class="comment">// determine comparison</span>
<a name="l00340"></a>00340     <span class="comment">// break out at the first dead classification</span>
<a name="l00341"></a>00341     <span class="keywordflow">if</span> (!strcmp(compare_str, <span class="stringliteral">"="</span>) || !strcmp(compare_str, <span class="stringliteral">"=="</span>))
<a name="l00342"></a>00342       compare = <a class="code" href="group__PublicFloatingPoint.html#gd4d16c33b78d242d7c582c61abe2afda">fc_eqd</a>;
<a name="l00343"></a>00343     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!strcmp(compare_str, <span class="stringliteral">"!="</span>) || !strcmp(compare_str, <span class="stringliteral">"=!"</span>))
<a name="l00344"></a>00344       compare = <a class="code" href="group__PublicFloatingPoint.html#g89930c19cd30cc03d43dfced41c3b7b5">fc_neqd</a>;
<a name="l00345"></a>00345     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!strcmp(compare_str, <span class="stringliteral">"&lt;"</span>))
<a name="l00346"></a>00346       compare = <a class="code" href="group__PublicFloatingPoint.html#g0e8dadc920de512f0695f7fab65b9072">fc_ltd</a>;
<a name="l00347"></a>00347     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!strcmp(compare_str, <span class="stringliteral">"&lt;="</span>) || !strcmp(compare_str, <span class="stringliteral">"=&lt;"</span>))
<a name="l00348"></a>00348     compare = <a class="code" href="group__PublicFloatingPoint.html#g9714952e76c7be683b56ff1b8d437b93">fc_lteqd</a>;
<a name="l00349"></a>00349     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!strcmp(compare_str, <span class="stringliteral">"&gt;"</span>))
<a name="l00350"></a>00350       compare = <a class="code" href="group__PublicFloatingPoint.html#g94f8391d98988b0cff3796b546140f3d">fc_gtd</a>;
<a name="l00351"></a>00351     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!strcmp(compare_str, <span class="stringliteral">"&gt;="</span>) || !strcmp(compare_str, <span class="stringliteral">"=&gt;"</span>))
<a name="l00352"></a>00352       compare = <a class="code" href="group__PublicFloatingPoint.html#g7b08124983995d7a0e76a544012a5de1">fc_gteqd</a>;
<a name="l00353"></a>00353     <span class="keywordflow">else</span> {
<a name="l00354"></a>00354       <a class="code" href="group__Library.html#gb41a63cb101314fb41df98cef504a556">fc_printfErrorMessage</a>(<span class="stringliteral">"Unknown comparison string: '%s'"</span>, compare_str);
<a name="l00355"></a>00355       <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52e4905abab801292d8b6338a89462b8e22">FC_INPUT_ERROR</a>;
<a name="l00356"></a>00356     }
<a name="l00357"></a>00357     
<a name="l00358"></a>00358     <span class="keywordflow">if</span> (compare(data1[i][id1], deathvarinfos[i].val)) {
<a name="l00359"></a>00359       isItDead1 = 1;
<a name="l00360"></a>00360       <span class="keywordflow">break</span>;
<a name="l00361"></a>00361     }
<a name="l00362"></a>00362     <span class="keywordflow">if</span> (compare(data2[i][id2], deathvarinfos[i].val)) {
<a name="l00363"></a>00363       isItDead2 = 1;
<a name="l00364"></a>00364       <span class="keywordflow">break</span>;
<a name="l00365"></a>00365     }
<a name="l00366"></a>00366   }
<a name="l00367"></a>00367 
<a name="l00368"></a>00368   <span class="keywordflow">if</span> (isItDead1 || isItDead2)
<a name="l00369"></a>00369     <span class="keywordflow">return</span> 1;
<a name="l00370"></a>00370   <span class="keywordflow">else</span>
<a name="l00371"></a>00371     <span class="keywordflow">return</span> 0;
<a name="l00372"></a>00372 }
<a name="l00373"></a>00373 
<a name="l00374"></a>00374 
<a name="l00375"></a>00375 <span class="comment">// print the stats of a specific seqVar over time</span>
<a name="l00376"></a>00376 <span class="comment">// pass in NULL for subset, or pointer to subset</span>
<a name="l00377"></a><a class="code" href="gaplines_8c.html#29506051f4d43ef02475c1242af995c5">00377</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="gaplines_8c.html#29506051f4d43ef02475c1242af995c5">printStats</a>(<span class="keywordtype">char</span>* title, <span class="keywordtype">int</span> numStep, <a class="code" href="structFC__Variable.html">FC_Variable</a>* lengthSeqVar,
<a name="l00378"></a>00378                  <a class="code" href="structFC__Subset.html">FC_Subset</a>* inputSubset, <a class="code" href="structFC__Subset.html">FC_Subset</a>* alivePerTime,
<a name="l00379"></a>00379                  <span class="keywordtype">double</span>* seq_coords) {
<a name="l00380"></a>00380   <span class="keywordtype">int</span> i;
<a name="l00381"></a>00381   <a class="code" href="structFC__Subset.html">FC_Subset</a> temp_subset, subsets[numStep];
<a name="l00382"></a>00382 
<a name="l00383"></a>00383   <span class="comment">// If not input subset, make a subset that is the entire mesh</span>
<a name="l00384"></a>00384   <span class="keywordflow">if</span> (inputSubset)
<a name="l00385"></a>00385     temp_subset = *inputSubset;
<a name="l00386"></a>00386   <span class="keywordflow">else</span> {
<a name="l00387"></a>00387     <span class="keywordtype">int</span> numMember;
<a name="l00388"></a>00388     <a class="code" href="structFC__Mesh.html">FC_Mesh</a> mesh;
<a name="l00389"></a>00389     <a class="code" href="group__Variable.html#g18aa101c04f3d2189a1f1e4d68c9dc2a">fc_getMeshFromVariable</a>(lengthSeqVar[0], &amp;mesh);
<a name="l00390"></a>00390     <a class="code" href="group__Mesh.html#g83a0b8188d49812c8d6d4c883cb8e9c4">fc_getMeshNumElement</a>(mesh, &amp;numMember);
<a name="l00391"></a>00391     <a class="code" href="group__Subset.html#g40d47282abccd83987c83e8051064db2">fc_createSubset</a>(mesh, <span class="stringliteral">"temp"</span>, <a class="code" href="group__DataTypes.html#gg63044bd7bb5313d8a79ea8a71f1b3040f4be04f2efb0e31c558b6146cf83f191">FC_AT_ELEMENT</a>, &amp;temp_subset);
<a name="l00392"></a>00392     <span class="keywordflow">for</span> (i = 0; i &lt; numMember; i++)
<a name="l00393"></a>00393       <a class="code" href="group__Subset.html#gf105b25f063533c8bdc24a6e0f1d1002">fc_addMemberToSubset</a>(temp_subset, i);
<a name="l00394"></a>00394   }
<a name="l00395"></a>00395 
<a name="l00396"></a>00396   <span class="comment">// If death is possible, find the ones that are still alive</span>
<a name="l00397"></a>00397   <span class="keywordflow">if</span> (alivePerTime) {
<a name="l00398"></a>00398     <span class="keywordflow">for</span> (i = 0; i &lt; numStep; i++)
<a name="l00399"></a>00399       <a class="code" href="group__Subset.html#gdc68d18522eac86b0c3eeb655e91f80b">fc_createSubsetIntersection</a>(temp_subset, <span class="stringliteral">"&amp;&amp;"</span>, alivePerTime[i],
<a name="l00400"></a>00400                       <span class="stringliteral">"temp"</span>, &amp;subsets[i]);
<a name="l00401"></a>00401   }
<a name="l00402"></a>00402   <span class="keywordflow">else</span> {
<a name="l00403"></a>00403     <span class="keywordflow">for</span> (i = 0; i &lt; numStep; i++)
<a name="l00404"></a>00404       subsets[i] = temp_subset;
<a name="l00405"></a>00405   }
<a name="l00406"></a>00406 
<a name="l00407"></a>00407   <span class="comment">// print the stats</span>
<a name="l00408"></a>00408   printf(<span class="stringliteral">"----------------------------------------------------------------\n"</span>); 
<a name="l00409"></a>00409   printf(<span class="stringliteral">"    Step      |      |    %s\n"</span>, title);
<a name="l00410"></a>00410   printf(<span class="stringliteral">"--------------|------|------------------------------------------\n"</span>);
<a name="l00411"></a>00411   printf(<span class="stringliteral">"ID     Value  |  num |    min        max        mean      stdev\n"</span>);
<a name="l00412"></a>00412   printf(<span class="stringliteral">"----------------------------------------------------------------\n"</span>);
<a name="l00413"></a>00413   <span class="keywordflow">for</span> (i = 0; i &lt; numStep; i++) {
<a name="l00414"></a>00414     <span class="keywordtype">int</span> num;
<a name="l00415"></a>00415     <span class="keywordtype">double</span> min, max, mean, stdev;
<a name="l00416"></a>00416     <a class="code" href="group__Subset.html#g8b932d306fb8f41ef49677f803fd9fd1">fc_getSubsetNumMember</a>(subsets[i], &amp;num);
<a name="l00417"></a>00417     <a class="code" href="group__Statistics.html#g4629fd93464ae8ca436f8c12c46cc9aa">fc_getVariableSubsetMinMax</a>(lengthSeqVar[i], subsets[i], &amp;min, NULL, 
<a name="l00418"></a>00418                       &amp;max, NULL);
<a name="l00419"></a>00419     <a class="code" href="group__Statistics.html#g1e581c90f89434b3f86e02e5e33e67b8">fc_getVariableSubsetMeanSdev</a>(lengthSeqVar[i], subsets[i], &amp;mean, &amp;stdev);
<a name="l00420"></a>00420     printf(<span class="stringliteral">"%-2d %10f %6d %10f %10f %10f %10f\n"</span>, i, seq_coords[i], num,
<a name="l00421"></a>00421         min, max, mean, stdev);
<a name="l00422"></a>00422     fflush(NULL);
<a name="l00423"></a>00423   }
<a name="l00424"></a>00424 
<a name="l00425"></a>00425   <span class="keywordflow">if</span> (!inputSubset)
<a name="l00426"></a>00426     <a class="code" href="group__Subset.html#gfdcc399692041499cc461916a9973558">fc_deleteSubset</a>(temp_subset);
<a name="l00427"></a>00427   <span class="keywordflow">if</span> (alivePerTime) {
<a name="l00428"></a>00428     <span class="keywordflow">for</span> (i = 0; i &lt; numStep; i++)
<a name="l00429"></a>00429       <a class="code" href="group__Subset.html#gfdcc399692041499cc461916a9973558">fc_deleteSubset</a>(subsets[i]);
<a name="l00430"></a>00430   }
<a name="l00431"></a>00431 }
<a name="l00432"></a>00432 
<a name="l00433"></a><a class="code" href="gaplines_8c.html#24e6ce6d053864cf5fb7af941457bb0e">00433</a> <span class="keywordtype">int</span> <a class="code" href="analyzeSpotWelds_8c.html#24e6ce6d053864cf5fb7af941457bb0e">main</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv) {
<a name="l00434"></a>00434   <a class="code" href="group__DataTypes.html#g2a816f8eddef0c2d8c2e3a0393b1f52e">FC_ReturnCode</a> rc;
<a name="l00435"></a>00435   <a class="code" href="group__DataTypes.html#g6c0891f21e34bad1d8b2bc7c76193a39">FC_VerbosityLevel</a> verbose_level = <a class="code" href="group__DataTypes.html#gg6c0891f21e34bad1d8b2bc7c76193a399cb0ad9c1f97775f8954860a08d78144">FC_QUIET</a>;
<a name="l00436"></a>00436   <span class="keywordtype">int</span> i, j, k, m, n;
<a name="l00437"></a>00437   <span class="keywordtype">int</span> numDeathVar = 0;
<a name="l00438"></a>00438   <a class="code" href="structdeathvarinfo.html">deathvarinfo</a>* deathVarInfos;
<a name="l00439"></a>00439   <a class="code" href="structFC__Dataset.html">FC_Dataset</a> dataset;
<a name="l00440"></a>00440   <a class="code" href="structFC__Sequence.html">FC_Sequence</a> sequence, sequences[2];
<a name="l00441"></a>00441   <a class="code" href="structFC__Mesh.html">FC_Mesh</a> meshes[2], gap_mesh;
<a name="l00442"></a>00442   <a class="code" href="structFC__Variable.html">FC_Variable</a> *displs[2], **deathVars[2];
<a name="l00443"></a>00443   <a class="code" href="structFC__Variable.html">FC_Variable</a> *gap_displ, *aveFaceNorms, *isDeadVar = NULL;
<a name="l00444"></a>00444   <a class="code" href="structFC__Variable.html">FC_Variable</a> *lengths, *norms, *tangs;
<a name="l00445"></a>00445   <a class="code" href="structFC__Subset.html">FC_Subset</a> face_skins[2], vert_skins[2];
<a name="l00446"></a>00446   <a class="code" href="structFC__Subset.html">FC_Subset</a> *alivePerTime;
<a name="l00447"></a>00447   <span class="keywordtype">char</span>* file_name = NULL;
<a name="l00448"></a>00448   <span class="keywordtype">char</span>* mesh_names[2] = { NULL, NULL };
<a name="l00449"></a>00449   <span class="keywordtype">char</span>* displ_name = NULL;
<a name="l00450"></a>00450   <span class="keywordtype">char</span> charBuf[1024];
<a name="l00451"></a>00451   <span class="keywordtype">int</span> numDims[2], numDim, numStep;
<a name="l00452"></a>00452   <span class="keywordtype">double</span> max_lens[2]; <span class="comment">// maximum edge length</span>
<a name="l00453"></a>00453   <span class="keywordtype">double</span> max_dists[2]; <span class="comment">// maximum possible distance between point in quad </span>
<a name="l00454"></a>00454                        <span class="comment">// and the vert (in the quad) furthest from point</span>
<a name="l00455"></a>00455                        <span class="comment">// see also documentation at the calc below</span>
<a name="l00456"></a>00456   <span class="keywordtype">double</span> *coords[2];
<a name="l00457"></a>00457   <span class="keywordtype">int</span> *numFacePerVert[2], **faceParentsPerVert[2];
<a name="l00458"></a>00458   <span class="keywordtype">int</span> *numElemPerFace[2], **elemParentsPerFace[2];
<a name="l00459"></a>00459   <span class="keywordtype">int</span> *numVertexPerFace[2], *faceToVertConns[2], stride[2];
<a name="l00460"></a>00460   <span class="keywordtype">int</span> numVertIDs[2], *vertIDs[2], numFaceIDs[2], *faceIDs[2];
<a name="l00461"></a>00461   <span class="keywordtype">int</span> *faceOrients[2];
<a name="l00462"></a>00462   <span class="keywordtype">int</span> numKeeps[2], *keepVertIDs[2], *keepThisFaceIDs[2], *keepOtherFaceIDs[2];
<a name="l00463"></a>00463   <span class="keywordtype">double</span> **keepParams[2];
<a name="l00464"></a>00464   <a class="code" href="structFC__VertexBin.html">FC_VertexBin</a> *bins[2];
<a name="l00465"></a>00465   <span class="keywordtype">double</span> min_dist = 0.001; <span class="comment">// critical distance to identify "joined" meshes</span>
<a name="l00466"></a>00466   <span class="keywordtype">double</span>* seq_coords;
<a name="l00467"></a>00467   <span class="keywordtype">double</span> angle = 80; <span class="comment">// faces with angles greater than this are on diff faces</span>
<a name="l00468"></a>00468   <span class="keywordtype">int</span> numShapes[2];
<a name="l00469"></a>00469   <a class="code" href="structFC__Shape.html">FC_Shape</a> *shapes[2];
<a name="l00470"></a>00470   <span class="keywordtype">int</span> numSide;
<a name="l00471"></a>00471   <a class="code" href="structFC__Subset.html">FC_Subset</a> *sides;
<a name="l00472"></a>00472 
<a name="l00473"></a>00473   <span class="comment">// handle arguments</span>
<a name="l00474"></a>00474   <span class="keywordflow">if</span> (argc &lt; 6) {
<a name="l00475"></a>00475   usage:
<a name="l00476"></a>00476     printf(<span class="stringliteral">"usage: %s [options] dataset mesh1name mesh2name displvarname min_dist\n"</span>,
<a name="l00477"></a>00477         argv[0]);
<a name="l00478"></a>00478     printf(<span class="stringliteral">"   -n # &lt;triplets&gt; : Specify the rules for finding dead elements.\n"</span>);
<a name="l00479"></a>00479     printf(<span class="stringliteral">"                     The first parameter is the number of triplets. Each\n"</span>); 
<a name="l00480"></a>00480     printf(<span class="stringliteral">"                     triplet is the name of variable to test, the comparison\n"</span>);
<a name="l00481"></a>00481     printf(<span class="stringliteral">"                     operator, and the value. The default is \n"</span>);
<a name="l00482"></a>00482     printf(<span class="stringliteral">"                     '-n 1 elem_death \"&lt;=\" 0', meaning all elements\n"</span>);
<a name="l00483"></a>00483     printf(<span class="stringliteral">"                     where the variable 'elem_death' is less than or\n"</span>);
<a name="l00484"></a>00484     printf(<span class="stringliteral">"                     equal to zero are treated as being dead.\n"</span>);
<a name="l00485"></a>00485     printf(<span class="stringliteral">"   -h              : print this help message\n"</span>);
<a name="l00486"></a>00486     printf(<span class="stringliteral">"   -v              : verbose: print calculation status and print warning\n"</span>);
<a name="l00487"></a>00487     printf(<span class="stringliteral">"                     and error messages\n"</span>);
<a name="l00488"></a>00488     printf(<span class="stringliteral">"   -V              : very verbose: print log and error messages\n"</span>);
<a name="l00489"></a>00489     printf(<span class="stringliteral">"\n"</span>);
<a name="l00490"></a>00490     printf(<span class="stringliteral">"Report gaps that form between the specified meshes assuming that surfaces\n"</span>);
<a name="l00491"></a>00491     printf(<span class="stringliteral">"of interest are those that are less than min_dist apart. This program will\n"</span>);
<a name="l00492"></a>00492     printf(<span class="stringliteral">"also create a dataset file 'gaplines.ex2' containing the gap lines.\n"</span>); 
<a name="l00493"></a>00493     printf(<span class="stringliteral">"If dead elements are specified, gaplines attached to dead elements will \n"</span>);
<a name="l00494"></a>00494     printf(<span class="stringliteral">"be dropped for stat calcs.\n"</span>);
<a name="l00495"></a>00495     printf(<span class="stringliteral">"\n"</span>);
<a name="l00496"></a>00496     fflush(NULL);
<a name="l00497"></a>00497     exit(-1);
<a name="l00498"></a>00498   }
<a name="l00499"></a>00499   <span class="keywordflow">for</span> (i = 1; i &lt; argc; i++) {
<a name="l00500"></a>00500     <span class="keywordflow">if</span> (!strcmp(argv[i], <span class="stringliteral">"-v"</span>)) {
<a name="l00501"></a>00501       verbose_level = <a class="code" href="group__DataTypes.html#gg6c0891f21e34bad1d8b2bc7c76193a3995521f4f1526a6565b08e663106dd6e7">FC_WARNING_MESSAGES</a>;
<a name="l00502"></a>00502     }
<a name="l00503"></a>00503     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!strcmp(argv[i], <span class="stringliteral">"-V"</span>)) {
<a name="l00504"></a>00504       verbose_level = <a class="code" href="group__DataTypes.html#gg6c0891f21e34bad1d8b2bc7c76193a395a6192ba586cd970dd36a49cd8862714">FC_LOG_MESSAGES</a>;
<a name="l00505"></a>00505     }
<a name="l00506"></a>00506     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!strncmp(argv[i], <span class="stringliteral">"-h"</span>, 2))
<a name="l00507"></a>00507       <span class="keywordflow">goto</span> usage;
<a name="l00508"></a>00508     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!strcmp(argv[i], <span class="stringliteral">"-n"</span>)) {
<a name="l00509"></a>00509       i++;
<a name="l00510"></a>00510       rc = <a class="code" href="gaplines_8c.html#cb3a46b4682216fa4a7faaa40e499a38">parseDeathVarSet</a>(argc, argv, &amp;i, &amp;numDeathVar, &amp;deathVarInfos);
<a name="l00511"></a>00511       <span class="keywordflow">if</span> (rc != <a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52e27738acee5b8b2ef61be6e9b14a26613">FC_SUCCESS</a>)
<a name="l00512"></a>00512      <span class="keywordflow">goto</span> usage;
<a name="l00513"></a>00513     }
<a name="l00514"></a>00514     <span class="keywordflow">else</span> {
<a name="l00515"></a>00515       <span class="keywordflow">if</span> (i+4 &gt;= argc)
<a name="l00516"></a>00516         <span class="keywordflow">goto</span> usage;
<a name="l00517"></a>00517       file_name = argv[i];
<a name="l00518"></a>00518       mesh_names[0] = argv[i+1];
<a name="l00519"></a>00519       mesh_names[1] = argv[i+2];
<a name="l00520"></a>00520       displ_name = argv[i+3];
<a name="l00521"></a>00521       min_dist = atof(argv[i+4]);
<a name="l00522"></a>00522       i+=4;
<a name="l00523"></a>00523     }
<a name="l00524"></a>00524   }
<a name="l00525"></a>00525   
<a name="l00526"></a>00526   <span class="keywordflow">if</span> (!file_name || !mesh_names[0] || !mesh_names[1] || !displ_name || 
<a name="l00527"></a>00527       min_dist &lt; 0.)
<a name="l00528"></a>00528      <span class="keywordflow">goto</span> usage;
<a name="l00529"></a>00529 
<a name="l00530"></a>00530   <span class="comment">// Init library &amp; load dataset</span>
<a name="l00531"></a>00531   rc = <a class="code" href="group__Library.html#gf13f047de6d44c9028d4944bc29867db">fc_setLibraryVerbosity</a>(verbose_level);
<a name="l00532"></a>00532   <a class="code" href="group__ErrorHandling.html#g4a09c0024ecd45d5d63c8b9ec333a717">fc_exitIfError</a>(rc);
<a name="l00533"></a>00533   rc = <a class="code" href="group__Library.html#g355d03ffe3f8c560e9343716f78af097">fc_initLibrary</a>();
<a name="l00534"></a>00534   <a class="code" href="group__ErrorHandling.html#g4a09c0024ecd45d5d63c8b9ec333a717">fc_exitIfError</a>(rc);
<a name="l00535"></a>00535   rc = <a class="code" href="group__FileIO.html#g953a8c4a7feb785e0091b7cf58626092">fc_loadDataset</a>(file_name, &amp;dataset);
<a name="l00536"></a>00536   <a class="code" href="error_8h.html#42c09317184affa18e70826cb35f3f04">fc_exitIfErrorPrintf</a>(rc, <span class="stringliteral">"Failed to load dataset '%s'"</span>, file_name);
<a name="l00537"></a>00537 
<a name="l00538"></a>00538   <span class="comment">// Get sequence, meshes, displacement seqVars &amp; death seqVars</span>
<a name="l00539"></a>00539   <span class="keywordflow">for</span> (i = 0; i &lt; 2; i++) {
<a name="l00540"></a>00540     <a class="code" href="group__DataTypes.html#g63044bd7bb5313d8a79ea8a71f1b3040">FC_AssociationType</a> temp_assoc;
<a name="l00541"></a>00541     <a class="code" href="structFC__Mesh.html">FC_Mesh</a> *returnMeshes;
<a name="l00542"></a>00542     <span class="keywordtype">int</span> numReturnMeshes;
<a name="l00543"></a>00543 
<a name="l00544"></a>00544     rc = <a class="code" href="group__Mesh.html#g8f35371531555da3b336a94d7ce3053d">fc_getMeshByName</a>(dataset, mesh_names[i], &amp;numReturnMeshes,
<a name="l00545"></a>00545                  &amp;returnMeshes);
<a name="l00546"></a>00546     <a class="code" href="error_8h.html#42c09317184affa18e70826cb35f3f04">fc_exitIfErrorPrintf</a>(rc,<span class="stringliteral">"Failed to get mesh by name"</span>);
<a name="l00547"></a>00547     <span class="keywordflow">if</span> (numReturnMeshes != 1){
<a name="l00548"></a>00548       <a class="code" href="error_8h.html#42c09317184affa18e70826cb35f3f04">fc_exitIfErrorPrintf</a>(<a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52e4905abab801292d8b6338a89462b8e22">FC_INPUT_ERROR</a>,
<a name="l00549"></a>00549                   <span class="stringliteral">"Problems finding (unique) mesh '%s' - found %d matches"</span>,
<a name="l00550"></a>00550                   mesh_names[i], numReturnMeshes);
<a name="l00551"></a>00551     }
<a name="l00552"></a>00552     meshes[i] = returnMeshes[0];
<a name="l00553"></a>00553     free(returnMeshes);
<a name="l00554"></a>00554 
<a name="l00555"></a>00555     rc = <a class="code" href="group__Mesh.html#geaea4205623196e6b1b58da0b4b82b20">fc_getMeshDim</a>(meshes[i], &amp;numDims[i]);
<a name="l00556"></a>00556     <a class="code" href="error_8h.html#42c09317184affa18e70826cb35f3f04">fc_exitIfErrorPrintf</a>(rc, <span class="stringliteral">"Failed to get numDim of mesh '%s'"</span>,
<a name="l00557"></a>00557                 mesh_names[i]);
<a name="l00558"></a>00558     rc = <a class="code" href="group__Variable.html#g81cdc76a742e4bbf85fcbf5deba8c0e7">fc_getOrGenerateUniqueSeqVariableByName</a>(meshes[i], displ_name,
<a name="l00559"></a>00559                                &amp;numStep, &amp;displs[i]);
<a name="l00560"></a>00560     <a class="code" href="error_8h.html#42c09317184affa18e70826cb35f3f04">fc_exitIfErrorPrintf</a>(rc, <span class="stringliteral">"Failed to find or generate seqVar '%s' in mesh '%s'"</span>, 
<a name="l00561"></a>00561                 displ_name, mesh_names[i]);
<a name="l00562"></a>00562     
<a name="l00563"></a>00563     <span class="keywordflow">if</span> (!<a class="code" href="group__GeometricRelations.html#gcffba2f092986b21bf1fc2e2e50c8d6e">fc_isValidDisplacementVariable</a>(meshes[i], displs[i][0]))
<a name="l00564"></a>00564       <a class="code" href="error_8h.html#42c09317184affa18e70826cb35f3f04">fc_exitIfErrorPrintf</a>(rc, <span class="stringliteral">"'%s' is not a valid displacement variable"</span>,
<a name="l00565"></a>00565                   displ_name);
<a name="l00566"></a>00566     rc = <a class="code" href="group__Variable.html#gea428de5a2584716f6e2bc77cd339544">fc_getSequenceFromSeqVariable</a>(numStep, displs[i], &amp;sequences[i]);
<a name="l00567"></a>00567     <a class="code" href="error_8h.html#42c09317184affa18e70826cb35f3f04">fc_exitIfErrorPrintf</a>(rc, <span class="stringliteral">"failed to get sequence"</span>);
<a name="l00568"></a>00568     <span class="keywordflow">if</span> (numDeathVar &gt; 0) {
<a name="l00569"></a>00569       deathVars[i] = (<a class="code" href="structFC__Variable.html">FC_Variable</a>**)malloc(numDeathVar*<span class="keyword">sizeof</span>(<a class="code" href="structFC__Variable.html">FC_Variable</a>*));
<a name="l00570"></a>00570       <span class="keywordflow">if</span> (!deathVars[i])
<a name="l00571"></a>00571      <a class="code" href="group__ErrorHandling.html#g4a09c0024ecd45d5d63c8b9ec333a717">fc_exitIfError</a>(<a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52ee4bf428a2cdead5d4e3e3391a2cdab0d">FC_MEMORY_ERROR</a>);
<a name="l00572"></a>00572       <span class="keywordflow">for</span> (j = 0; j &lt; numDeathVar; j++) {
<a name="l00573"></a>00573      rc = <a class="code" href="group__Variable.html#g81cdc76a742e4bbf85fcbf5deba8c0e7">fc_getOrGenerateUniqueSeqVariableByName</a>(meshes[i],
<a name="l00574"></a>00574                                    deathVarInfos[j].name,
<a name="l00575"></a>00575                                    &amp;numStep,
<a name="l00576"></a>00576                                    &amp;deathVars[i][j]);
<a name="l00577"></a>00577      <a class="code" href="error_8h.html#42c09317184affa18e70826cb35f3f04">fc_exitIfErrorPrintf</a>(rc, <span class="stringliteral">"Failed to find or generate seqVar '%s' in mesh '%s'"</span>, 
<a name="l00578"></a>00578                     deathVarInfos[j].name, mesh_names[i]);
<a name="l00579"></a>00579 
<a name="l00580"></a>00580      <a class="code" href="group__Variable.html#g36c4ac9f503bcf040c378c06e1ad9188">fc_getVariableAssociationType</a>(deathVars[i][j][0], &amp;temp_assoc);
<a name="l00581"></a>00581      <span class="keywordflow">if</span> (temp_assoc != <a class="code" href="group__DataTypes.html#gg63044bd7bb5313d8a79ea8a71f1b3040f4be04f2efb0e31c558b6146cf83f191">FC_AT_ELEMENT</a>) {
<a name="l00582"></a>00582        <a class="code" href="error_8h.html#42c09317184affa18e70826cb35f3f04">fc_exitIfErrorPrintf</a>(<a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52e51d318f8c97c8b094cf9820b51e4fa83">FC_ERROR</a>, <span class="stringliteral">"Death var '%s' should be of assoc "</span>
<a name="l00583"></a>00583                       <span class="stringliteral">"%s not %s'"</span>, deathVarInfos[j].name,
<a name="l00584"></a>00584                       <a class="code" href="group__DataTypes.html#gdb7ce28f8a85a1cc1e68b55f64eb54f5">fc_getAssociationTypeText</a>(<a class="code" href="group__DataTypes.html#gg63044bd7bb5313d8a79ea8a71f1b3040f4be04f2efb0e31c558b6146cf83f191">FC_AT_ELEMENT</a>),
<a name="l00585"></a>00585                       <a class="code" href="group__DataTypes.html#gdb7ce28f8a85a1cc1e68b55f64eb54f5">fc_getAssociationTypeText</a>(temp_assoc));
<a name="l00586"></a>00586      }
<a name="l00587"></a>00587       }
<a name="l00588"></a>00588     }
<a name="l00589"></a>00589   }
<a name="l00590"></a>00590   <span class="keywordflow">if</span> (numDims[0] != numDims[1]) 
<a name="l00591"></a>00591     <a class="code" href="error_8h.html#42c09317184affa18e70826cb35f3f04">fc_exitIfErrorPrintf</a>(<a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52e51d318f8c97c8b094cf9820b51e4fa83">FC_ERROR</a>, <span class="stringliteral">"expect meshes to have same numDim "</span>
<a name="l00592"></a>00592                 <span class="stringliteral">"(%d!=%d)"</span>, numDims[0], numDims[1]);
<a name="l00593"></a>00593   numDim = numDims[0];
<a name="l00594"></a>00594   <span class="keywordflow">if</span> (!<a class="code" href="group__Handles.html#gf1de8e9eed3c2f3c7ffcaa6527fe0adf">FC_HANDLE_EQUIV</a>(sequences[0], sequences[1])) 
<a name="l00595"></a>00595     <a class="code" href="error_8h.html#42c09317184affa18e70826cb35f3f04">fc_exitIfErrorPrintf</a>(FC_ERROR, 
<a name="l00596"></a>00596                 <span class="stringliteral">"expected displacements to be on the same sequence"</span>);
<a name="l00597"></a>00597   sequence = sequences[0];
<a name="l00598"></a>00598 
<a name="l00599"></a>00599   <span class="comment">// Close everything else to 1) to make room, and 2) when we write the </span>
<a name="l00600"></a>00600   <span class="comment">// dataset we only get gapline related stuff</span>
<a name="l00601"></a>00601   {
<a name="l00602"></a>00602     <span class="keywordtype">int</span> temp_numSequence, temp_numMesh, temp_numSubset;
<a name="l00603"></a>00603     <span class="keywordtype">int</span> temp_numVar, temp_numSeqVar, *temp_numSteps;
<a name="l00604"></a>00604     <a class="code" href="structFC__Sequence.html">FC_Sequence</a> *temp_sequences;
<a name="l00605"></a>00605     <a class="code" href="structFC__Mesh.html">FC_Mesh</a> *temp_meshes;
<a name="l00606"></a>00606     <a class="code" href="structFC__Subset.html">FC_Subset</a> *temp_subsets;
<a name="l00607"></a>00607     <a class="code" href="structFC__Variable.html">FC_Variable</a> *temp_vars, **temp_seqVars;
<a name="l00608"></a>00608     rc = <a class="code" href="group__Sequence.html#g4e9e6506fc7e6ce22310105003a21789">fc_getSequences</a>(dataset, &amp;temp_numSequence, &amp;temp_sequences);
<a name="l00609"></a>00609     <a class="code" href="group__ErrorHandling.html#g4a09c0024ecd45d5d63c8b9ec333a717">fc_exitIfError</a>(rc);
<a name="l00610"></a>00610     <span class="keywordflow">for</span> (i = 0; i &lt; temp_numSequence; i++) {
<a name="l00611"></a>00611       <span class="keywordflow">if</span> (!<a class="code" href="group__Handles.html#gf1de8e9eed3c2f3c7ffcaa6527fe0adf">FC_HANDLE_EQUIV</a>(temp_sequences[i], sequence))
<a name="l00612"></a>00612      <a class="code" href="group__Sequence.html#gf23403070ab8aa0a4d172f3cc0293754">fc_deleteSequence</a>(temp_sequences[i]);
<a name="l00613"></a>00613     }
<a name="l00614"></a>00614     free(temp_sequences);
<a name="l00615"></a>00615     rc = <a class="code" href="group__Mesh.html#ge71cd0e179143c6d82d58b9cc78cc436">fc_getMeshes</a>(dataset, &amp;temp_numMesh, &amp;temp_meshes);
<a name="l00616"></a>00616     <a class="code" href="group__ErrorHandling.html#g4a09c0024ecd45d5d63c8b9ec333a717">fc_exitIfError</a>(rc);
<a name="l00617"></a>00617     <span class="keywordflow">for</span> (i = 0; i &lt; temp_numMesh; i++) {
<a name="l00618"></a>00618       <span class="keywordflow">if</span> (!<a class="code" href="group__Handles.html#gf1de8e9eed3c2f3c7ffcaa6527fe0adf">FC_HANDLE_EQUIV</a>(temp_meshes[i], meshes[0]) &amp;&amp;
<a name="l00619"></a>00619        !<a class="code" href="group__Handles.html#gf1de8e9eed3c2f3c7ffcaa6527fe0adf">FC_HANDLE_EQUIV</a>(temp_meshes[i], meshes[1]))
<a name="l00620"></a>00620      <a class="code" href="group__Mesh.html#gc3572be7c4803b339a6110f2c3980e8e">fc_deleteMesh</a>(temp_meshes[i]);
<a name="l00621"></a>00621     }
<a name="l00622"></a>00622     free(temp_meshes);
<a name="l00623"></a>00623     <span class="keywordflow">for</span> (i = 0; i &lt; 2; i++) {
<a name="l00624"></a>00624       <a class="code" href="group__Subset.html#g5c0185b0cab5ac7256fec095a98c3bd0">fc_getSubsets</a>(meshes[i], &amp;temp_numSubset, &amp;temp_subsets);
<a name="l00625"></a>00625       <span class="keywordflow">for</span> (j = 0; j &lt; temp_numSubset; j++)
<a name="l00626"></a>00626      <a class="code" href="group__Subset.html#gfdcc399692041499cc461916a9973558">fc_deleteSubset</a>(temp_subsets[j]);
<a name="l00627"></a>00627       free(temp_subsets);
<a name="l00628"></a>00628       <a class="code" href="group__Variable.html#g74cf87c790d013532d9451af1b5f1fbb">fc_getVariables</a>(meshes[i], &amp;temp_numVar, &amp;temp_vars);
<a name="l00629"></a>00629       <span class="keywordflow">for</span> (j = 0; j &lt; temp_numVar; j++)
<a name="l00630"></a>00630      <a class="code" href="group__Variable.html#g2f48fcbd551131488dd5757c27364656">fc_deleteVariable</a>(temp_vars[j]);
<a name="l00631"></a>00631       free(temp_vars);
<a name="l00632"></a>00632       <a class="code" href="group__Variable.html#g93185e07dcdf01ffc87fc28a69ee96ae">fc_getSeqVariables</a>(meshes[i], &amp;temp_numSeqVar, &amp;temp_numSteps, 
<a name="l00633"></a>00633                 &amp;temp_seqVars);
<a name="l00634"></a>00634       <span class="keywordflow">for</span> (j = 0; j &lt; temp_numSeqVar; j++) {
<a name="l00635"></a>00635      <span class="keywordtype">int</span> hasMatch = 0;
<a name="l00636"></a>00636      <span class="keywordflow">if</span> (<a class="code" href="group__Handles.html#gf1de8e9eed3c2f3c7ffcaa6527fe0adf">FC_HANDLE_EQUIV</a>(temp_seqVars[j][0], displs[i][0]))
<a name="l00637"></a>00637        hasMatch = 1;
<a name="l00638"></a>00638      <span class="keywordflow">else</span> {
<a name="l00639"></a>00639        <span class="keywordflow">for</span> (k = 0; k &lt; numDeathVar; k++) {
<a name="l00640"></a>00640          <span class="keywordflow">if</span> (<a class="code" href="group__Handles.html#gf1de8e9eed3c2f3c7ffcaa6527fe0adf">FC_HANDLE_EQUIV</a>(temp_seqVars[j][0], deathVars[i][k][0])) {
<a name="l00641"></a>00641            hasMatch = 1;
<a name="l00642"></a>00642            <span class="keywordflow">break</span>;
<a name="l00643"></a>00643          }
<a name="l00644"></a>00644        }
<a name="l00645"></a>00645      }
<a name="l00646"></a>00646      <span class="keywordflow">if</span> (!hasMatch) 
<a name="l00647"></a>00647        <a class="code" href="group__Variable.html#g57341fab4863efe2c35476aee509f20d">fc_deleteSeqVariable</a>(temp_numSteps[j], temp_seqVars[j]);
<a name="l00648"></a>00648      free(temp_seqVars[j]);
<a name="l00649"></a>00649       }
<a name="l00650"></a>00650       free(temp_numSteps);
<a name="l00651"></a>00651       free(temp_seqVars);
<a name="l00652"></a>00652     }
<a name="l00653"></a>00653   }
<a name="l00654"></a>00654 
<a name="l00655"></a>00655   <span class="comment">// ---- done with setup</span>
<a name="l00656"></a>00656 
<a name="l00657"></a>00657   <span class="comment">// Header</span>
<a name="l00658"></a>00658   printf(<span class="stringliteral">"Generating gaplines for:\n"</span>);
<a name="l00659"></a>00659   printf(<span class="stringliteral">"Dataset: '%s'\n"</span>, file_name);
<a name="l00660"></a>00660   printf(<span class="stringliteral">"Meshes: '%s' and '%s'\n"</span>, mesh_names[0], mesh_names[1]);
<a name="l00661"></a>00661   printf(<span class="stringliteral">"Displ: '%s'\n"</span>, displ_name);
<a name="l00662"></a>00662   printf(<span class="stringliteral">"Min Dist: %g\n"</span>, min_dist);
<a name="l00663"></a>00663   <span class="keywordflow">if</span> (numDeathVar &gt; 0) {
<a name="l00664"></a>00664     printf(<span class="stringliteral">"Death Criteria: '%s' %s %g"</span>, deathVarInfos[0].name,
<a name="l00665"></a>00665         deathVarInfos[0].op, deathVarInfos[0].val);
<a name="l00666"></a>00666     <span class="keywordflow">for</span> (i = 1; i &lt; numDeathVar; i++) 
<a name="l00667"></a>00667       printf(<span class="stringliteral">" or '%s' %s %g"</span>, deathVarInfos[i].name,
<a name="l00668"></a>00668           deathVarInfos[i].op, deathVarInfos[i].val);
<a name="l00669"></a>00669     printf(<span class="stringliteral">"\n"</span>);
<a name="l00670"></a>00670   }
<a name="l00671"></a>00671   fflush(NULL);
<a name="l00672"></a>00672 
<a name="l00673"></a>00673   <span class="comment">// skin the meshes (get face skin and vertex skin)</span>
<a name="l00674"></a>00674   <span class="comment">// also get shapes</span>
<a name="l00675"></a>00675   <span class="keywordflow">if</span> (verbose_level &gt; <a class="code" href="group__DataTypes.html#gg6c0891f21e34bad1d8b2bc7c76193a399cb0ad9c1f97775f8954860a08d78144">FC_QUIET</a>) {
<a name="l00676"></a>00676     printf(<span class="stringliteral">"Skinning meshes ...\n"</span>);
<a name="l00677"></a>00677     fflush(NULL);
<a name="l00678"></a>00678   }
<a name="l00679"></a>00679   <span class="keywordflow">for</span> (i = 0; i &lt; 2; i++) {
<a name="l00680"></a>00680     rc = <a class="code" href="group__Mesh.html#g44d09391731a139c4efc2c4fb2eda4e7">fc_getMeshCoordsPtr</a>(meshes[i], &amp;coords[i]);
<a name="l00681"></a>00681     <a class="code" href="group__ErrorHandling.html#g4a09c0024ecd45d5d63c8b9ec333a717">fc_exitIfError</a>(rc);
<a name="l00682"></a>00682     rc = <a class="code" href="gaplines_8c.html#a4b9b7eb8ccadfa5bf7039cf115b7223">getMeshMaxEdgeLength</a>(meshes[i], &amp;max_lens[i]);
<a name="l00683"></a>00683     <a class="code" href="error_8h.html#42c09317184affa18e70826cb35f3f04">fc_exitIfErrorPrintf</a>(rc, <span class="stringliteral">"failed to get mesh max edge length"</span>);
<a name="l00684"></a>00684     <span class="comment">// Imagine a 4 sided quad with edge lengths of max_lens[i]</span>
<a name="l00685"></a>00685     <span class="comment">// squash it - the two vertices farthest apart are 2*max_lens[i] apart</span>
<a name="l00686"></a>00686     <span class="comment">// Imagine a point min_dist above one of those two vertices</span>
<a name="l00687"></a>00687     <span class="comment">// max_dists[i] is distance from that point to other vert.</span>
<a name="l00688"></a>00688     max_dists[i] = sqrt(4*max_lens[i]*max_lens[i] + min_dist*min_dist);
<a name="l00689"></a>00689     rc = <a class="code" href="group__TopologyRelations.html#ga4961b6dfaf20254b4c72082a7c070c6">fc_getMeshSkin</a>(meshes[i], &amp;face_skins[i]);
<a name="l00690"></a>00690     <a class="code" href="group__ErrorHandling.html#g4a09c0024ecd45d5d63c8b9ec333a717">fc_exitIfError</a>(rc);
<a name="l00691"></a>00691     rc = <a class="code" href="group__Subset.html#g7a79d4d1e13846ae12abe55ef2db3c3d">fc_getSubsetMembersAsArray</a>(face_skins[i], &amp;numFaceIDs[i], &amp;faceIDs[i]);
<a name="l00692"></a>00692     <a class="code" href="group__ErrorHandling.html#g4a09c0024ecd45d5d63c8b9ec333a717">fc_exitIfError</a>(rc);
<a name="l00693"></a>00693     sprintf(charBuf, <span class="stringliteral">"vert skin %d"</span>, i);
<a name="l00694"></a>00694     rc = <a class="code" href="group__Subset.html#gb776198fa763b99d16d1512d1e75d818">fc_copySubsetWithNewAssociation</a>(face_skins[i], charBuf,
<a name="l00695"></a>00695                           <a class="code" href="group__DataTypes.html#gg63044bd7bb5313d8a79ea8a71f1b30408cc812de98bed6c7106d5fa72e11f726">FC_AT_VERTEX</a>, 1, &amp;vert_skins[i]);
<a name="l00696"></a>00696     <a class="code" href="group__ErrorHandling.html#g4a09c0024ecd45d5d63c8b9ec333a717">fc_exitIfError</a>(rc);
<a name="l00697"></a>00697     rc = <a class="code" href="group__Subset.html#g7a79d4d1e13846ae12abe55ef2db3c3d">fc_getSubsetMembersAsArray</a>(vert_skins[i], &amp;numVertIDs[i], &amp;vertIDs[i]);
<a name="l00698"></a>00698     <a class="code" href="group__ErrorHandling.html#g4a09c0024ecd45d5d63c8b9ec333a717">fc_exitIfError</a>(rc);
<a name="l00699"></a>00699     rc = <a class="code" href="group__Mesh.html#g216435eac0f72ad3ccb35e44b2df6ca5">fc_getMeshFaceConnsPtr</a>(meshes[i], &amp;numVertexPerFace[i], &amp;stride[i],
<a name="l00700"></a>00700                     &amp;faceToVertConns[i]);
<a name="l00701"></a>00701     <a class="code" href="group__ErrorHandling.html#g4a09c0024ecd45d5d63c8b9ec333a717">fc_exitIfError</a>(rc);
<a name="l00702"></a>00702     rc = <a class="code" href="group__PrivateMesh.html#g35d692d6e99ca4b93a4a1de17b34c932">_fc_getMeshFaceParentsOfVerticesPtr</a>(meshes[i], &amp;numFacePerVert[i],
<a name="l00703"></a>00703                               &amp;faceParentsPerVert[i]);
<a name="l00704"></a>00704     <a class="code" href="group__ErrorHandling.html#g4a09c0024ecd45d5d63c8b9ec333a717">fc_exitIfError</a>(rc);
<a name="l00705"></a>00705     rc = <a class="code" href="group__Shape.html#ge19316dcd48bbd670312d12a61ba04c4">fc_getMeshShapes</a>(meshes[i], angle, 0, &amp;numShapes[i], &amp;shapes[i]);
<a name="l00706"></a>00706     <a class="code" href="group__ErrorHandling.html#g4a09c0024ecd45d5d63c8b9ec333a717">fc_exitIfError</a>(rc);
<a name="l00707"></a>00707     <a class="code" href="gaplines_8c.html#5cd3a0ae146dbd7260b0fe8425d006e6">calcFaceOrients</a>(meshes[i], numFaceIDs[i], faceIDs[i], &amp;faceOrients[i]);
<a name="l00708"></a>00708     <span class="comment">// FIX could move this to later ... don't need until constructing gap mesh</span>
<a name="l00709"></a>00709     rc = <a class="code" href="group__PrivateMesh.html#gaaab766d8ce1d4e44e682b0f7aaf3d40">_fc_getMeshElementParentsOfFacesPtr</a>(meshes[i], &amp;numElemPerFace[i],
<a name="l00710"></a>00710                               &amp;elemParentsPerFace[i]);
<a name="l00711"></a>00711     <a class="code" href="group__ErrorHandling.html#g4a09c0024ecd45d5d63c8b9ec333a717">fc_exitIfError</a>(rc);
<a name="l00712"></a>00712     rc = <a class="code" href="group__GeometricRelations.html#g9aab2b1ce3bf7747aa6adcf63fb590c4">fc_createMeshVertexBin</a>(meshes[i], &amp;bins[i]);
<a name="l00713"></a>00713     <a class="code" href="group__ErrorHandling.html#g4a09c0024ecd45d5d63c8b9ec333a717">fc_exitIfError</a>(rc);
<a name="l00714"></a>00714   }
<a name="l00715"></a>00715 
<a name="l00716"></a>00716   <span class="comment">// Create lists of vert to face pairs</span>
<a name="l00717"></a>00717   <span class="keywordflow">if</span> (verbose_level &gt; <a class="code" href="group__DataTypes.html#gg6c0891f21e34bad1d8b2bc7c76193a399cb0ad9c1f97775f8954860a08d78144">FC_QUIET</a>) {
<a name="l00718"></a>00718     printf(<span class="stringliteral">"Finding vert to face pairs ...\n"</span>);
<a name="l00719"></a>00719     fflush(NULL);
<a name="l00720"></a>00720   }
<a name="l00721"></a>00721   <span class="keywordflow">for</span> (i = 0; i &lt; 2; i++) {
<a name="l00722"></a>00722     <span class="keywordtype">int</span> otherMesh = (i == 0 ? 1 : 0);
<a name="l00723"></a>00723     numKeeps[i] = 0;
<a name="l00724"></a>00724     keepVertIDs[i] = malloc(numVertIDs[i]*<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
<a name="l00725"></a>00725     keepThisFaceIDs[i] = malloc(numVertIDs[i]*<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
<a name="l00726"></a>00726     keepOtherFaceIDs[i] = malloc(numVertIDs[i]*<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
<a name="l00727"></a>00727     keepParams[i] = malloc(numVertIDs[i]*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>*));
<a name="l00728"></a>00728     <span class="keywordflow">if</span> (!keepVertIDs[i] || !keepThisFaceIDs[i] || !keepOtherFaceIDs[i] ||
<a name="l00729"></a>00729      !keepParams[i]) {
<a name="l00730"></a>00730       printf(<span class="stringliteral">"Memory problem\n"</span>);
<a name="l00731"></a>00731       exit(-1);
<a name="l00732"></a>00732     }
<a name="l00733"></a>00733     <span class="keywordflow">for</span> (j = 0; j &lt; numVertIDs[i]; j++) {
<a name="l00734"></a>00734       <span class="comment">// look for a containing face on other mesh</span>
<a name="l00735"></a>00735       <span class="comment">// (assumption - can find such a face via nearest vertex</span>
<a name="l00736"></a>00736       <span class="comment">//   this is not true, but true enough; cases this doesn't hold</span>
<a name="l00737"></a>00737       <span class="comment">//   for are just discarded)</span>
<a name="l00738"></a>00738       <span class="keywordtype">int</span> thisVertID = vertIDs[i][j];
<a name="l00739"></a>00739       <span class="keywordtype">int</span> numOtherFace, *otherFaceIDs;
<a name="l00740"></a>00740       rc = <a class="code" href="group__GeometricRelations.html#g77c54eb65c09c6f4d062ed151cd68208">fc_getEntitiesWithinSphere</a>(meshes[otherMesh], bins[otherMesh],
<a name="l00741"></a>00741                           &amp;coords[i][thisVertID*numDim], 
<a name="l00742"></a>00742                           max_dists[otherMesh], <a class="code" href="group__DataTypes.html#gg63044bd7bb5313d8a79ea8a71f1b30402787462c13709118df8e232282a530a4">FC_AT_FACE</a>, 
<a name="l00743"></a>00743                           &amp;numOtherFace, &amp;otherFaceIDs);
<a name="l00744"></a>00744       <a class="code" href="error_8h.html#42c09317184affa18e70826cb35f3f04">fc_exitIfErrorPrintf</a>(rc, <span class="stringliteral">"failed to get entities within a sphere"</span>);
<a name="l00745"></a>00745       <span class="keywordflow">for</span> (k = 0; k &lt; numOtherFace; k++) {
<a name="l00746"></a>00746      <span class="keywordtype">int</span> numParam;
<a name="l00747"></a>00747      <span class="keywordtype">double</span> *params;
<a name="l00748"></a>00748      <span class="keywordtype">double</span> distance2, min_dist2 = min_dist*min_dist; <span class="comment">// squared distances</span>
<a name="l00749"></a>00749      <span class="comment">//int otherFaceID = faceParentsPerVert[otherMesh][otherVertID][k];</span>
<a name="l00750"></a>00750      <span class="keywordtype">int</span> otherFaceID = otherFaceIDs[k];
<a name="l00751"></a>00751      <span class="keywordtype">int</span> thisFaceID;
<a name="l00752"></a>00752      <a class="code" href="group__SimpleDataObjects.html#g84c64ce1a8b6f4beca59ee9140f3f109">FC_Vector</a> otherNormal;
<a name="l00753"></a>00753      <a class="code" href="group__SimpleDataObjects.html#g9687c6aad22d56c60f87659f533869c2">FC_Coords</a> otherFaceCoords[4], temp_newPoint;
<a name="l00754"></a>00754      <span class="keywordtype">int</span> foundMatch = 0;
<a name="l00755"></a>00755      <span class="comment">// skip if not in the skin</span>
<a name="l00756"></a>00756      <span class="keywordflow">if</span> (!<a class="code" href="group__Subset.html#ge786dd4486b757ba00e4e78359a460bc">fc_isMemberInSubset</a>(face_skins[otherMesh], otherFaceID))
<a name="l00757"></a>00757        <span class="keywordflow">continue</span>;
<a name="l00758"></a>00758      <span class="keywordflow">if</span> (numVertexPerFace[otherMesh][otherFaceID] != 4)
<a name="l00759"></a>00759        printf(<span class="stringliteral">"*** expected quads!\n"</span>);
<a name="l00760"></a>00760      <span class="comment">// setup</span>
<a name="l00761"></a>00761      <span class="keywordflow">for</span> (m = 0; m &lt; numVertexPerFace[otherMesh][otherFaceID]; m++) {
<a name="l00762"></a>00762        <span class="keywordtype">int</span> totherVertID = faceToVertConns[otherMesh][otherFaceID*4+m];
<a name="l00763"></a>00763        memcpy(otherFaceCoords[m], &amp;coords[otherMesh][numDim*totherVertID],
<a name="l00764"></a>00764            numDim*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l00765"></a>00765      }
<a name="l00766"></a>00766      <a class="code" href="group__PrivateGeometricRelations.html#g220950bef4a17b1ad88db87868459421">_fc_calcSurfaceNormal</a>(numVertexPerFace[otherMesh][otherFaceID],
<a name="l00767"></a>00767                      otherFaceCoords, &amp;otherNormal);
<a name="l00768"></a>00768      <span class="comment">// check that normal is oposite some face in the first mesh</span>
<a name="l00769"></a>00769      <span class="keywordflow">for</span> (m = 0; m &lt; numFacePerVert[i][thisVertID]; m++) {
<a name="l00770"></a>00770        thisFaceID = faceParentsPerVert[i][thisVertID][m];
<a name="l00771"></a>00771        <a class="code" href="group__SimpleDataObjects.html#g9687c6aad22d56c60f87659f533869c2">FC_Coords</a> thisFaceCoords[4];
<a name="l00772"></a>00772        <a class="code" href="group__SimpleDataObjects.html#g84c64ce1a8b6f4beca59ee9140f3f109">FC_Vector</a> thisNormal;
<a name="l00773"></a>00773        <span class="keywordtype">double</span> anglediff;
<a name="l00774"></a>00774        <span class="keywordflow">if</span> (!<a class="code" href="group__Subset.html#ge786dd4486b757ba00e4e78359a460bc">fc_isMemberInSubset</a>(face_skins[i], thisFaceID)) 
<a name="l00775"></a>00775          <span class="keywordflow">continue</span>;
<a name="l00776"></a>00776        <span class="keywordflow">for</span> (n = 0; n &lt; numVertexPerFace[i][thisFaceID]; n++)
<a name="l00777"></a>00777          memcpy(thisFaceCoords[n],
<a name="l00778"></a>00778              &amp;coords[i][numDim*faceToVertConns[i][thisFaceID*4+n]],
<a name="l00779"></a>00779              numDim*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l00780"></a>00780        <a class="code" href="group__PrivateGeometricRelations.html#g220950bef4a17b1ad88db87868459421">_fc_calcSurfaceNormal</a>(numVertexPerFace[i][thisFaceID],
<a name="l00781"></a>00781                     thisFaceCoords, &amp;thisNormal);
<a name="l00782"></a>00782        <a class="code" href="group__GeometricRelations.html#g4972191f68d5f52d1c0acbb0254c6eb6">fc_calcAngleBetweenVectors</a>(thisNormal, otherNormal, &amp;anglediff);
<a name="l00783"></a>00783        <span class="comment">//printf("angle = %g,faceorients = %d %d\n", anglediff,</span>
<a name="l00784"></a>00784        <span class="comment">// faceOrients[i][thisFaceID], faceOrients[otherMesh][otherFaceID]);</span>
<a name="l00785"></a>00785        <span class="keywordflow">if</span> ((faceOrients[i][thisFaceID] ==
<a name="l00786"></a>00786             faceOrients[otherMesh][otherFaceID] &amp;&amp; anglediff &gt; 175) ||
<a name="l00787"></a>00787            (faceOrients[i][thisFaceID] == 
<a name="l00788"></a>00788             -1*faceOrients[otherMesh][otherFaceID] &amp;&amp; anglediff &lt; 5)) {
<a name="l00789"></a>00789          foundMatch = 1;
<a name="l00790"></a>00790          <span class="keywordflow">break</span>;
<a name="l00791"></a>00791        }
<a name="l00792"></a>00792      }
<a name="l00793"></a>00793      <span class="keywordflow">if</span> (!foundMatch)
<a name="l00794"></a>00794        <span class="keywordflow">continue</span>;
<a name="l00795"></a>00795      <span class="comment">// check to see if it's inside face - within tolerance of DBL_EPSILON</span>
<a name="l00796"></a>00796      <a class="code" href="group__PrivateGeometricRelations.html#gd03a818ea21f282dc0726a145836265e">_fc_calcQuadParams</a>(otherFaceCoords, &amp;coords[i][thisVertID*numDim], 
<a name="l00797"></a>00797                   &amp;numParam, &amp;params);
<a name="l00798"></a>00798      <span class="keywordflow">if</span> (!params || 
<a name="l00799"></a>00799          params[0] &lt; -1*FLT_EPSILON || params[0] &gt; 1 + FLT_EPSILON || 
<a name="l00800"></a>00800          params[1] &lt; -1*FLT_EPSILON || params[1] &gt; 1 + FLT_EPSILON ) {
<a name="l00801"></a>00801        free(params);
<a name="l00802"></a>00802        <span class="keywordflow">continue</span>; <span class="comment">// not inside the quad</span>
<a name="l00803"></a>00803      }
<a name="l00804"></a>00804      <a class="code" href="group__PrivateGeometricRelations.html#g16a56e75e5ccb2deec37abfa5e532b73">_fc_calcQuadLocation</a>(otherFaceCoords, numParam, params, 
<a name="l00805"></a>00805                     &amp;temp_newPoint);
<a name="l00806"></a>00806      <span class="comment">// check distance</span>
<a name="l00807"></a>00807      <a class="code" href="group__GeometricRelations.html#g69030cccac839d01b0a3fbc573a20254">fc_calcSquaredEuclideanDistance</a>(&amp;coords[i][thisVertID*numDim], 
<a name="l00808"></a>00808                          temp_newPoint, numDim, &amp;distance2);
<a name="l00809"></a>00809      <span class="comment">// Below is friendlier version of "if (distance2 &gt; min_dist2) {"</span>
<a name="l00810"></a>00810      <span class="keywordflow">if</span> (distance2 - min_dist2 &gt; DBL_EPSILON) {
<a name="l00811"></a>00811        free(params);
<a name="l00812"></a>00812        <span class="keywordflow">continue</span>;
<a name="l00813"></a>00813      }
<a name="l00814"></a>00814      <span class="comment">// passed the test, add to list and stop looking</span>
<a name="l00815"></a>00815      <span class="comment">//printf("keepFace = %d\n", otherFaceID);</span>
<a name="l00816"></a>00816      keepVertIDs[i][numKeeps[i]] = thisVertID;
<a name="l00817"></a>00817      keepThisFaceIDs[i][numKeeps[i]] = thisFaceID;
<a name="l00818"></a>00818      keepOtherFaceIDs[i][numKeeps[i]] = otherFaceID;
<a name="l00819"></a>00819      keepParams[i][numKeeps[i]] = params;
<a name="l00820"></a>00820      numKeeps[i]++;
<a name="l00821"></a>00821      <span class="keywordflow">break</span>;
<a name="l00822"></a>00822       }
<a name="l00823"></a>00823       free(otherFaceIDs);
<a name="l00824"></a>00824     }
<a name="l00825"></a>00825     realloc(keepVertIDs[i], numKeeps[i]*<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
<a name="l00826"></a>00826     realloc(keepThisFaceIDs[i], numKeeps[i]*<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
<a name="l00827"></a>00827     realloc(keepOtherFaceIDs[i], numKeeps[i]*<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
<a name="l00828"></a>00828     realloc(keepParams[i], numKeeps[i]*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>*));
<a name="l00829"></a>00829   }
<a name="l00830"></a>00830   <span class="keywordflow">for</span> (i = 0; i &lt; 2; i++) {
<a name="l00831"></a>00831     <a class="code" href="group__Subset.html#gfdcc399692041499cc461916a9973558">fc_deleteSubset</a>(face_skins[i]);
<a name="l00832"></a>00832     <a class="code" href="group__Subset.html#gfdcc399692041499cc461916a9973558">fc_deleteSubset</a>(vert_skins[i]);
<a name="l00833"></a>00833   }
<a name="l00834"></a>00834 
<a name="l00835"></a>00835   <span class="comment">// Early exit - We are done if no pairs were found</span>
<a name="l00836"></a>00836   <span class="keywordflow">if</span> (numKeeps[0] + numKeeps[1] &lt; 1) {
<a name="l00837"></a>00837     printf(<span class="stringliteral">"\n"</span>);
<a name="l00838"></a>00838     printf(<span class="stringliteral">"Number of gap lines found = 0\n"</span>);
<a name="l00839"></a>00839     exit(0);
<a name="l00840"></a>00840   }
<a name="l00841"></a>00841     
<a name="l00842"></a>00842   <span class="comment">//debug</span>
<a name="l00843"></a>00843   <span class="comment">//printf("numKeeps[0] = %d, numKeeps[1] = %d\n", numKeeps[0], numKeeps[1]);</span>
<a name="l00844"></a>00844   <span class="comment">/*</span>
<a name="l00845"></a>00845 <span class="comment">  { // for debugging - make subsets of thisFaces &amp; otherFaces</span>
<a name="l00846"></a>00846 <span class="comment">    FC_Subset thisSubsets[2];</span>
<a name="l00847"></a>00847 <span class="comment">    FC_Subset otherSubsets[2];</span>
<a name="l00848"></a>00848 <span class="comment">    for (i = 0; i &lt; 2; i++) {</span>
<a name="l00849"></a>00849 <span class="comment">      char buf[1048];</span>
<a name="l00850"></a>00850 <span class="comment">      sprintf(buf, "%s-thisFaces", mesh_names[i]);</span>
<a name="l00851"></a>00851 <span class="comment">      fc_createSubset(meshes[i], buf, FC_AT_FACE, &amp;thisSubsets[i]);</span>
<a name="l00852"></a>00852 <span class="comment">      sprintf(buf, "%s-otherFaces", mesh_names[i]);</span>
<a name="l00853"></a>00853 <span class="comment">      fc_createSubset(meshes[i], buf, FC_AT_FACE, &amp;otherSubsets[i]);</span>
<a name="l00854"></a>00854 <span class="comment">    }</span>
<a name="l00855"></a>00855 <span class="comment">    for (i = 0; i &lt; 2; i++) {</span>
<a name="l00856"></a>00856 <span class="comment">      int otherMesh =(i == 0 ? 1 : 0);</span>
<a name="l00857"></a>00857 <span class="comment">      for (j = 0; j &lt; numKeeps[i]; j++) {</span>
<a name="l00858"></a>00858 <span class="comment">     fc_addMemberToSubset(thisSubsets[i], keepThisFaceIDs[i][j]);</span>
<a name="l00859"></a>00859 <span class="comment">     fc_addMemberToSubset(otherSubsets[otherMesh], keepOtherFaceIDs[i][j]);</span>
<a name="l00860"></a>00860 <span class="comment">      }</span>
<a name="l00861"></a>00861 <span class="comment">    }</span>
<a name="l00862"></a>00862 <span class="comment">  }</span>
<a name="l00863"></a>00863 <span class="comment">  */</span>
<a name="l00864"></a>00864 
<a name="l00865"></a>00865   <span class="comment">// Create the line mesh &amp; its displacements &amp; isDead var</span>
<a name="l00866"></a>00866   <span class="keywordflow">if</span> (verbose_level &gt; <a class="code" href="group__DataTypes.html#gg6c0891f21e34bad1d8b2bc7c76193a399cb0ad9c1f97775f8954860a08d78144">FC_QUIET</a>) {
<a name="l00867"></a>00867     printf(<span class="stringliteral">"Creating gaplines mesh ...\n"</span>);
<a name="l00868"></a>00868     fflush(NULL);
<a name="l00869"></a>00869   }  
<a name="l00870"></a>00870   {
<a name="l00871"></a>00871     <span class="keywordtype">int</span> vindex, eindex;
<a name="l00872"></a>00872     <span class="keywordtype">int</span> numElement = numKeeps[0] + numKeeps[1];
<a name="l00873"></a>00873     <span class="keywordtype">int</span> numVertex = numElement*2;
<a name="l00874"></a>00874     <span class="keywordtype">int</span> temp_numStep;
<a name="l00875"></a>00875     <span class="keywordtype">double</span>* new_coords = malloc(numDim*numVertex*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l00876"></a>00876     <span class="keywordtype">int</span>* new_conns = malloc(2*numElement*<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
<a name="l00877"></a>00877     <span class="keywordtype">double</span> *displ_datas[2], **death_datas[2];
<a name="l00878"></a>00878     <span class="keywordtype">double</span>* new_displ_data, *new_ave_face_data;
<a name="l00879"></a>00879     <span class="keywordtype">int</span> *new_isDead_data;
<a name="l00880"></a>00880     <span class="comment">// create coords &amp; conns</span>
<a name="l00881"></a>00881     vindex = 0;
<a name="l00882"></a>00882     <span class="keywordflow">for</span> (i = 0; i &lt; 2; i++) {
<a name="l00883"></a>00883       <span class="keywordtype">int</span> otherMesh = (i == 0 ? 1 : 0);
<a name="l00884"></a>00884       <span class="keywordflow">for</span> (j = 0; j &lt; numKeeps[i]; j++) {
<a name="l00885"></a>00885      <span class="keywordtype">int</span> otherFaceID = keepOtherFaceIDs[i][j];
<a name="l00886"></a>00886      <a class="code" href="group__SimpleDataObjects.html#g9687c6aad22d56c60f87659f533869c2">FC_Coords</a> otherFaceCoords[4], newPoint;
<a name="l00887"></a>00887      <span class="comment">// First the vertex</span>
<a name="l00888"></a>00888      memcpy(new_coords+vindex*numDim, coords[i]+keepVertIDs[i][j]*numDim, 
<a name="l00889"></a>00889             numDim*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l00890"></a>00890      new_conns[vindex] = vindex;
<a name="l00891"></a>00891      vindex++;
<a name="l00892"></a>00892      <span class="comment">// Then the parameterized point on the face</span>
<a name="l00893"></a>00893      <span class="keywordflow">for</span> (k = 0; k &lt; 4; k++) {
<a name="l00894"></a>00894        <span class="keywordtype">int</span> totherVertID = faceToVertConns[otherMesh][otherFaceID*4+k];
<a name="l00895"></a>00895        memcpy(otherFaceCoords[k], &amp;coords[otherMesh][numDim*totherVertID],
<a name="l00896"></a>00896            numDim*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l00897"></a>00897      }
<a name="l00898"></a>00898      <a class="code" href="group__PrivateGeometricRelations.html#g16a56e75e5ccb2deec37abfa5e532b73">_fc_calcQuadLocation</a>(otherFaceCoords, 2, keepParams[i][j], 
<a name="l00899"></a>00899                     &amp;newPoint);
<a name="l00900"></a>00900      memcpy(new_coords+vindex*numDim, newPoint, numDim*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l00901"></a>00901      new_conns[vindex] = vindex;
<a name="l00902"></a>00902      vindex++;
<a name="l00903"></a>00903       }
<a name="l00904"></a>00904     }
<a name="l00905"></a>00905     <span class="comment">// create mesh</span>
<a name="l00906"></a>00906     sprintf(charBuf, <span class="stringliteral">"gap lines"</span>);
<a name="l00907"></a>00907     rc = <a class="code" href="group__Mesh.html#gfeb2fbc7f7fce6d00b6946d43b56e0bb">fc_createMesh</a>(dataset, charBuf, &amp;gap_mesh);
<a name="l00908"></a>00908     <a class="code" href="group__ErrorHandling.html#g4a09c0024ecd45d5d63c8b9ec333a717">fc_exitIfError</a>(rc);
<a name="l00909"></a>00909     rc = <a class="code" href="group__Mesh.html#gd49edafdfdda60b392d3a24803869b50">fc_setMeshCoordsPtr</a>(gap_mesh, numDim, numVertex, new_coords);
<a name="l00910"></a>00910     <a class="code" href="group__ErrorHandling.html#g4a09c0024ecd45d5d63c8b9ec333a717">fc_exitIfError</a>(rc);
<a name="l00911"></a>00911     rc = <a class="code" href="group__Mesh.html#gbb354f851c7ec2f20f2921fd5a76cf02">fc_setMeshElementConnsPtr</a>(gap_mesh, <a class="code" href="group__DataTypes.html#gg5d0bf8bd47afb81d89d4c5d60c7d62b4e17a2f7fa15c69d4f9c2f89ecbab0c18">FC_ET_LINE</a>, numElement,
<a name="l00912"></a>00912                        new_conns);
<a name="l00913"></a>00913     <a class="code" href="group__ErrorHandling.html#g4a09c0024ecd45d5d63c8b9ec333a717">fc_exitIfError</a>(rc);
<a name="l00914"></a>00914     <span class="comment">// create displacement var and face normals var</span>
<a name="l00915"></a>00915     rc = <a class="code" href="group__Variable.html#gada4bacc9679592ff8b27c538570c1da">fc_createSeqVariable</a>(gap_mesh, sequence, displ_name, &amp;temp_numStep,
<a name="l00916"></a>00916                      &amp;gap_displ);
<a name="l00917"></a>00917     <a class="code" href="group__ErrorHandling.html#g4a09c0024ecd45d5d63c8b9ec333a717">fc_exitIfError</a>(rc);
<a name="l00918"></a>00918     rc = <a class="code" href="group__Variable.html#gada4bacc9679592ff8b27c538570c1da">fc_createSeqVariable</a>(gap_mesh, sequence, <span class="stringliteral">"ave face normals"</span>, 
<a name="l00919"></a>00919                 &amp;temp_numStep, &amp;aveFaceNorms);
<a name="l00920"></a>00920     <a class="code" href="group__ErrorHandling.html#g4a09c0024ecd45d5d63c8b9ec333a717">fc_exitIfError</a>(rc);
<a name="l00921"></a>00921     <span class="keywordflow">if</span> (numDeathVar &gt; 0) {
<a name="l00922"></a>00922       rc = <a class="code" href="group__Variable.html#gada4bacc9679592ff8b27c538570c1da">fc_createSeqVariable</a>(gap_mesh, sequence, <span class="stringliteral">"isDead"</span>,
<a name="l00923"></a>00923                   &amp;temp_numStep, &amp;isDeadVar);
<a name="l00924"></a>00924       <a class="code" href="group__ErrorHandling.html#g4a09c0024ecd45d5d63c8b9ec333a717">fc_exitIfError</a>(rc);
<a name="l00925"></a>00925     }
<a name="l00926"></a>00926     <span class="keywordflow">for</span> (i = 0; i &lt; numStep; i++) {
<a name="l00927"></a>00927       new_displ_data = calloc(numDim*numVertex, <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l00928"></a>00928       new_ave_face_data = malloc(numDim*numElement*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l00929"></a>00929       <span class="keywordflow">if</span> (!new_displ_data || !new_ave_face_data)
<a name="l00930"></a>00930      <a class="code" href="group__ErrorHandling.html#g4a09c0024ecd45d5d63c8b9ec333a717">fc_exitIfError</a>(<a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52ee4bf428a2cdead5d4e3e3391a2cdab0d">FC_MEMORY_ERROR</a>);
<a name="l00931"></a>00931       <span class="keywordflow">for</span> (j = 0; j &lt; 2; j++) {
<a name="l00932"></a>00932      rc = <a class="code" href="group__Variable.html#g717ba43c5ff38b3e711f5a38625e670e">fc_getVariableDataAsDataType</a>(displs[j][i], <a class="code" href="group__DataTypes.html#ggbbab9b2f35d4bc42e868e4f5853a6297806cef8a12ffc6ef267ac21addb95ab3">FC_DT_DOUBLE</a>,
<a name="l00933"></a>00933                            (<span class="keywordtype">void</span>**)&amp;displ_datas[j]);
<a name="l00934"></a>00934      <a class="code" href="group__ErrorHandling.html#g4a09c0024ecd45d5d63c8b9ec333a717">fc_exitIfError</a>(rc);
<a name="l00935"></a>00935       }
<a name="l00936"></a>00936       <span class="keywordflow">if</span> (numDeathVar &gt; 0) {
<a name="l00937"></a>00937      new_isDead_data = malloc(numElement*<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
<a name="l00938"></a>00938      <span class="keywordflow">if</span> (!new_isDead_data)
<a name="l00939"></a>00939        <a class="code" href="group__ErrorHandling.html#g4a09c0024ecd45d5d63c8b9ec333a717">fc_exitIfError</a>(FC_MEMORY_ERROR);
<a name="l00940"></a>00940      <span class="keywordflow">for</span> (j = 0; j &lt; 2; j++) {
<a name="l00941"></a>00941        death_datas[j] = (<span class="keywordtype">double</span>**)malloc(numDeathVar*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>*));
<a name="l00942"></a>00942        <span class="keywordflow">if</span> (!death_datas[j])
<a name="l00943"></a>00943          <a class="code" href="group__ErrorHandling.html#g4a09c0024ecd45d5d63c8b9ec333a717">fc_exitIfError</a>(FC_MEMORY_ERROR);
<a name="l00944"></a>00944        <span class="keywordflow">for</span> (k = 0; k &lt; numDeathVar; k++) {
<a name="l00945"></a>00945          <a class="code" href="group__Variable.html#g717ba43c5ff38b3e711f5a38625e670e">fc_getVariableDataAsDataType</a>(deathVars[j][k][i], <a class="code" href="group__DataTypes.html#ggbbab9b2f35d4bc42e868e4f5853a6297806cef8a12ffc6ef267ac21addb95ab3">FC_DT_DOUBLE</a>,
<a name="l00946"></a>00946                           (<span class="keywordtype">void</span>**)&amp;death_datas[j][k]);
<a name="l00947"></a>00947          <a class="code" href="group__ErrorHandling.html#g4a09c0024ecd45d5d63c8b9ec333a717">fc_exitIfError</a>(rc);
<a name="l00948"></a>00948        }
<a name="l00949"></a>00949      }
<a name="l00950"></a>00950       }
<a name="l00951"></a>00951       vindex = 0;
<a name="l00952"></a>00952       eindex = 0;
<a name="l00953"></a>00953       <span class="keywordflow">for</span> (j = 0; j &lt; 2; j++) {
<a name="l00954"></a>00954      <span class="keywordtype">int</span> otherMesh = (j == 0 ? 1 : 0);
<a name="l00955"></a>00955      <span class="keywordflow">for</span> (k = 0; k &lt; numKeeps[j]; k++) {
<a name="l00956"></a>00956        <span class="keywordtype">int</span> thisFaceID = keepThisFaceIDs[j][k];
<a name="l00957"></a>00957        <span class="keywordtype">int</span> otherFaceID = keepOtherFaceIDs[j][k];
<a name="l00958"></a>00958        <span class="comment">// assume skin face (only 1 parent element)</span>
<a name="l00959"></a>00959        <span class="keywordtype">int</span> thisElemID = elemParentsPerFace[j][thisFaceID][0];
<a name="l00960"></a>00960        <span class="keywordtype">int</span> otherElemID = elemParentsPerFace[otherMesh][otherFaceID][0];
<a name="l00961"></a>00961        <a class="code" href="group__SimpleDataObjects.html#g9687c6aad22d56c60f87659f533869c2">FC_Coords</a> thisFaceCoords[4], otherFaceCoords[4], newPoint;
<a name="l00962"></a>00962        <a class="code" href="group__SimpleDataObjects.html#g84c64ce1a8b6f4beca59ee9140f3f109">FC_Vector</a> thisNormal, otherNormal;
<a name="l00963"></a>00963        <span class="comment">// First the vertex</span>
<a name="l00964"></a>00964        memcpy(&amp;new_displ_data[vindex*numDim],
<a name="l00965"></a>00965            &amp;displ_datas[j][keepVertIDs[j][k]*numDim], 
<a name="l00966"></a>00966            numDim*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l00967"></a>00967        vindex++;
<a name="l00968"></a>00968        <span class="comment">// Then the parameterized point on the face</span>
<a name="l00969"></a>00969        <span class="keywordflow">for</span> (m = 0; m &lt; 4; m++) {
<a name="l00970"></a>00970          <span class="keywordtype">int</span> otherVertID = faceToVertConns[otherMesh][otherFaceID*4+m];
<a name="l00971"></a>00971          <span class="keywordflow">for</span> (n = 0; n &lt; numDim; n++)
<a name="l00972"></a>00972            otherFaceCoords[m][n] = coords[otherMesh][numDim*otherVertID+n]
<a name="l00973"></a>00973           + displ_datas[otherMesh][numDim*otherVertID+n];
<a name="l00974"></a>00974        }
<a name="l00975"></a>00975        <a class="code" href="group__PrivateGeometricRelations.html#g16a56e75e5ccb2deec37abfa5e532b73">_fc_calcQuadLocation</a>(otherFaceCoords, 2, keepParams[j][k],
<a name="l00976"></a>00976                       &amp;newPoint);
<a name="l00977"></a>00977        <span class="keywordflow">for</span> (m = 0; m &lt; numDim; m++)
<a name="l00978"></a>00978          new_displ_data[vindex*numDim+m] = newPoint[m] - 
<a name="l00979"></a>00979                                            new_coords[vindex*numDim+m];
<a name="l00980"></a>00980        vindex++;
<a name="l00981"></a>00981        <span class="comment">// Also save the face normals</span>
<a name="l00982"></a>00982        <span class="keywordflow">for</span> (m = 0; m &lt; 4; m++) {
<a name="l00983"></a>00983          <span class="keywordtype">int</span> thisVertID = faceToVertConns[j][thisFaceID*4+m];
<a name="l00984"></a>00984          <span class="keywordflow">for</span> (n = 0; n &lt; numDim; n++)
<a name="l00985"></a>00985            thisFaceCoords[m][n] = coords[j][numDim*thisVertID+n]
<a name="l00986"></a>00986           + displ_datas[j][numDim*thisVertID+n];
<a name="l00987"></a>00987        }
<a name="l00988"></a>00988        <a class="code" href="group__PrivateGeometricRelations.html#g220950bef4a17b1ad88db87868459421">_fc_calcSurfaceNormal</a>(4, thisFaceCoords, &amp;thisNormal);
<a name="l00989"></a>00989        <a class="code" href="group__PrivateGeometricRelations.html#g220950bef4a17b1ad88db87868459421">_fc_calcSurfaceNormal</a>(4, otherFaceCoords, &amp;otherNormal);
<a name="l00990"></a>00990        <span class="keywordflow">if</span> (faceOrients[j][thisFaceID] == faceOrients[otherMesh][otherFaceID]) {
<a name="l00991"></a>00991          <span class="keywordflow">for</span> (m = 0; m &lt; numDim; m++)
<a name="l00992"></a>00992            new_ave_face_data[eindex*numDim+m] = (thisNormal[m] - otherNormal[m])/2.;
<a name="l00993"></a>00993        }
<a name="l00994"></a>00994        <span class="keywordflow">else</span> {
<a name="l00995"></a>00995          <span class="keywordflow">for</span> (m = 0; m &lt; numDim; m++)
<a name="l00996"></a>00996            new_ave_face_data[eindex*numDim+m] = (thisNormal[m] + otherNormal[m])/2.;
<a name="l00997"></a>00997        }
<a name="l00998"></a>00998        <span class="comment">// also calc &amp; save isDead</span>
<a name="l00999"></a>00999        <span class="keywordflow">if</span> (numDeathVar &gt; 0) {
<a name="l01000"></a>01000          new_isDead_data[eindex] = <a class="code" href="gaplines_8c.html#924ef643e120d02e293b8afea03f1d69">isItDead</a>(numDeathVar, deathVarInfos,
<a name="l01001"></a>01001                                 thisElemID, death_datas[j],
<a name="l01002"></a>01002                                 otherElemID, death_datas[otherMesh]);
<a name="l01003"></a>01003          <span class="comment">//int isDead = 1;</span>
<a name="l01004"></a>01004          <span class="comment">//for (m = 0; m &lt; numDeathVar; m++) {</span>
<a name="l01005"></a>01005          <span class="comment">//}</span>
<a name="l01006"></a>01006 
<a name="l01007"></a>01007          <span class="comment">// FIX! do a real calc!</span>
<a name="l01008"></a>01008          <span class="comment">//if (death_datas[j][0][thisElemID] == 1 || </span>
<a name="l01009"></a>01009          <span class="comment">//death_datas[otherMesh][0][otherElemID] == 1) </span>
<a name="l01010"></a>01010          <span class="comment">// new_isDead_data[eindex] = 1;</span>
<a name="l01011"></a>01011          <span class="comment">//else</span>
<a name="l01012"></a>01012          <span class="comment">//new_isDead_data[eindex] = 0;</span>
<a name="l01013"></a>01013        }
<a name="l01014"></a>01014        eindex++;
<a name="l01015"></a>01015      }
<a name="l01016"></a>01016       }
<a name="l01017"></a>01017       rc = <a class="code" href="group__Variable.html#g4491a3d96b7252fd5d0de54089d6838d">fc_setVariableDataPtr</a>(gap_displ[i], numVertex, numDim, <a class="code" href="group__DataTypes.html#gg63044bd7bb5313d8a79ea8a71f1b30408cc812de98bed6c7106d5fa72e11f726">FC_AT_VERTEX</a>,
<a name="l01018"></a>01018                      <a class="code" href="group__DataTypes.html#ggf4416c02a52bd37e799d442b985151b367e06c1812f7a0127035e27d14fd597d">FC_MT_VECTOR</a>, <a class="code" href="group__DataTypes.html#ggbbab9b2f35d4bc42e868e4f5853a6297806cef8a12ffc6ef267ac21addb95ab3">FC_DT_DOUBLE</a>, 
<a name="l01019"></a>01019                      (<span class="keywordtype">void</span>*)new_displ_data);
<a name="l01020"></a>01020       <a class="code" href="group__ErrorHandling.html#g4a09c0024ecd45d5d63c8b9ec333a717">fc_exitIfError</a>(rc);
<a name="l01021"></a>01021       rc = <a class="code" href="group__Variable.html#g4491a3d96b7252fd5d0de54089d6838d">fc_setVariableDataPtr</a>(aveFaceNorms[i], numElement, numDim, 
<a name="l01022"></a>01022                      <a class="code" href="group__DataTypes.html#gg63044bd7bb5313d8a79ea8a71f1b3040f4be04f2efb0e31c558b6146cf83f191">FC_AT_ELEMENT</a>, <a class="code" href="group__DataTypes.html#ggf4416c02a52bd37e799d442b985151b367e06c1812f7a0127035e27d14fd597d">FC_MT_VECTOR</a>, <a class="code" href="group__DataTypes.html#ggbbab9b2f35d4bc42e868e4f5853a6297806cef8a12ffc6ef267ac21addb95ab3">FC_DT_DOUBLE</a>, 
<a name="l01023"></a>01023                    (<span class="keywordtype">void</span>*)new_ave_face_data);
<a name="l01024"></a>01024       <a class="code" href="group__ErrorHandling.html#g4a09c0024ecd45d5d63c8b9ec333a717">fc_exitIfError</a>(rc);
<a name="l01025"></a>01025       free(displ_datas[0]);
<a name="l01026"></a>01026       free(displ_datas[1]);
<a name="l01027"></a>01027       <span class="keywordflow">if</span> (numDeathVar &gt; 0) {
<a name="l01028"></a>01028      rc = <a class="code" href="group__Variable.html#g4491a3d96b7252fd5d0de54089d6838d">fc_setVariableDataPtr</a>(isDeadVar[i], numElement, 1, <a class="code" href="group__DataTypes.html#gg63044bd7bb5313d8a79ea8a71f1b3040f4be04f2efb0e31c558b6146cf83f191">FC_AT_ELEMENT</a>,
<a name="l01029"></a>01029                      <a class="code" href="group__DataTypes.html#ggf4416c02a52bd37e799d442b985151b3599bbbe8f8e41851a17f1037bd44a83f">FC_MT_SCALAR</a>, <a class="code" href="group__DataTypes.html#ggbbab9b2f35d4bc42e868e4f5853a6297f0b74a7d9f58ca6960dd832980645f7d">FC_DT_INT</a>, (<span class="keywordtype">void</span>*)new_isDead_data);
<a name="l01030"></a>01030      <a class="code" href="group__ErrorHandling.html#g4a09c0024ecd45d5d63c8b9ec333a717">fc_exitIfError</a>(rc);
<a name="l01031"></a>01031      <span class="keywordflow">for</span> (j = 0; j &lt; 2; j++) {
<a name="l01032"></a>01032        <span class="keywordflow">for</span> (k = 0; k &lt; numDeathVar; k++)
<a name="l01033"></a>01033          free(death_datas[j][k]);
<a name="l01034"></a>01034        free(death_datas[j]);
<a name="l01035"></a>01035      }
<a name="l01036"></a>01036       }
<a name="l01037"></a>01037     }
<a name="l01038"></a>01038   }
<a name="l01039"></a>01039   free(displs[0]);
<a name="l01040"></a>01040   free(displs[1]);
<a name="l01041"></a>01041   <span class="comment">// FIX free death seq vars arrays (but not the vars)</span>
<a name="l01042"></a>01042 
<a name="l01043"></a>01043   <span class="comment">// Create more variables</span>
<a name="l01044"></a>01044   {
<a name="l01045"></a>01045     <a class="code" href="structFC__Variable.html">FC_Variable</a> templengths[numStep], tempnorms[numStep], temptangs[numStep];
<a name="l01046"></a>01046     <span class="keywordflow">for</span> (i = 0; i &lt; numStep; i++) {
<a name="l01047"></a>01047       <a class="code" href="structFC__Variable.html">FC_Variable</a> tempvector, tempnorm, temptang;
<a name="l01048"></a>01048       rc = <a class="code" href="group__GeometricRelations.html#g723de1cc925a8cc252e36dd7cea01fd6">fc_getDisplacedEdgeLengths</a>(gap_mesh, gap_displ[i], &amp;templengths[i]);
<a name="l01049"></a>01049       <a class="code" href="group__ErrorHandling.html#g4a09c0024ecd45d5d63c8b9ec333a717">fc_exitIfError</a>(rc);
<a name="l01050"></a>01050       rc = <a class="code" href="gaplines_8c.html#0c08829553c7fe4564d36fc982cb1bb1">getLinesAsVectors</a>(gap_mesh, gap_displ[i], &amp;tempvector);
<a name="l01051"></a>01051       <a class="code" href="group__ErrorHandling.html#g4a09c0024ecd45d5d63c8b9ec333a717">fc_exitIfError</a>(rc);
<a name="l01052"></a>01052       rc = <a class="code" href="group__VariableMath.html#g6b7fd07f05be873eee13d4c16a74e76b">fc_createNormalTangentVariables2</a>(tempvector, aveFaceNorms[i],
<a name="l01053"></a>01053                              &amp;tempnorm, &amp;temptang);
<a name="l01054"></a>01054       <a class="code" href="group__ErrorHandling.html#g4a09c0024ecd45d5d63c8b9ec333a717">fc_exitIfError</a>(rc);
<a name="l01055"></a>01055       rc = <a class="code" href="group__VariableMath.html#g84b3f6963472cbe8c79fe1d6c1c39640">fc_varUnaryFunction</a>(tempnorm, fabs, <span class="stringliteral">"normal"</span>, &amp;tempnorms[i]);
<a name="l01056"></a>01056       <a class="code" href="group__ErrorHandling.html#g4a09c0024ecd45d5d63c8b9ec333a717">fc_exitIfError</a>(rc);
<a name="l01057"></a>01057       rc = <a class="code" href="group__VariableMath.html#g84b3f6963472cbe8c79fe1d6c1c39640">fc_varUnaryFunction</a>(temptang, fabs, <span class="stringliteral">"tanget"</span>, &amp;temptangs[i]);
<a name="l01058"></a>01058       <a class="code" href="group__ErrorHandling.html#g4a09c0024ecd45d5d63c8b9ec333a717">fc_exitIfError</a>(rc);
<a name="l01059"></a>01059       <a class="code" href="group__Variable.html#g2f48fcbd551131488dd5757c27364656">fc_deleteVariable</a>(tempvector);
<a name="l01060"></a>01060       <a class="code" href="group__Variable.html#g2f48fcbd551131488dd5757c27364656">fc_deleteVariable</a>(tempnorm);
<a name="l01061"></a>01061       <a class="code" href="group__Variable.html#g2f48fcbd551131488dd5757c27364656">fc_deleteVariable</a>(temptang);
<a name="l01062"></a>01062     }
<a name="l01063"></a>01063     rc = <a class="code" href="group__Variable.html#g61fe9ebf0de41291042f685580b6d272">fc_convertVariablesToSeqVariable</a>(numStep, templengths, sequence, 
<a name="l01064"></a>01064                          <span class="stringliteral">"length"</span>, &amp;lengths);
<a name="l01065"></a>01065     <a class="code" href="group__ErrorHandling.html#g4a09c0024ecd45d5d63c8b9ec333a717">fc_exitIfError</a>(rc);
<a name="l01066"></a>01066     rc = <a class="code" href="group__Variable.html#g61fe9ebf0de41291042f685580b6d272">fc_convertVariablesToSeqVariable</a>(numStep, tempnorms, sequence, 
<a name="l01067"></a>01067                          <span class="stringliteral">"length_norm"</span>, &amp;norms);
<a name="l01068"></a>01068     <a class="code" href="group__ErrorHandling.html#g4a09c0024ecd45d5d63c8b9ec333a717">fc_exitIfError</a>(rc);
<a name="l01069"></a>01069     rc = <a class="code" href="group__Variable.html#g61fe9ebf0de41291042f685580b6d272">fc_convertVariablesToSeqVariable</a>(numStep, temptangs, sequence, 
<a name="l01070"></a>01070                          <span class="stringliteral">"length_tang"</span>, &amp;tangs);
<a name="l01071"></a>01071     <a class="code" href="group__ErrorHandling.html#g4a09c0024ecd45d5d63c8b9ec333a717">fc_exitIfError</a>(rc);
<a name="l01072"></a>01072   }
<a name="l01073"></a>01073 
<a name="l01074"></a>01074   <span class="comment">/*</span>
<a name="l01075"></a>01075 <span class="comment">  { // for debugging - make gaplines from this and from other</span>
<a name="l01076"></a>01076 <span class="comment">    int eindex = 0;</span>
<a name="l01077"></a>01077 <span class="comment">    for (i = 0; i &lt; 2; i++) {</span>
<a name="l01078"></a>01078 <span class="comment">      FC_Mesh temp_mesh;</span>
<a name="l01079"></a>01079 <span class="comment">      FC_Subset temp_subset;</span>
<a name="l01080"></a>01080 <span class="comment">      if (i == 0) </span>
<a name="l01081"></a>01081 <span class="comment">     sprintf(charBuf, "thisGaplines");</span>
<a name="l01082"></a>01082 <span class="comment">      else</span>
<a name="l01083"></a>01083 <span class="comment">     sprintf(charBuf, "otherGaplines");</span>
<a name="l01084"></a>01084 <span class="comment">      fc_createSubset(gap_mesh, charBuf, FC_AT_ELEMENT, &amp;temp_subset);</span>
<a name="l01085"></a>01085 <span class="comment">      for (j = 0; j &lt; numKeeps[i]; j++) {</span>
<a name="l01086"></a>01086 <span class="comment">     fc_addMemberToSubset(temp_subset, eindex);</span>
<a name="l01087"></a>01087 <span class="comment">     eindex++;</span>
<a name="l01088"></a>01088 <span class="comment">      }</span>
<a name="l01089"></a>01089 <span class="comment">      // HACK for exodus not writing element subsets</span>
<a name="l01090"></a>01090 <span class="comment">      fc_createSubsetMesh(temp_subset, dataset, 1, charBuf, &amp;temp_mesh);</span>
<a name="l01091"></a>01091 <span class="comment">    }</span>
<a name="l01092"></a>01092 <span class="comment">  }</span>
<a name="l01093"></a>01093 <span class="comment">  */</span>
<a name="l01094"></a>01094 
<a name="l01095"></a>01095   <span class="comment">// Create per side gaplines subset</span>
<a name="l01096"></a>01096   {
<a name="l01097"></a>01097     <span class="keywordtype">int</span> eindex;
<a name="l01098"></a>01098     <a class="code" href="structFC__SortedIntArray.html">FC_SortedIntArray</a> **sias[2];
<a name="l01099"></a>01099     <span class="comment">// create initialize lists</span>
<a name="l01100"></a>01100     <span class="keywordflow">for</span> (i = 0; i &lt; 2; i++) { 
<a name="l01101"></a>01101       sias[i] = malloc(numShapes[i]*<span class="keyword">sizeof</span>(<a class="code" href="structFC__SortedIntArray.html">FC_SortedIntArray</a>*));
<a name="l01102"></a>01102       <span class="keywordflow">if</span> (sias[i] == NULL)
<a name="l01103"></a>01103      <a class="code" href="group__ErrorHandling.html#g4a09c0024ecd45d5d63c8b9ec333a717">fc_exitIfError</a>(<a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52ee4bf428a2cdead5d4e3e3391a2cdab0d">FC_MEMORY_ERROR</a>);
<a name="l01104"></a>01104       <span class="keywordflow">for</span> (j = 0; j &lt; numShapes[i]; j++) {
<a name="l01105"></a>01105      sias[i][j] = calloc(shapes[i][j].numSides, <span class="keyword">sizeof</span>(FC_SortedIntArray));
<a name="l01106"></a>01106      <span class="keywordflow">if</span> (sias[i][j] == NULL)
<a name="l01107"></a>01107        <a class="code" href="group__ErrorHandling.html#g4a09c0024ecd45d5d63c8b9ec333a717">fc_exitIfError</a>(FC_MEMORY_ERROR);
<a name="l01108"></a>01108       }
<a name="l01109"></a>01109     }
<a name="l01110"></a>01110     <span class="comment">// add gapline ids to appropriate lists</span>
<a name="l01111"></a>01111     eindex = 0;
<a name="l01112"></a>01112     <span class="keywordflow">for</span> (i = 0; i &lt; 2; i++) {
<a name="l01113"></a>01113       <span class="keywordtype">int</span> otherMesh = (i == 0 ? 1 : 0);
<a name="l01114"></a>01114       <span class="keywordflow">for</span> (j = 0; j &lt; numKeeps[i]; j++) {
<a name="l01115"></a>01115      <span class="keywordtype">int</span> shapeID, sideID;
<a name="l01116"></a>01116      <a class="code" href="gaplines_8c.html#74fcd9342cefc46ed067f5f766289e82">findShapeSide</a>(keepThisFaceIDs[i][j], numShapes[i], shapes[i], 
<a name="l01117"></a>01117                 &amp;shapeID, &amp;sideID);
<a name="l01118"></a>01118      <a class="code" href="group__SimpleDataObjects.html#g64768f52c122c1cd322cbebac85979f2">fc_addIntToSortedIntArray</a>(&amp;sias[i][shapeID][sideID], eindex);
<a name="l01119"></a>01119      <a class="code" href="gaplines_8c.html#74fcd9342cefc46ed067f5f766289e82">findShapeSide</a>(keepOtherFaceIDs[i][j], numShapes[otherMesh],
<a name="l01120"></a>01120            shapes[otherMesh], &amp;shapeID, &amp;sideID);
<a name="l01121"></a>01121      <a class="code" href="group__SimpleDataObjects.html#g64768f52c122c1cd322cbebac85979f2">fc_addIntToSortedIntArray</a>(&amp;sias[otherMesh][shapeID][sideID], eindex);
<a name="l01122"></a>01122      eindex++;
<a name="l01123"></a>01123       }
<a name="l01124"></a>01124     }
<a name="l01125"></a>01125     <span class="comment">// make subset of non empty lists</span>
<a name="l01126"></a>01126     numSide = 0;
<a name="l01127"></a>01127     sides = NULL;
<a name="l01128"></a>01128     <span class="comment">// loop over first mesh's shapes</span>
<a name="l01129"></a>01129     <span class="keywordflow">for</span> (i = 0; i &lt; numShapes[0]; i++) {
<a name="l01130"></a>01130       <span class="keywordflow">for</span> (j = 0; j &lt; shapes[0][i].<a class="code" href="structFC__Shape.html#0bf1533a6d673f68e4a2b2544f3920d2">numSides</a>; j++) {
<a name="l01131"></a>01131 
<a name="l01132"></a>01132      <span class="comment">// skip if no entries</span>
<a name="l01133"></a>01133      <span class="keywordflow">if</span> (sias[0][i][j].numVal &lt; 1)
<a name="l01134"></a>01134        <span class="keywordflow">continue</span>;
<a name="l01135"></a>01135 
<a name="l01136"></a>01136      <span class="comment">// loop over 2nd mesh's shapes</span>
<a name="l01137"></a>01137      <span class="keywordflow">for</span> (k = 0; k &lt; numShapes[1]; k++) {
<a name="l01138"></a>01138        <span class="keywordflow">for</span> (m = 0; m &lt; shapes[1][k].<a class="code" href="structFC__Shape.html#0bf1533a6d673f68e4a2b2544f3920d2">numSides</a>; m++) {
<a name="l01139"></a>01139          <a class="code" href="structFC__SortedIntArray.html">FC_SortedIntArray</a> temp_sia = { 0, 0, 0 };
<a name="l01140"></a>01140 
<a name="l01141"></a>01141          <span class="comment">// skip if no entries</span>
<a name="l01142"></a>01142          <span class="keywordflow">if</span> (sias[1][k][m].numVal &lt; 1)
<a name="l01143"></a>01143            <span class="keywordflow">continue</span>;
<a name="l01144"></a>01144 
<a name="l01145"></a>01145          <span class="comment">// look for intersection</span>
<a name="l01146"></a>01146          <a class="code" href="gaplines_8c.html#8dbbc7f24e3ff9d7d456001329e56dc2">getRemoveSIAIntersection</a>(&amp;sias[0][i][j], &amp;sias[1][k][m], 
<a name="l01147"></a>01147                          &amp;temp_sia);
<a name="l01148"></a>01148          <span class="keywordflow">if</span> (temp_sia.numVal &gt; 0) {
<a name="l01149"></a>01149            <a class="code" href="structFC__Subset.html">FC_Subset</a> temp_subset;
<a name="l01150"></a>01150            <span class="keywordtype">char</span> *subset_name = malloc((strlen(mesh_names[0]) +
<a name="l01151"></a>01151                            strlen(mesh_names[1]) + 
<a name="l01152"></a>01152                            100)*<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));
<a name="l01153"></a>01153            sprintf(subset_name, <span class="stringliteral">"%s_shape%d_side%d-%s_shape%d_side%d"</span>,
<a name="l01154"></a>01154                 mesh_names[0], i, j, mesh_names[1], k, m);
<a name="l01155"></a>01155            rc = <a class="code" href="group__Subset.html#g40d47282abccd83987c83e8051064db2">fc_createSubset</a>(gap_mesh, subset_name, <a class="code" href="group__DataTypes.html#gg63044bd7bb5313d8a79ea8a71f1b3040f4be04f2efb0e31c558b6146cf83f191">FC_AT_ELEMENT</a>,
<a name="l01156"></a>01156                      &amp;temp_subset);
<a name="l01157"></a>01157            <a class="code" href="group__ErrorHandling.html#g4a09c0024ecd45d5d63c8b9ec333a717">fc_exitIfError</a>(rc);
<a name="l01158"></a>01158            free(subset_name);
<a name="l01159"></a>01159            <a class="code" href="group__Subset.html#g47d34843c8d66c114c2c81e3a1fc14e4">fc_addArrayMembersToSubset</a>(temp_subset, temp_sia.numVal, 
<a name="l01160"></a>01160                           temp_sia.vals);
<a name="l01161"></a>01161            <a class="code" href="group__SimpleDataObjects.html#ga6ecd909b91f581633b4accbc88642b2">fc_freeSortedIntArray</a>(&amp;temp_sia);
<a name="l01162"></a>01162            sides = realloc(sides, (numSide+1)*<span class="keyword">sizeof</span>(<a class="code" href="structFC__Subset.html">FC_Subset</a>));
<a name="l01163"></a>01163            <span class="keywordflow">if</span> (!sides) 
<a name="l01164"></a>01164           <a class="code" href="group__ErrorHandling.html#g4a09c0024ecd45d5d63c8b9ec333a717">fc_exitIfError</a>(<a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52ee4bf428a2cdead5d4e3e3391a2cdab0d">FC_MEMORY_ERROR</a>);
<a name="l01165"></a>01165            sides[numSide] = temp_subset;
<a name="l01166"></a>01166            numSide++;
<a name="l01167"></a>01167          }
<a name="l01168"></a>01168        }
<a name="l01169"></a>01169      } <span class="comment">// done' with 2nd mesh's shapes</span>
<a name="l01170"></a>01170       }
<a name="l01171"></a>01171     } <span class="comment">// done with 1 mesh's shapes</span>
<a name="l01172"></a>01172     <span class="comment">// delete lists</span>
<a name="l01173"></a>01173     <span class="keywordflow">for</span> (i = 0; i &lt; 2; i++) { 
<a name="l01174"></a>01174       <span class="keywordflow">for</span> (j = 0; j &lt; numShapes[i]; j++) {
<a name="l01175"></a>01175      <span class="keywordflow">for</span> (k = 0; k &lt; shapes[i][j].<a class="code" href="structFC__Shape.html#0bf1533a6d673f68e4a2b2544f3920d2">numSides</a>; k++) 
<a name="l01176"></a>01176        <a class="code" href="group__SimpleDataObjects.html#ga6ecd909b91f581633b4accbc88642b2">fc_freeSortedIntArray</a>(&amp;sias[i][j][k]);
<a name="l01177"></a>01177      free(sias[i][j]);
<a name="l01178"></a>01178       }
<a name="l01179"></a>01179       free(sias[i]);
<a name="l01180"></a>01180     }
<a name="l01181"></a>01181   } 
<a name="l01182"></a>01182 
<a name="l01183"></a>01183   <span class="comment">// make alive subsets for entire gap mesh</span>
<a name="l01184"></a>01184   alivePerTime = NULL;
<a name="l01185"></a>01185   <span class="keywordflow">if</span> (numDeathVar &gt; 0) {
<a name="l01186"></a>01186     <span class="comment">//FC_Mesh temp_mesh;</span>
<a name="l01187"></a>01187     alivePerTime = (<a class="code" href="structFC__Subset.html">FC_Subset</a>*)malloc(numStep*<span class="keyword">sizeof</span>(<a class="code" href="structFC__Subset.html">FC_Subset</a>));
<a name="l01188"></a>01188     <span class="keywordflow">for</span> (i = 0; i &lt; numStep; i++) {
<a name="l01189"></a>01189       rc = <a class="code" href="group__Threshold.html#g96adad55812ccdee300831275ea3b355">fc_createThresholdSubset</a>(isDeadVar[i], <span class="stringliteral">"=="</span>, 0, <span class="stringliteral">"temp"</span>,
<a name="l01190"></a>01190                         &amp;alivePerTime[i]);
<a name="l01191"></a>01191       <a class="code" href="error_8h.html#42c09317184affa18e70826cb35f3f04">fc_exitIfErrorPrintf</a>(rc, <span class="stringliteral">"failed to create alive subset"</span>);
<a name="l01192"></a>01192       <span class="comment">// FIX delete these subsets</span>
<a name="l01193"></a>01193       <span class="comment">// debug hack</span>
<a name="l01194"></a>01194       <span class="comment">//sprintf(charBuf, "alive at step %d", i);</span>
<a name="l01195"></a>01195       <span class="comment">//rc = fc_createSubsetMesh(alivePerTime[i], dataset, 1, charBuf, </span>
<a name="l01196"></a>01196       <span class="comment">//              &amp;temp_mesh);</span>
<a name="l01197"></a>01197       <span class="comment">//fc_exitIfErrorPrintf(rc, "could not create mesh versin of alive subset");</span>
<a name="l01198"></a>01198     }
<a name="l01199"></a>01199   }
<a name="l01200"></a>01200 
<a name="l01201"></a>01201   <span class="comment">// Report min/max/ave/stdev lengths of lines for each step</span>
<a name="l01202"></a>01202   rc = <a class="code" href="group__Sequence.html#g71cc991334f68976219fae136693ff38">fc_getSequenceCoordsAsDataType</a>(sequence, <a class="code" href="group__DataTypes.html#ggbbab9b2f35d4bc42e868e4f5853a6297806cef8a12ffc6ef267ac21addb95ab3">FC_DT_DOUBLE</a>,
<a name="l01203"></a>01203                           (<span class="keywordtype">void</span>**)&amp;seq_coords); 
<a name="l01204"></a>01204   <a class="code" href="error_8h.html#42c09317184affa18e70826cb35f3f04">fc_exitIfErrorPrintf</a>(rc, <span class="stringliteral">"Failed to get sequence coords"</span>);
<a name="l01205"></a>01205 
<a name="l01206"></a>01206   printf(<span class="stringliteral">"\n"</span>);
<a name="l01207"></a>01207   printf(<span class="stringliteral">"Number of gap lines found = %d\n"</span>, numKeeps[0] + numKeeps[1]);
<a name="l01208"></a>01208   printf(<span class="stringliteral">"Number of sets of sides involved = %d\n"</span>, numSide);
<a name="l01209"></a>01209   <span class="keywordflow">for</span> (i = 0; i &lt; numSide; i++) {
<a name="l01210"></a>01210     <span class="keywordtype">int</span> numMember;
<a name="l01211"></a>01211     <span class="keywordtype">char</span> *temp_name;
<a name="l01212"></a>01212     <a class="code" href="group__Subset.html#gf8d751f06ea68d6944e19816147d35a9">fc_getSubsetName</a>(sides[i], &amp;temp_name);
<a name="l01213"></a>01213     <a class="code" href="group__Subset.html#g8b932d306fb8f41ef49677f803fd9fd1">fc_getSubsetNumMember</a>(sides[i], &amp;numMember);
<a name="l01214"></a>01214     printf(<span class="stringliteral">"\n"</span>);
<a name="l01215"></a>01215     printf(<span class="stringliteral">"Stats for set %d ('%s'):\n"</span>, i, temp_name);
<a name="l01216"></a>01216     free(temp_name);
<a name="l01217"></a>01217     printf(<span class="stringliteral">"numGapline = %d\n"</span>, numMember);
<a name="l01218"></a>01218     <a class="code" href="gaplines_8c.html#29506051f4d43ef02475c1242af995c5">printStats</a>(<span class="stringliteral">"Gap Length"</span>, numStep, lengths, &amp;sides[i], alivePerTime,
<a name="l01219"></a>01219             seq_coords);
<a name="l01220"></a>01220     <a class="code" href="gaplines_8c.html#29506051f4d43ef02475c1242af995c5">printStats</a>(<span class="stringliteral">"Normal Component of Gap Length"</span>, numStep, norms,
<a name="l01221"></a>01221             &amp;sides[i], alivePerTime, seq_coords);
<a name="l01222"></a>01222     <a class="code" href="gaplines_8c.html#29506051f4d43ef02475c1242af995c5">printStats</a>(<span class="stringliteral">"Tangent Component of Gap Length"</span>, numStep, tangs,
<a name="l01223"></a>01223             &amp;sides[i], alivePerTime, seq_coords);
<a name="l01224"></a>01224   }
<a name="l01225"></a>01225   <span class="keywordflow">if</span> (numSide &gt; 1) {
<a name="l01226"></a>01226     printf(<span class="stringliteral">"\n"</span>);
<a name="l01227"></a>01227     printf(<span class="stringliteral">"Overall stats:\n"</span>);
<a name="l01228"></a>01228     printf(<span class="stringliteral">"numGapline = %d\n"</span>, numKeeps[0] + numKeeps[1]);
<a name="l01229"></a>01229     fflush(NULL);
<a name="l01230"></a>01230     <a class="code" href="gaplines_8c.html#29506051f4d43ef02475c1242af995c5">printStats</a>(<span class="stringliteral">"Gap Length"</span>, numStep, lengths, NULL, alivePerTime, seq_coords);
<a name="l01231"></a>01231     <a class="code" href="gaplines_8c.html#29506051f4d43ef02475c1242af995c5">printStats</a>(<span class="stringliteral">"Normal Component of Gap Length"</span>, numStep, norms, NULL,
<a name="l01232"></a>01232             alivePerTime, seq_coords);
<a name="l01233"></a>01233     <a class="code" href="gaplines_8c.html#29506051f4d43ef02475c1242af995c5">printStats</a>(<span class="stringliteral">"Tangent Component of Gap Length"</span>, numStep, tangs, NULL,
<a name="l01234"></a>01234             alivePerTime, seq_coords);
<a name="l01235"></a>01235   }
<a name="l01236"></a>01236   fflush(NULL);
<a name="l01237"></a>01237 
<a name="l01238"></a>01238   <span class="comment">// delete some more stuff so that it doesn't show up in output</span>
<a name="l01239"></a>01239   <span class="keywordflow">for</span> (i = 0; i &lt; 2; i++) {
<a name="l01240"></a>01240     <span class="keywordflow">for</span> (j = 0; j &lt; numShapes[i]; j++)
<a name="l01241"></a>01241       <a class="code" href="group__Shape.html#g472eb5141c2ac7917aae158bb6181eb5">fc_freeShape</a>(&amp;shapes[i][j]);
<a name="l01242"></a>01242     free(shapes[i]);
<a name="l01243"></a>01243   }
<a name="l01244"></a>01244   <a class="code" href="group__Variable.html#g57341fab4863efe2c35476aee509f20d">fc_deleteSeqVariable</a>(numStep, aveFaceNorms);
<a name="l01245"></a>01245 
<a name="l01246"></a>01246   <span class="comment">// FIX! HACK! Since exodus can't write element subsets, create mesh </span>
<a name="l01247"></a>01247   <span class="comment">// copies of sides</span>
<a name="l01248"></a>01248   <span class="keywordflow">for</span> (i = 0; i &lt; numSide; i++) {
<a name="l01249"></a>01249     <a class="code" href="structFC__Mesh.html">FC_Mesh</a> temp_mesh;
<a name="l01250"></a>01250     <span class="keywordtype">char</span> *temp_name;
<a name="l01251"></a>01251     <a class="code" href="group__Subset.html#gf8d751f06ea68d6944e19816147d35a9">fc_getSubsetName</a>(sides[i], &amp;temp_name);
<a name="l01252"></a>01252     rc = <a class="code" href="group__Mesh.html#gb576e8dd50a853aa248c1a189cf2384b">fc_createSubsetMesh</a>(sides[i], dataset, 1, temp_name, &amp;temp_mesh);
<a name="l01253"></a>01253     free(temp_name);
<a name="l01254"></a>01254     <a class="code" href="error_8h.html#42c09317184affa18e70826cb35f3f04">fc_exitIfErrorPrintf</a>(rc, 
<a name="l01255"></a>01255                        <span class="stringliteral">"Could not create mesh versions of the side subsets"</span>);
<a name="l01256"></a>01256   }
<a name="l01257"></a>01257 
<a name="l01258"></a>01258   <span class="comment">// Write the gaplines dataset</span>
<a name="l01259"></a>01259   <span class="keywordflow">if</span> (verbose_level &gt; <a class="code" href="group__DataTypes.html#gg6c0891f21e34bad1d8b2bc7c76193a399cb0ad9c1f97775f8954860a08d78144">FC_QUIET</a>) {
<a name="l01260"></a>01260     printf(<span class="stringliteral">"Writing gaplines dataset ...\n"</span>);
<a name="l01261"></a>01261     fflush(NULL);
<a name="l01262"></a>01262   }
<a name="l01263"></a>01263   {
<a name="l01264"></a>01264     <span class="keywordtype">char</span> *temp_name;
<a name="l01265"></a>01265     <a class="code" href="group__Dataset.html#g73ffaa788f8d780ae78b33d47e22078c">fc_getDatasetName</a>(dataset, &amp;temp_name);
<a name="l01266"></a>01266     sprintf(charBuf, <span class="stringliteral">"gap lines for '"</span>);
<a name="l01267"></a>01267     strncat(charBuf, temp_name, 1000);
<a name="l01268"></a>01268     free(temp_name);
<a name="l01269"></a>01269     strncat(charBuf, <span class="stringliteral">"'"</span>, 1);
<a name="l01270"></a>01270     <a class="code" href="group__Dataset.html#g11550c2f0ed5177773fea3058929b33f">fc_changeDatasetName</a>(dataset, charBuf);
<a name="l01271"></a>01271     <a class="code" href="group__FileIO.html#ge858ea01dcbf5464b07a9024475cb66a">fc_rewriteDataset</a>(dataset, <span class="stringliteral">"gaplines.ex2"</span>, <a class="code" href="group__FileIO.html#gg4647ac3054682609036d15ddf55055d563b4812ed953ad6ecd01be20b81c46a3">FC_FT_EXODUS</a>);
<a name="l01272"></a>01272   }
<a name="l01273"></a>01273 
<a name="l01274"></a>01274   <span class="comment">// Final library</span>
<a name="l01275"></a>01275   <a class="code" href="group__Library.html#g68cec1422dde03b636cf039faafa7baa">fc_finalLibrary</a>();
<a name="l01276"></a>01276 
<a name="l01277"></a>01277   exit(0);  
<a name="l01278"></a>01278 }
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Oct 31 11:09:59 2007 for FCLib by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1 </small></address>
</body>
</html>
