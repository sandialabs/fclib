<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>FCLib: Element Death</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="classes.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Element Death<br>
<small>
[<a class="el" href="group__API.html">FCLib API</a>]</small>
</h1>
<p>
<div class="dynheader">
Collaboration diagram for Element Death:</div>
<div class="dynsection">
<center><table><tr><td><img src="group__ElemDeath.gif" border="0" alt="" usemap="#group____ElemDeath_map">
<map name="group____ElemDeath_map">
<area shape="rect" href="group__PrivateElemDeath.html" title="(Private)" alt="" coords="321,5,401,32"><area shape="rect" href="group__API.html" title="Feature Characterization Library." alt="" coords="7,5,92,32"></map></td></tr></table></center>
</div>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Dead element analysis routines and helper functions. 
<p>
<b>Description:</b> <p>
In many simulations, changing mesh topology is approximated by allowing elements to "die". The mesh topology stays the same, but any elements that are labeld "dead" no longer participate in the simulation. Dead elements can be used to model rips, tears and other changes in the mesh.<p>
The input of most of the routines in this module is a subset representing a dead element region, and is assumed to have the association type of FC_AT_ELEMENT. It is also assumed that the coordinates of vertices within an dead element region cannot be trusted (the vertices on the boundary of the dead element region may be o.k. if they are still on live elements).<p>
A dead element region does not have to be a single topological segment, but most of the results are more easily interpreted if this is true. 
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Modules</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PrivateElemDeath.html">(Private)</a></td></tr>

<tr><td colspan="2"><br><h2>Decay of Subsets</h2></td></tr>
<tr><td colspan="2"><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DataTypes.html#g2a40aa471d085988d5b582669f766ce4">FC_ReturnCode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ElemDeath.html#g2d37a81b1e6240c627462e067ce4861a">fc_getExposedSkin</a> (<a class="el" href="structFC__Subset.html">FC_Subset</a> subset, <a class="el" href="structFC__Subset.html">FC_Subset</a> *opt_meshSkin, <a class="el" href="structFC__Subset.html">FC_Subset</a> *exposed)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get exposed skin.  <a href="#g2d37a81b1e6240c627462e067ce4861a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DataTypes.html#g2a40aa471d085988d5b582669f766ce4">FC_ReturnCode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ElemDeath.html#gcf6293155cfec71e92d3ef592bcb4b51">fc_getDecayedSkin</a> (<a class="el" href="structFC__Subset.html">FC_Subset</a> deadregion, <a class="el" href="structFC__Subset.html">FC_Subset</a> *opt_meshSkin, <a class="el" href="structFC__Subset.html">FC_Subset</a> *decayedSkin)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get decayed skin.  <a href="#gcf6293155cfec71e92d3ef592bcb4b51"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DataTypes.html#g2a40aa471d085988d5b582669f766ce4">FC_ReturnCode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ElemDeath.html#g7f53a591070ef1f242ee2574e1556a8e">fc_getSubsetDecayType</a> (<a class="el" href="structFC__Subset.html">FC_Subset</a> deadSubset, <a class="el" href="structFC__Subset.html">FC_Subset</a> compSubset, int *sidedecayflag)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get identifier telling if deadSubset intersects, or entirely erodes a subset.  <a href="#g7f53a591070ef1f242ee2574e1556a8e"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Decay of Shapes</h2></td></tr>
<tr><td colspan="2"><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DataTypes.html#g2a40aa471d085988d5b582669f766ce4">FC_ReturnCode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ElemDeath.html#gf43b12767fdb725a1f10e96c9b6d70d1">fc_getDecayedShapeSkin</a> (<a class="el" href="structFC__Subset.html">FC_Subset</a> deadregion, <a class="el" href="structFC__Shape.html">FC_Shape</a> *shape, <a class="el" href="structFC__Subset.html">FC_Subset</a> *decayedSkin)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the decayed Skin.  <a href="#gf43b12767fdb725a1f10e96c9b6d70d1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DataTypes.html#g2a40aa471d085988d5b582669f766ce4">FC_ReturnCode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ElemDeath.html#gccd459337d17ffd659545b5252ad569b">fc_getDecayedShapeSides</a> (<a class="el" href="structFC__Subset.html">FC_Subset</a> deadregion, <a class="el" href="structFC__Shape.html">FC_Shape</a> *shape, <a class="el" href="structFC__Subset.html">FC_Subset</a> **decayedSides)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the decayed item of each of a shapes sides.  <a href="#gccd459337d17ffd659545b5252ad569b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DataTypes.html#g2a40aa471d085988d5b582669f766ce4">FC_ReturnCode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ElemDeath.html#g5cef93bfeb2c73c7990a26be98b44849">fc_getShapeSidesDecayType</a> (<a class="el" href="structFC__Subset.html">FC_Subset</a> deadSubset, <a class="el" href="structFC__Shape.html">FC_Shape</a> *shape, int **sidedecayflag)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get identifier telling if deadSubset intersects or entirely erodes the sides of a shape.  <a href="#g5cef93bfeb2c73c7990a26be98b44849"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Dead region segmenting mesh</h2></td></tr>
<tr><td colspan="2"><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DataTypes.html#g2a40aa471d085988d5b582669f766ce4">FC_ReturnCode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ElemDeath.html#g332e59c8a844757b89063201843da456">fc_subsetSegmentsMesh</a> (<a class="el" href="structFC__Subset.html">FC_Subset</a> subset, int shared_segdim, char *varname, int *numSubset, <a class="el" href="structFC__Subset.html">FC_Subset</a> **newSubsets)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns the segments (and their number) that result from segmenting the mesh by the input subset.  <a href="#g332e59c8a844757b89063201843da456"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DataTypes.html#g2a40aa471d085988d5b582669f766ce4">FC_ReturnCode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ElemDeath.html#g666b97bf9ae5501aa0e296436f6dec7b">fc_subsetSegmentsSubset</a> (<a class="el" href="structFC__Subset.html">FC_Subset</a> subset_inner, <a class="el" href="structFC__Subset.html">FC_Subset</a> subset_outer, int shared_segdim, char *varname, int *numSubset, <a class="el" href="structFC__Subset.html">FC_Subset</a> **newSubsets)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns the segments (and their number) that result from segmenting a subset by another subset.  <a href="#g666b97bf9ae5501aa0e296436f6dec7b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DataTypes.html#g2a40aa471d085988d5b582669f766ce4">FC_ReturnCode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ElemDeath.html#ga5ee90cb8f509b4b15f6cdc8a029451a">fc_subsetPlusNeighborGreaterSegmentationMesh</a> (<a class="el" href="structFC__Subset.html">FC_Subset</a> subset, int shared_neighbordim, int shared_segdim, int *numNbr, int **nbrIDs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">given an input subset and parameters for specifying neghbors, returns IDs of neighbors for which adding any single one individually to the subset will result in a greater segmentation of the mesh than results from segmenting based on the orginal subset  <a href="#ga5ee90cb8f509b4b15f6cdc8a029451a"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Characterizations of Dead Element Regions</h2></td></tr>
<tr><td colspan="2"><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DataTypes.html#g2a40aa471d085988d5b582669f766ce4">FC_ReturnCode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ElemDeath.html#g653817d82355385af798c6639d07d6e5">fc_calcTearLength</a> (<a class="el" href="structFC__Subset.html">FC_Subset</a> subset, <a class="el" href="structFC__Subset.html">FC_Subset</a> *opt_meshSkin, <a class="el" href="structFC__Variable.html">FC_Variable</a> *displ_coords, double *length)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get tear length.  <a href="#g653817d82355385af798c6639d07d6e5"></a><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="g653817d82355385af798c6639d07d6e5"></a><!-- doxytag: member="elemdeath.c::fc_calcTearLength" ref="g653817d82355385af798c6639d07d6e5" args="(FC_Subset subset, FC_Subset *opt_meshSkin, FC_Variable *displ_coords, double *length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DataTypes.html#g2a40aa471d085988d5b582669f766ce4">FC_ReturnCode</a> fc_calcTearLength           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFC__Subset.html">FC_Subset</a>&nbsp;</td>
          <td class="paramname"> <em>subset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structFC__Subset.html">FC_Subset</a> *&nbsp;</td>
          <td class="paramname"> <em>opt_meshSkin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structFC__Variable.html">FC_Variable</a> *&nbsp;</td>
          <td class="paramname"> <em>displ_coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get tear length. 
<p>
<b>Description:</b> <p>
This function is just for convenience - it calls <a class="el" href="group__ElemDeath.html#g2d37a81b1e6240c627462e067ce4861a" title="Get exposed skin.">fc_getExposedSkin()</a> and then <a class="el" href="group__GeometricRelations.html#g00b83ac877266a548a15c1c4b884808a" title="Get the diameter of a subset.">fc_getSubsetDiameter()</a> (or <a class="el" href="group__GeometricRelations.html#gf65d48152257eb51fddb4c3ce3ec9957" title="Get the diameter of a displaced subset.">fc_getDisplacedSubsetDiameter()</a> if the displacement variable is provided).<p>
<dl compact><dt><b><a class="el" href="todo.html#_todo000010">Todo:</a></b></dt><dd>Unit test this.</dd></dl>
<b>Modifications:</b> <ul>
<li>7/6/2005 WSD. Created. </li></ul>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>subset</em>&nbsp;</td><td>
input - A subset of "dead" elements </td></tr>
<tr><td valign="top"><em>opt_meshSkin</em>&nbsp;</td><td>
input - (optional) pointer to mesh skin (or NULL) </td></tr>
<tr><td valign="top"><em>displ_coords</em>&nbsp;</td><td>
input - (optional) pointer to the owning mesh's coordinate displacements (or NULL) </td></tr>
<tr><td valign="top"><em>length</em>&nbsp;</td><td>
ouput - diameter of the vertex set </td></tr>
</table>
</dl>
<p>Definition at line <a class="el" href="elemdeath_8c-source.html#l01196">1196</a> of file <a class="el" href="elemdeath_8c-source.html">elemdeath.c</a>.</p>

<p>References <a class="el" href="subset_8c-source.html#l02482">fc_deleteSubset()</a>, <a class="el" href="geom_8c-source.html#l01790">fc_getDisplacedSubsetDiameter()</a>, <a class="el" href="elemdeath_8c-source.html#l00130">fc_getExposedSkin()</a>, <a class="el" href="geom_8c-source.html#l01753">fc_getSubsetDiameter()</a>, and <a class="el" href="base_8h-source.html#l00104">FC_SUCCESS</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l01203"></a>01203   {
<a name="l01204"></a>01204   <a class="code" href="group__DataTypes.html#g2a40aa471d085988d5b582669f766ce4" title="Possible function return values.">FC_ReturnCode</a> rc;
<a name="l01205"></a>01205   <a class="code" href="structFC__Subset.html" title="Subset Handle.">FC_Subset</a> exposed;
<a name="l01206"></a>01206   rc = <a class="code" href="group__ElemDeath.html#g2d37a81b1e6240c627462e067ce4861a" title="Get exposed skin.">fc_getExposedSkin</a>(subset, opt_meshSkin, &amp;exposed);
<a name="l01207"></a>01207   <span class="keywordflow">if</span> (rc != <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce46687acb19dbc2e15e6e89cdc39e8e18e">FC_SUCCESS</a>) {
<a name="l01208"></a>01208     *length = -1;
<a name="l01209"></a>01209     <span class="keywordflow">return</span> rc;
<a name="l01210"></a>01210   }
<a name="l01211"></a>01211   <span class="keywordflow">if</span> (displ_coords)
<a name="l01212"></a>01212     rc = <a class="code" href="group__GeometricRelations.html#gf65d48152257eb51fddb4c3ce3ec9957" title="Get the diameter of a displaced subset.">fc_getDisplacedSubsetDiameter</a>(exposed, *displ_coords, length, NULL,
<a name="l01213"></a>01213                            NULL);
<a name="l01214"></a>01214   <span class="keywordflow">else</span>
<a name="l01215"></a>01215     rc = <a class="code" href="group__GeometricRelations.html#g00b83ac877266a548a15c1c4b884808a" title="Get the diameter of a subset.">fc_getSubsetDiameter</a>(exposed, length, NULL, NULL);
<a name="l01216"></a>01216   <a class="code" href="group__Subset.html#g550d0636e4f35c29d6dbc427b3165a24" title="Delete a subset.">fc_deleteSubset</a>(exposed);
<a name="l01217"></a>01217   <span class="keywordflow">return</span> rc;
<a name="l01218"></a>01218 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="gccd459337d17ffd659545b5252ad569b"></a><!-- doxytag: member="elemdeath.c::fc_getDecayedShapeSides" ref="gccd459337d17ffd659545b5252ad569b" args="(FC_Subset deadregion, FC_Shape *shape, FC_Subset **decayedSides)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DataTypes.html#g2a40aa471d085988d5b582669f766ce4">FC_ReturnCode</a> fc_getDecayedShapeSides           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFC__Subset.html">FC_Subset</a>&nbsp;</td>
          <td class="paramname"> <em>deadregion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structFC__Shape.html">FC_Shape</a> *&nbsp;</td>
          <td class="paramname"> <em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structFC__Subset.html">FC_Subset</a> **&nbsp;</td>
          <td class="paramname"> <em>decayedSides</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the decayed item of each of a shapes sides. 
<p>
<b>Description:</b> <p>
Given a dead element region and a shape, returns an array of subsets, which is the intersection of the dead and the faces of each side. This is basically <a class="el" href="group__ElemDeath.html#gcf6293155cfec71e92d3ef592bcb4b51">fc_getDecayedSkin</a> called for each side in turn, so see the text there.<p>
If you want to get thsi information for a single side, call <a class="el" href="group__ElemDeath.html#gcf6293155cfec71e92d3ef592bcb4b51">fc_getDecayedSkin</a> and send it the single side face subset.<p>
If the inner calls fail for any of the sides, the whole thing fails.<p>
<b>Modifications:</b> <ul>
<li>03/02/2006 ACG fc_getDecayedSidesSegments created</li><li>07/16/2006 ACG This is born from fc_getDecayedSkinSegments, but without the segmenting. </li></ul>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>deadregion</em>&nbsp;</td><td>
input - dead region elements </td></tr>
<tr><td valign="top"><em>shape</em>&nbsp;</td><td>
input - shape </td></tr>
<tr><td valign="top"><em>decayedSides</em>&nbsp;</td><td>
output - decayedSkin subsets, one for each face </td></tr>
</table>
</dl>
<p>Definition at line <a class="el" href="elemdeath_8c-source.html#l00583">583</a> of file <a class="el" href="elemdeath_8c-source.html">elemdeath.c</a>.</p>

<p>References <a class="el" href="shape_8h-source.html#l00088">FC_Shape::faces</a>, <a class="el" href="subset_8c-source.html#l02482">fc_deleteSubset()</a>, <a class="el" href="elemdeath_8c-source.html#l00262">fc_getDecayedSkin()</a>, <a class="el" href="base_8c-source.html#l00355">fc_getReturnCodeText()</a>, <a class="el" href="base_8h-source.html#l00107">FC_INPUT_ERROR</a>, <a class="el" href="subset_8c-source.html#l02622">fc_isSubsetValid()</a>, <a class="el" href="base_8h-source.html#l00106">FC_MEMORY_ERROR</a>, <a class="el" href="library_8h-source.html#l00120">fc_printfErrorMessage</a>, <a class="el" href="base_8h-source.html#l00104">FC_SUCCESS</a>, and <a class="el" href="shape_8h-source.html#l00087">FC_Shape::numSides</a>.</p>

<p>Referenced by <a class="el" href="elemdeath_8c-source.html#l00499">fc_getDecayedShapeSkin()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00588"></a>00588    {
<a name="l00589"></a>00589   <a class="code" href="group__DataTypes.html#g2a40aa471d085988d5b582669f766ce4" title="Possible function return values.">FC_ReturnCode</a> rc;
<a name="l00590"></a>00590   <a class="code" href="structFC__Subset.html" title="Subset Handle.">FC_Subset</a> *sidesdecay;
<a name="l00591"></a>00591   <span class="keywordtype">int</span> i,j;
<a name="l00592"></a>00592 
<a name="l00593"></a>00593   <span class="comment">// default returns</span>
<a name="l00594"></a>00594   <span class="keywordflow">if</span> (decayedSides!= NULL)
<a name="l00595"></a>00595     *decayedSides = NULL;
<a name="l00596"></a>00596 
<a name="l00597"></a>00597   <span class="comment">// Test input. </span>
<a name="l00598"></a>00598   <span class="keywordflow">if</span> (!<a class="code" href="group__Subset.html#g63bf248cb60435e458ea038036d6af90" title="Check that the handle refers to a valid subset.">fc_isSubsetValid</a>(deadregion) || !shape || !shape-&gt;<a class="code" href="structFC__Shape.html#c9ea723452fe6cd941e3abb06ac4aee3">numSides</a> ||
<a name="l00599"></a>00599       !decayedSides){
<a name="l00600"></a>00600     <a class="code" href="group__Library.html#g1473e77471cd1319f76eb9a32e4ad91f" title="Print an error message to stderr.">fc_printfErrorMessage</a>(<span class="stringliteral">"%s"</span>, <a class="code" href="group__DataTypes.html#g510d74cc1e13d4cdc5bde247a25d48e4" title="Return the name of the FC_ReturnCode&amp;#39;s value.">fc_getReturnCodeText</a>(<a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce464a3d55131c355cdf036f95d0d7e1a6e">FC_INPUT_ERROR</a>));
<a name="l00601"></a>00601     <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce464a3d55131c355cdf036f95d0d7e1a6e">FC_INPUT_ERROR</a>;
<a name="l00602"></a>00602   }
<a name="l00603"></a>00603 
<a name="l00604"></a>00604   sidesdecay = (<a class="code" href="structFC__Subset.html" title="Subset Handle.">FC_Subset</a>*)malloc((shape-&gt;<a class="code" href="structFC__Shape.html#c9ea723452fe6cd941e3abb06ac4aee3">numSides</a>) * <span class="keyword">sizeof</span>(<a class="code" href="structFC__Subset.html" title="Subset Handle.">FC_Subset</a>));
<a name="l00605"></a>00605   <span class="keywordflow">if</span> (!sidesdecay){
<a name="l00606"></a>00606     <a class="code" href="group__Library.html#g1473e77471cd1319f76eb9a32e4ad91f" title="Print an error message to stderr.">fc_printfErrorMessage</a>(<span class="stringliteral">"%s"</span>, <a class="code" href="group__DataTypes.html#g510d74cc1e13d4cdc5bde247a25d48e4" title="Return the name of the FC_ReturnCode&amp;#39;s value.">fc_getReturnCodeText</a>(<a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce4db79475c8e6c2fcf3e4e7979a4139658">FC_MEMORY_ERROR</a>));
<a name="l00607"></a>00607     <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce4db79475c8e6c2fcf3e4e7979a4139658">FC_MEMORY_ERROR</a>;
<a name="l00608"></a>00608   }
<a name="l00609"></a>00609 
<a name="l00610"></a>00610   <span class="keywordflow">for</span> (i = 0; i &lt; shape-&gt;<a class="code" href="structFC__Shape.html#c9ea723452fe6cd941e3abb06ac4aee3">numSides</a>; i++){
<a name="l00611"></a>00611     rc = <a class="code" href="group__ElemDeath.html#gcf6293155cfec71e92d3ef592bcb4b51" title="Get decayed skin.">fc_getDecayedSkin</a>(deadregion,&amp;(shape-&gt;<a class="code" href="structFC__Shape.html#d3057d72e60c8f7f024bf3770a6d7c74">faces</a>[i]),&amp;sidesdecay[i]);
<a name="l00612"></a>00612     <span class="keywordflow">if</span> (rc != <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce46687acb19dbc2e15e6e89cdc39e8e18e">FC_SUCCESS</a>){
<a name="l00613"></a>00613       <a class="code" href="group__Library.html#g1473e77471cd1319f76eb9a32e4ad91f" title="Print an error message to stderr.">fc_printfErrorMessage</a>(<span class="stringliteral">"cant get decayedSkin of face %d"</span>,i);
<a name="l00614"></a>00614       <span class="keywordflow">for</span> (j = 0; j &lt; i; j++){
<a name="l00615"></a>00615      <a class="code" href="group__Subset.html#g550d0636e4f35c29d6dbc427b3165a24" title="Delete a subset.">fc_deleteSubset</a>(sidesdecay[j]);
<a name="l00616"></a>00616       }
<a name="l00617"></a>00617       free(sidesdecay);
<a name="l00618"></a>00618       <span class="keywordflow">return</span> rc;
<a name="l00619"></a>00619     }
<a name="l00620"></a>00620   }
<a name="l00621"></a>00621 
<a name="l00622"></a>00622   *decayedSides = sidesdecay;
<a name="l00623"></a>00623   <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce46687acb19dbc2e15e6e89cdc39e8e18e">FC_SUCCESS</a>;
<a name="l00624"></a>00624 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="gf43b12767fdb725a1f10e96c9b6d70d1"></a><!-- doxytag: member="elemdeath.c::fc_getDecayedShapeSkin" ref="gf43b12767fdb725a1f10e96c9b6d70d1" args="(FC_Subset deadregion, FC_Shape *shape, FC_Subset *decayedSkin)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DataTypes.html#g2a40aa471d085988d5b582669f766ce4">FC_ReturnCode</a> fc_getDecayedShapeSkin           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFC__Subset.html">FC_Subset</a>&nbsp;</td>
          <td class="paramname"> <em>deadregion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structFC__Shape.html">FC_Shape</a> *&nbsp;</td>
          <td class="paramname"> <em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structFC__Subset.html">FC_Subset</a> *&nbsp;</td>
          <td class="paramname"> <em>decayedSkin</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the decayed Skin. 
<p>
<b>Description:</b> <p>
Analogous method to <a class="el" href="group__ElemDeath.html#gcf6293155cfec71e92d3ef592bcb4b51">fc_getDecayedSkin</a> but where the meshskin is that defined by a shape. If you want the decay information on a side-by-side basis, use <a class="el" href="group__ElemDeath.html#gccd459337d17ffd659545b5252ad569b">fc_getDecayedShapeSides</a>.<p>
<b>Modifications:</b> <ul>
<li>07/16/2006 ACG created </li></ul>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>deadregion</em>&nbsp;</td><td>
input - dead region elements </td></tr>
<tr><td valign="top"><em>shape</em>&nbsp;</td><td>
input - ptr to shape </td></tr>
<tr><td valign="top"><em>decayedSkin</em>&nbsp;</td><td>
output - decayedSkin </td></tr>
</table>
</dl>
<p>Definition at line <a class="el" href="elemdeath_8c-source.html#l00499">499</a> of file <a class="el" href="elemdeath_8c-source.html">elemdeath.c</a>.</p>

<p>References <a class="el" href="subset_8c-source.html#l02064">fc_addArrayMembersToSubset()</a>, <a class="el" href="subset_8c-source.html#l02482">fc_deleteSubset()</a>, <a class="el" href="elemdeath_8c-source.html#l00583">fc_getDecayedShapeSides()</a>, <a class="el" href="base_8c-source.html#l00355">fc_getReturnCodeText()</a>, <a class="el" href="subset_8c-source.html#l03001">fc_getSubsetMembersAsArray()</a>, <a class="el" href="base_8h-source.html#l00319">FC_HANDLE_EQUIV</a>, <a class="el" href="base_8h-source.html#l00107">FC_INPUT_ERROR</a>, <a class="el" href="subset_8c-source.html#l02622">fc_isSubsetValid()</a>, <a class="el" href="base_8c-source.html#l00784">FC_NULL_SUBSET</a>, <a class="el" href="library_8h-source.html#l00120">fc_printfErrorMessage</a>, <a class="el" href="base_8h-source.html#l00104">FC_SUCCESS</a>, and <a class="el" href="shape_8h-source.html#l00087">FC_Shape::numSides</a>.</p>

<p>Referenced by <a class="el" href="tears_8c-source.html#l00686">calcShapeIntersection()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00503"></a>00503    {
<a name="l00504"></a>00504   <a class="code" href="group__DataTypes.html#g2a40aa471d085988d5b582669f766ce4" title="Possible function return values.">FC_ReturnCode</a> rc;
<a name="l00505"></a>00505   <a class="code" href="structFC__Subset.html" title="Subset Handle.">FC_Subset</a> *sidesdecay;
<a name="l00506"></a>00506   <span class="keywordtype">int</span> i,j;
<a name="l00507"></a>00507 
<a name="l00508"></a>00508   <span class="comment">// default returns</span>
<a name="l00509"></a>00509   <span class="keywordflow">if</span> (decayedSkin)
<a name="l00510"></a>00510     *decayedSkin = <a class="code" href="group__Handles.html#gd007f5eb6e7e7f2febca17b53420fd15" title="Null (default) subset handle.">FC_NULL_SUBSET</a>;
<a name="l00511"></a>00511 
<a name="l00512"></a>00512   <span class="comment">// Test input. </span>
<a name="l00513"></a>00513   <span class="keywordflow">if</span> (!<a class="code" href="group__Subset.html#g63bf248cb60435e458ea038036d6af90" title="Check that the handle refers to a valid subset.">fc_isSubsetValid</a>(deadregion) || !shape || !shape-&gt;<a class="code" href="structFC__Shape.html#c9ea723452fe6cd941e3abb06ac4aee3">numSides</a> ||
<a name="l00514"></a>00514       !decayedSkin){
<a name="l00515"></a>00515     <a class="code" href="group__Library.html#g1473e77471cd1319f76eb9a32e4ad91f" title="Print an error message to stderr.">fc_printfErrorMessage</a>(<span class="stringliteral">"%s"</span>, <a class="code" href="group__DataTypes.html#g510d74cc1e13d4cdc5bde247a25d48e4" title="Return the name of the FC_ReturnCode&amp;#39;s value.">fc_getReturnCodeText</a>(<a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce464a3d55131c355cdf036f95d0d7e1a6e">FC_INPUT_ERROR</a>));
<a name="l00516"></a>00516     <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce464a3d55131c355cdf036f95d0d7e1a6e">FC_INPUT_ERROR</a>;
<a name="l00517"></a>00517   }
<a name="l00518"></a>00518 
<a name="l00519"></a>00519   rc = <a class="code" href="group__ElemDeath.html#gccd459337d17ffd659545b5252ad569b" title="Get the decayed item of each of a shapes sides.">fc_getDecayedShapeSides</a>(deadregion,shape,&amp;sidesdecay);
<a name="l00520"></a>00520   <span class="keywordflow">if</span> (rc != <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce46687acb19dbc2e15e6e89cdc39e8e18e">FC_SUCCESS</a>){
<a name="l00521"></a>00521     <a class="code" href="group__Library.html#g1473e77471cd1319f76eb9a32e4ad91f" title="Print an error message to stderr.">fc_printfErrorMessage</a>(<span class="stringliteral">"cant get decayed shape skin"</span>);
<a name="l00522"></a>00522     <span class="keywordflow">return</span> rc;
<a name="l00523"></a>00523   }
<a name="l00524"></a>00524 
<a name="l00525"></a>00525 
<a name="l00526"></a>00526   <span class="keywordflow">for</span> (i = 1; i &lt; shape-&gt;<a class="code" href="structFC__Shape.html#c9ea723452fe6cd941e3abb06ac4aee3">numSides</a>; i++){
<a name="l00527"></a>00527     <span class="keywordtype">int</span> num, *arr;
<a name="l00528"></a>00528     <span class="keywordflow">if</span> (!<a class="code" href="group__Handles.html#g390004fca0870147d490f32c55afab8d" title="Check two handles for equality.">FC_HANDLE_EQUIV</a>(sidesdecay[i],<a class="code" href="group__Handles.html#gd007f5eb6e7e7f2febca17b53420fd15" title="Null (default) subset handle.">FC_NULL_SUBSET</a>)){
<a name="l00529"></a>00529       rc = <a class="code" href="group__Subset.html#g6cebfda6e20e2a518636838b170185da" title="Get a copy of subset members as array.">fc_getSubsetMembersAsArray</a>(sidesdecay[i],&amp;num,&amp;arr);
<a name="l00530"></a>00530       <span class="keywordflow">if</span> (rc != <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce46687acb19dbc2e15e6e89cdc39e8e18e">FC_SUCCESS</a>){
<a name="l00531"></a>00531      <a class="code" href="group__Library.html#g1473e77471cd1319f76eb9a32e4ad91f" title="Print an error message to stderr.">fc_printfErrorMessage</a>(<span class="stringliteral">"cant get subset members as array"</span>);
<a name="l00532"></a>00532      <a class="code" href="group__Subset.html#g550d0636e4f35c29d6dbc427b3165a24" title="Delete a subset.">fc_deleteSubset</a>(sidesdecay[0]);
<a name="l00533"></a>00533      <span class="keywordflow">for</span> (j = i; j &lt; shape-&gt;<a class="code" href="structFC__Shape.html#c9ea723452fe6cd941e3abb06ac4aee3">numSides</a>; j++){
<a name="l00534"></a>00534        <a class="code" href="group__Subset.html#g550d0636e4f35c29d6dbc427b3165a24" title="Delete a subset.">fc_deleteSubset</a>(sidesdecay[j]);
<a name="l00535"></a>00535      }
<a name="l00536"></a>00536      free(sidesdecay);
<a name="l00537"></a>00537      <span class="keywordflow">return</span> rc;
<a name="l00538"></a>00538       }
<a name="l00539"></a>00539       rc = <a class="code" href="group__Subset.html#g123bb2337bd35a1915aa736270ed3d40" title="Add members from an array to a subset.">fc_addArrayMembersToSubset</a>(sidesdecay[0],num,arr);
<a name="l00540"></a>00540       free(arr);
<a name="l00541"></a>00541       <span class="keywordflow">if</span> (rc != <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce46687acb19dbc2e15e6e89cdc39e8e18e">FC_SUCCESS</a>){
<a name="l00542"></a>00542      <a class="code" href="group__Library.html#g1473e77471cd1319f76eb9a32e4ad91f" title="Print an error message to stderr.">fc_printfErrorMessage</a>(<span class="stringliteral">"cant add aray members to subset"</span>);
<a name="l00543"></a>00543      <a class="code" href="group__Subset.html#g550d0636e4f35c29d6dbc427b3165a24" title="Delete a subset.">fc_deleteSubset</a>(sidesdecay[0]);
<a name="l00544"></a>00544      <span class="keywordflow">for</span> (j = i; j &lt; shape-&gt;<a class="code" href="structFC__Shape.html#c9ea723452fe6cd941e3abb06ac4aee3">numSides</a>; j++){
<a name="l00545"></a>00545        <a class="code" href="group__Subset.html#g550d0636e4f35c29d6dbc427b3165a24" title="Delete a subset.">fc_deleteSubset</a>(sidesdecay[j]);
<a name="l00546"></a>00546      }
<a name="l00547"></a>00547      free(sidesdecay);
<a name="l00548"></a>00548      <span class="keywordflow">return</span> rc;
<a name="l00549"></a>00549       }
<a name="l00550"></a>00550     }
<a name="l00551"></a>00551   }
<a name="l00552"></a>00552 
<a name="l00553"></a>00553   *decayedSkin = sidesdecay[0];
<a name="l00554"></a>00554   free(sidesdecay);
<a name="l00555"></a>00555   <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce46687acb19dbc2e15e6e89cdc39e8e18e">FC_SUCCESS</a>;
<a name="l00556"></a>00556 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="gcf6293155cfec71e92d3ef592bcb4b51"></a><!-- doxytag: member="elemdeath.c::fc_getDecayedSkin" ref="gcf6293155cfec71e92d3ef592bcb4b51" args="(FC_Subset deadregion, FC_Subset *opt_meshSkin, FC_Subset *decayedSkin)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DataTypes.html#g2a40aa471d085988d5b582669f766ce4">FC_ReturnCode</a> fc_getDecayedSkin           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFC__Subset.html">FC_Subset</a>&nbsp;</td>
          <td class="paramname"> <em>deadregion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structFC__Subset.html">FC_Subset</a> *&nbsp;</td>
          <td class="paramname"> <em>opt_meshSkin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structFC__Subset.html">FC_Subset</a> *&nbsp;</td>
          <td class="paramname"> <em>decayedSkin</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get decayed skin. 
<p>
<b>Description:</b> <p>
Given a dead element region and the skin of a mesh or subset, returns a subset which is the intersection of the dead element region and the skin, referred to as the "decayedSkin". The return subset is named "DecayedSkin".<p>
The dead region must have association FC_AT_ELEMENT, the skin must have association FC_AT_FACE, and the return subset has the assocation FC_AT_FACE. Both input subsets must be on the same mesh. If you want the elements of the decayed face, call <a class="el" href="group__Subset.html#gebbcc05ef1a5287612b7767903e69b68">fc_createSubsetIntersection</a> directly on the dead region and subset giving rise to the input skin.<p>
This method does not check that the initial subsets actually describe a dead region and a skin, so this can in fact be used to calculate the intersection of any element subset and some other skin. It is being placed in elemdeath however, because this function was developed for a specific dead element need and and using the deadelement terminology in this function name is beneficial.<p>
Notes:<ul>
<li>if the deadregion is NULL or the input skin is empty, returns with error (this is to be consistent with <a class="el" href="group__ElemDeath.html#g2d37a81b1e6240c627462e067ce4861a">fc_getExposedSkin</a>)</li><li>if the input skin is NULL, it creates the mesh skin</li><li>if the dead region is empty, returns empty subset.</li><li>if there are no intersections, returns a subset with no members.</li></ul>
<p>
<b>Modifications:</b> <ul>
<li>11/30/2005 ACG Created via moving here from surface demo code.</li><li>12/05/2005 ACG Added the unittest (see todo above).</li><li>03/01/2006 ACG added explicit type checking for hte input subsets</li><li>03/02/2006 ACG changing name for DecayedMeshSkin to DecayedSkin since the skin doesnt have to be a meshskin</li><li>07/16/2006 ACG This was fc_getDecayedSkinSegments, but removing the segmenting </li></ul>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>deadregion</em>&nbsp;</td><td>
input - dead region elements </td></tr>
<tr><td valign="top"><em>opt_meshSkin</em>&nbsp;</td><td>
input - optional ptr to mesh skin or NULL </td></tr>
<tr><td valign="top"><em>decayedSkin</em>&nbsp;</td><td>
output - skin items ids comprising the dead skin (not segmented) </td></tr>
</table>
</dl>
<p>Definition at line <a class="el" href="elemdeath_8c-source.html#l00262">262</a> of file <a class="el" href="elemdeath_8c-source.html">elemdeath.c</a>.</p>

<p>References <a class="el" href="base_8h-source.html#l00196">FC_AT_ELEMENT</a>, <a class="el" href="base_8h-source.html#l00194">FC_AT_FACE</a>, <a class="el" href="subset_8c-source.html#l01040">fc_createSubsetIntersection()</a>, <a class="el" href="subset_8c-source.html#l02482">fc_deleteSubset()</a>, <a class="el" href="subset_8c-source.html#l02741">fc_getMeshFromSubset()</a>, <a class="el" href="topo_8c-source.html#l01792">fc_getMeshSkin()</a>, <a class="el" href="base_8c-source.html#l00355">fc_getReturnCodeText()</a>, <a class="el" href="subset_8c-source.html#l02782">fc_getSubsetInfo()</a>, <a class="el" href="topo_8c-source.html#l01645">fc_getSubsetSkin()</a>, <a class="el" href="base_8h-source.html#l00319">FC_HANDLE_EQUIV</a>, <a class="el" href="base_8h-source.html#l00107">FC_INPUT_ERROR</a>, <a class="el" href="subset_8c-source.html#l02622">fc_isSubsetValid()</a>, <a class="el" href="base_8c-source.html#l00784">FC_NULL_SUBSET</a>, <a class="el" href="library_8h-source.html#l00120">fc_printfErrorMessage</a>, <a class="el" href="library_8h-source.html#l00188">fc_printfLogMessage</a>, and <a class="el" href="base_8h-source.html#l00104">FC_SUCCESS</a>.</p>

<p>Referenced by <a class="el" href="elemdeath_8c-source.html#l00583">fc_getDecayedShapeSides()</a>, <a class="el" href="elemdeath__ex1_8c-source.html#l00147">main()</a>, and <a class="el" href="screwBreaks_8c-source.html#l00617">projection()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00266"></a>00266    {
<a name="l00267"></a>00267   <a class="code" href="group__DataTypes.html#g2a40aa471d085988d5b582669f766ce4" title="Possible function return values.">FC_ReturnCode</a> rc;
<a name="l00268"></a>00268   <a class="code" href="structFC__Mesh.html" title="Mesh Handle.">FC_Mesh</a> mesh1, mesh2;
<a name="l00269"></a>00269   <a class="code" href="structFC__Subset.html" title="Subset Handle.">FC_Subset</a> deadregionskin,meshskin,createmeshskin,deadfaces;
<a name="l00270"></a>00270   <a class="code" href="group__DataTypes.html#g28b7cdba59395ddc988888d01dd19af6" title="Possible association of the data to the mesh.">FC_AssociationType</a> assocdead, assocskin;
<a name="l00271"></a>00271   <span class="keywordtype">int</span> n_dead, n_skin;
<a name="l00272"></a>00272   <span class="keywordtype">int</span> junk;
<a name="l00273"></a>00273 
<a name="l00274"></a>00274 
<a name="l00275"></a>00275   <span class="comment">// default returns</span>
<a name="l00276"></a>00276   <span class="keywordflow">if</span> (decayedSkin)
<a name="l00277"></a>00277     *decayedSkin = <a class="code" href="group__Handles.html#gd007f5eb6e7e7f2febca17b53420fd15" title="Null (default) subset handle.">FC_NULL_SUBSET</a>;
<a name="l00278"></a>00278 
<a name="l00279"></a>00279   <span class="comment">// Test input. </span>
<a name="l00280"></a>00280   <span class="keywordflow">if</span> (!<a class="code" href="group__Subset.html#g63bf248cb60435e458ea038036d6af90" title="Check that the handle refers to a valid subset.">fc_isSubsetValid</a>(deadregion) || !decayedSkin ||
<a name="l00281"></a>00281       (opt_meshSkin != NULL &amp;&amp; !<a class="code" href="group__Subset.html#g63bf248cb60435e458ea038036d6af90" title="Check that the handle refers to a valid subset.">fc_isSubsetValid</a>(*opt_meshSkin))){
<a name="l00282"></a>00282     <a class="code" href="group__Library.html#g1473e77471cd1319f76eb9a32e4ad91f" title="Print an error message to stderr.">fc_printfErrorMessage</a>(<span class="stringliteral">"%s"</span>, <a class="code" href="group__DataTypes.html#g510d74cc1e13d4cdc5bde247a25d48e4" title="Return the name of the FC_ReturnCode&amp;#39;s value.">fc_getReturnCodeText</a>(<a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce464a3d55131c355cdf036f95d0d7e1a6e">FC_INPUT_ERROR</a>));
<a name="l00283"></a>00283     <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce464a3d55131c355cdf036f95d0d7e1a6e">FC_INPUT_ERROR</a>;
<a name="l00284"></a>00284   }
<a name="l00285"></a>00285 
<a name="l00286"></a>00286   rc = <a class="code" href="group__Subset.html#g815857d0e2d573d0418a3892229c0d83" title="Get information about a subset.">fc_getSubsetInfo</a>(deadregion,&amp;n_dead,&amp;junk,&amp;assocdead);
<a name="l00287"></a>00287   <span class="keywordflow">if</span> (rc != <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce46687acb19dbc2e15e6e89cdc39e8e18e">FC_SUCCESS</a>){
<a name="l00288"></a>00288     <a class="code" href="group__Library.html#g1473e77471cd1319f76eb9a32e4ad91f" title="Print an error message to stderr.">fc_printfErrorMessage</a>(<span class="stringliteral">"cant get info of dead region"</span>);    
<a name="l00289"></a>00289     <span class="keywordflow">return</span> rc;
<a name="l00290"></a>00290   }
<a name="l00291"></a>00291 
<a name="l00292"></a>00292   <span class="keywordflow">if</span> (assocdead != <a class="code" href="group__DataTypes.html#gg28b7cdba59395ddc988888d01dd19af690a2a90b49747de25e69b3bfdad27f4a">FC_AT_ELEMENT</a>){
<a name="l00293"></a>00293     <a class="code" href="group__Library.html#g1473e77471cd1319f76eb9a32e4ad91f" title="Print an error message to stderr.">fc_printfErrorMessage</a>(<span class="stringliteral">"deadregion must have element assoc"</span>);
<a name="l00294"></a>00294     <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce464a3d55131c355cdf036f95d0d7e1a6e">FC_INPUT_ERROR</a>;
<a name="l00295"></a>00295   }
<a name="l00296"></a>00296   rc = <a class="code" href="group__Subset.html#gddbb3a2f8c43289a3c3754f1546462bc" title="Get the parent mesh of the subset.">fc_getMeshFromSubset</a>(deadregion,&amp;mesh1);
<a name="l00297"></a>00297   <span class="keywordflow">if</span> (rc != <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce46687acb19dbc2e15e6e89cdc39e8e18e">FC_SUCCESS</a>)
<a name="l00298"></a>00298     <span class="keywordflow">return</span> rc;
<a name="l00299"></a>00299   <span class="keywordflow">if</span> (opt_meshSkin) {
<a name="l00300"></a>00300     rc = <a class="code" href="group__Subset.html#gddbb3a2f8c43289a3c3754f1546462bc" title="Get the parent mesh of the subset.">fc_getMeshFromSubset</a>(*opt_meshSkin, &amp;mesh2);
<a name="l00301"></a>00301     <span class="keywordflow">if</span> (rc != <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce46687acb19dbc2e15e6e89cdc39e8e18e">FC_SUCCESS</a>)
<a name="l00302"></a>00302       <span class="keywordflow">return</span> rc;
<a name="l00303"></a>00303     <span class="keywordflow">if</span> (!<a class="code" href="group__Handles.html#g390004fca0870147d490f32c55afab8d" title="Check two handles for equality.">FC_HANDLE_EQUIV</a>(mesh1, mesh2)) {
<a name="l00304"></a>00304       <a class="code" href="group__Library.html#g1473e77471cd1319f76eb9a32e4ad91f" title="Print an error message to stderr.">fc_printfErrorMessage</a>(<span class="stringliteral">"deadregion and skin must be on the same mesh"</span>);
<a name="l00305"></a>00305       <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce464a3d55131c355cdf036f95d0d7e1a6e">FC_INPUT_ERROR</a>;
<a name="l00306"></a>00306     }
<a name="l00307"></a>00307   }
<a name="l00308"></a>00308 
<a name="l00309"></a>00309   createmeshskin = <a class="code" href="group__Handles.html#gd007f5eb6e7e7f2febca17b53420fd15" title="Null (default) subset handle.">FC_NULL_SUBSET</a>;
<a name="l00310"></a>00310   <span class="keywordflow">if</span> (opt_meshSkin){
<a name="l00311"></a>00311     meshskin = *opt_meshSkin;
<a name="l00312"></a>00312   } <span class="keywordflow">else</span> {
<a name="l00313"></a>00313     rc = <a class="code" href="group__TopologyRelations.html#gc9cf699133b0d472adf19df31c8ce3bf" title="Create skin of the mesh.">fc_getMeshSkin</a>(mesh1, &amp;createmeshskin);
<a name="l00314"></a>00314     <span class="keywordflow">if</span> (rc != <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce46687acb19dbc2e15e6e89cdc39e8e18e">FC_SUCCESS</a>)
<a name="l00315"></a>00315       <span class="keywordflow">return</span> rc;
<a name="l00316"></a>00316     meshskin = createmeshskin;
<a name="l00317"></a>00317   }
<a name="l00318"></a>00318   rc = <a class="code" href="group__Subset.html#g815857d0e2d573d0418a3892229c0d83" title="Get information about a subset.">fc_getSubsetInfo</a>(meshskin,&amp;n_skin,&amp;junk,&amp;assocskin);
<a name="l00319"></a>00319   <span class="keywordflow">if</span> (rc != <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce46687acb19dbc2e15e6e89cdc39e8e18e">FC_SUCCESS</a>){
<a name="l00320"></a>00320     <a class="code" href="group__Library.html#g1473e77471cd1319f76eb9a32e4ad91f" title="Print an error message to stderr.">fc_printfErrorMessage</a>(<span class="stringliteral">"cant get info of skin"</span>);    
<a name="l00321"></a>00321     <a class="code" href="group__Subset.html#g550d0636e4f35c29d6dbc427b3165a24" title="Delete a subset.">fc_deleteSubset</a>(createmeshskin);
<a name="l00322"></a>00322     <span class="keywordflow">return</span> rc;
<a name="l00323"></a>00323   }
<a name="l00324"></a>00324   <span class="keywordflow">if</span> (assocskin != <a class="code" href="group__DataTypes.html#gg28b7cdba59395ddc988888d01dd19af640a4ba10b4045dfe3aef0e0c0588cbd0">FC_AT_FACE</a>){
<a name="l00325"></a>00325     <a class="code" href="group__Library.html#g1473e77471cd1319f76eb9a32e4ad91f" title="Print an error message to stderr.">fc_printfErrorMessage</a>(<span class="stringliteral">"skin must have face assoc"</span>);
<a name="l00326"></a>00326     <a class="code" href="group__Subset.html#g550d0636e4f35c29d6dbc427b3165a24" title="Delete a subset.">fc_deleteSubset</a>(createmeshskin);
<a name="l00327"></a>00327     <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce464a3d55131c355cdf036f95d0d7e1a6e">FC_INPUT_ERROR</a>;
<a name="l00328"></a>00328   }
<a name="l00329"></a>00329   <span class="comment">//have to check if the skin is empty before checking if the dead set is</span>
<a name="l00330"></a>00330   <span class="keywordflow">if</span> (n_skin == 0){
<a name="l00331"></a>00331     <a class="code" href="group__Library.html#g1473e77471cd1319f76eb9a32e4ad91f" title="Print an error message to stderr.">fc_printfErrorMessage</a>(<span class="stringliteral">"cant work on an empty skin"</span>);
<a name="l00332"></a>00332     <a class="code" href="group__Subset.html#g550d0636e4f35c29d6dbc427b3165a24" title="Delete a subset.">fc_deleteSubset</a>(createmeshskin);
<a name="l00333"></a>00333     <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce464a3d55131c355cdf036f95d0d7e1a6e">FC_INPUT_ERROR</a>;
<a name="l00334"></a>00334   }
<a name="l00335"></a>00335   <span class="keywordflow">if</span> (n_dead == 0){
<a name="l00336"></a>00336     <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce46687acb19dbc2e15e6e89cdc39e8e18e">FC_SUCCESS</a>;
<a name="l00337"></a>00337   }
<a name="l00338"></a>00338 
<a name="l00339"></a>00339   <a class="code" href="group__Library.html#g7e9664a8765cc08c313df880421c496b" title="Print a log message to stdout.">fc_printfLogMessage</a>(<span class="stringliteral">"get decayed skin "</span>);
<a name="l00340"></a>00340 
<a name="l00341"></a>00341   <span class="comment">//get the skin of the dead region</span>
<a name="l00342"></a>00342   rc = <a class="code" href="group__TopologyRelations.html#gba256da3e22e892863b569dbfcdcabf5" title="Create a skin of the subset.">fc_getSubsetSkin</a>(deadregion,&amp;deadregionskin);
<a name="l00343"></a>00343   <span class="keywordflow">if</span> (rc != <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce46687acb19dbc2e15e6e89cdc39e8e18e">FC_SUCCESS</a>){
<a name="l00344"></a>00344     <a class="code" href="group__Subset.html#g550d0636e4f35c29d6dbc427b3165a24" title="Delete a subset.">fc_deleteSubset</a>(createmeshskin);
<a name="l00345"></a>00345     <a class="code" href="group__Library.html#g1473e77471cd1319f76eb9a32e4ad91f" title="Print an error message to stderr.">fc_printfErrorMessage</a>(<span class="stringliteral">"cant get dead region skin"</span>);
<a name="l00346"></a>00346     <span class="keywordflow">return</span> rc;
<a name="l00347"></a>00347   } 
<a name="l00348"></a>00348   
<a name="l00349"></a>00349   <span class="comment">//intersect to get the dead faces</span>
<a name="l00350"></a>00350   rc = <a class="code" href="group__Subset.html#gebbcc05ef1a5287612b7767903e69b68" title="Create subset based on intersection of two input subsets.">fc_createSubsetIntersection</a>(deadregionskin,<span class="stringliteral">"AND"</span>,meshskin,
<a name="l00351"></a>00351                        <span class="stringliteral">"DeadSkin"</span>,&amp;deadfaces);
<a name="l00352"></a>00352   <a class="code" href="group__Subset.html#g550d0636e4f35c29d6dbc427b3165a24" title="Delete a subset.">fc_deleteSubset</a>(deadregionskin);
<a name="l00353"></a>00353   <a class="code" href="group__Subset.html#g550d0636e4f35c29d6dbc427b3165a24" title="Delete a subset.">fc_deleteSubset</a>(createmeshskin);
<a name="l00354"></a>00354   <span class="keywordflow">if</span> (rc != <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce46687acb19dbc2e15e6e89cdc39e8e18e">FC_SUCCESS</a>){
<a name="l00355"></a>00355     <a class="code" href="group__Library.html#g1473e77471cd1319f76eb9a32e4ad91f" title="Print an error message to stderr.">fc_printfErrorMessage</a>(<span class="stringliteral">"cant get dead mesh faces"</span>);
<a name="l00356"></a>00356     <span class="keywordflow">return</span> rc;
<a name="l00357"></a>00357   } 
<a name="l00358"></a>00358 
<a name="l00359"></a>00359   *decayedSkin = deadfaces;
<a name="l00360"></a>00360 
<a name="l00361"></a>00361   <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce46687acb19dbc2e15e6e89cdc39e8e18e">FC_SUCCESS</a>;
<a name="l00362"></a>00362 };
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="g2d37a81b1e6240c627462e067ce4861a"></a><!-- doxytag: member="elemdeath.c::fc_getExposedSkin" ref="g2d37a81b1e6240c627462e067ce4861a" args="(FC_Subset subset, FC_Subset *opt_meshSkin, FC_Subset *exposed)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DataTypes.html#g2a40aa471d085988d5b582669f766ce4">FC_ReturnCode</a> fc_getExposedSkin           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFC__Subset.html">FC_Subset</a>&nbsp;</td>
          <td class="paramname"> <em>subset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structFC__Subset.html">FC_Subset</a> *&nbsp;</td>
          <td class="paramname"> <em>opt_meshSkin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structFC__Subset.html">FC_Subset</a> *&nbsp;</td>
          <td class="paramname"> <em>exposed</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get exposed skin. 
<p>
<b>Description:</b> <p>
Given a subset of elements, this routine returns a subset of the entities that would become "exposed" (i.e. become part of the mesh skin) if the given elements were removed from the parent mesh. The exposed skin is the boundary between the dead region and the rest of the mesh. It is useful as a subset of the dead region because all members are still "real" unlike entities that are totally within a dead region which may no longer have physical meaning.<p>
Since calculating the skin of the parent mesh can be very computationally expension, there is an optional argument to pass in an already computed mesh skin.<p>
If there are no exposed entities, this routine returns successfully but with FC_NULL_SUBSET (instead of a subset with no members).<p>
This function will fail if there are no members in the input subset.<p>
<b>Modifications:</b> <ul>
<li>6/27/2005 WSD. Created. </li></ul>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>subset</em>&nbsp;</td><td>
input - A subset of "dead" elements </td></tr>
<tr><td valign="top"><em>opt_meshSkin</em>&nbsp;</td><td>
input - (optional) pointer to mesh skin (or NULL) </td></tr>
<tr><td valign="top"><em>exposed</em>&nbsp;</td><td>
output - The exposed skin </td></tr>
</table>
</dl>
<p>Definition at line <a class="el" href="elemdeath_8c-source.html#l00130">130</a> of file <a class="el" href="elemdeath_8c-source.html">elemdeath.c</a>.</p>

<p>References <a class="el" href="base_8h-source.html#l00196">FC_AT_ELEMENT</a>, <a class="el" href="base_8h-source.html#l00197">FC_AT_WHOLE_MESH</a>, <a class="el" href="subset_8c-source.html#l01040">fc_createSubsetIntersection()</a>, <a class="el" href="subset_8c-source.html#l02482">fc_deleteSubset()</a>, <a class="el" href="subset_8c-source.html#l02741">fc_getMeshFromSubset()</a>, <a class="el" href="topo_8c-source.html#l01792">fc_getMeshSkin()</a>, <a class="el" href="base_8c-source.html#l00355">fc_getReturnCodeText()</a>, <a class="el" href="subset_8c-source.html#l02782">fc_getSubsetInfo()</a>, <a class="el" href="topo_8c-source.html#l01645">fc_getSubsetSkin()</a>, <a class="el" href="base_8h-source.html#l00319">FC_HANDLE_EQUIV</a>, <a class="el" href="base_8h-source.html#l00107">FC_INPUT_ERROR</a>, <a class="el" href="subset_8c-source.html#l02622">fc_isSubsetValid()</a>, <a class="el" href="base_8c-source.html#l00784">FC_NULL_SUBSET</a>, <a class="el" href="library_8h-source.html#l00120">fc_printfErrorMessage</a>, and <a class="el" href="base_8h-source.html#l00104">FC_SUCCESS</a>.</p>

<p>Referenced by <a class="el" href="elemdeath_8c-source.html#l01196">fc_calcTearLength()</a>, and <a class="el" href="tears_8c-source.html#l00922">main()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00135"></a>00135   {
<a name="l00136"></a>00136   <a class="code" href="group__DataTypes.html#g2a40aa471d085988d5b582669f766ce4" title="Possible function return values.">FC_ReturnCode</a> rc;
<a name="l00137"></a>00137   <a class="code" href="group__DataTypes.html#g28b7cdba59395ddc988888d01dd19af6" title="Possible association of the data to the mesh.">FC_AssociationType</a> in_assoc;
<a name="l00138"></a>00138   <span class="keywordtype">int</span> numMember, maxNumMember;
<a name="l00139"></a>00139   <a class="code" href="structFC__Mesh.html" title="Mesh Handle.">FC_Mesh</a> mesh, temp_mesh;
<a name="l00140"></a>00140   <a class="code" href="structFC__Subset.html" title="Subset Handle.">FC_Subset</a> mesh_skin, subset_skin, union_subset;
<a name="l00141"></a>00141   
<a name="l00142"></a>00142   <span class="comment">// default returns</span>
<a name="l00143"></a>00143   <span class="keywordflow">if</span> (exposed)
<a name="l00144"></a>00144     *exposed = <a class="code" href="group__Handles.html#gd007f5eb6e7e7f2febca17b53420fd15" title="Null (default) subset handle.">FC_NULL_SUBSET</a>;
<a name="l00145"></a>00145 
<a name="l00146"></a>00146   <span class="comment">// Test input</span>
<a name="l00147"></a>00147   <span class="keywordflow">if</span> (!<a class="code" href="group__Subset.html#g63bf248cb60435e458ea038036d6af90" title="Check that the handle refers to a valid subset.">fc_isSubsetValid</a>(subset) || !exposed ||
<a name="l00148"></a>00148       (opt_meshSkin != NULL &amp;&amp; !<a class="code" href="group__Subset.html#g63bf248cb60435e458ea038036d6af90" title="Check that the handle refers to a valid subset.">fc_isSubsetValid</a>(*opt_meshSkin))) {
<a name="l00149"></a>00149     <a class="code" href="group__Library.html#g1473e77471cd1319f76eb9a32e4ad91f" title="Print an error message to stderr.">fc_printfErrorMessage</a>(<span class="stringliteral">"%s"</span>, <a class="code" href="group__DataTypes.html#g510d74cc1e13d4cdc5bde247a25d48e4" title="Return the name of the FC_ReturnCode&amp;#39;s value.">fc_getReturnCodeText</a>(<a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce464a3d55131c355cdf036f95d0d7e1a6e">FC_INPUT_ERROR</a>));
<a name="l00150"></a>00150     <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce464a3d55131c355cdf036f95d0d7e1a6e">FC_INPUT_ERROR</a>;
<a name="l00151"></a>00151   }
<a name="l00152"></a>00152   rc = <a class="code" href="group__Subset.html#g815857d0e2d573d0418a3892229c0d83" title="Get information about a subset.">fc_getSubsetInfo</a>(subset, &amp;numMember, &amp;maxNumMember, &amp;in_assoc);
<a name="l00153"></a>00153   <span class="keywordflow">if</span> (rc != <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce46687acb19dbc2e15e6e89cdc39e8e18e">FC_SUCCESS</a>)
<a name="l00154"></a>00154     <span class="keywordflow">return</span> rc;
<a name="l00155"></a>00155   <span class="keywordflow">if</span> (in_assoc != <a class="code" href="group__DataTypes.html#gg28b7cdba59395ddc988888d01dd19af690a2a90b49747de25e69b3bfdad27f4a">FC_AT_ELEMENT</a> &amp;&amp; in_assoc != <a class="code" href="group__DataTypes.html#gg28b7cdba59395ddc988888d01dd19af62b7e38452f200e9abd5767534b43d670">FC_AT_WHOLE_MESH</a>) {
<a name="l00156"></a>00156     <a class="code" href="group__Library.html#g1473e77471cd1319f76eb9a32e4ad91f" title="Print an error message to stderr.">fc_printfErrorMessage</a>(<span class="stringliteral">"Subset must have element or whole association"</span>);
<a name="l00157"></a>00157     <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce464a3d55131c355cdf036f95d0d7e1a6e">FC_INPUT_ERROR</a>;
<a name="l00158"></a>00158   }
<a name="l00159"></a>00159 
<a name="l00160"></a>00160   <span class="comment">// A little setup and more testing</span>
<a name="l00161"></a>00161   rc = <a class="code" href="group__Subset.html#gddbb3a2f8c43289a3c3754f1546462bc" title="Get the parent mesh of the subset.">fc_getMeshFromSubset</a>(subset, &amp;mesh);
<a name="l00162"></a>00162   <span class="keywordflow">if</span> (rc != <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce46687acb19dbc2e15e6e89cdc39e8e18e">FC_SUCCESS</a>)
<a name="l00163"></a>00163     <span class="keywordflow">return</span> rc;
<a name="l00164"></a>00164   <span class="keywordflow">if</span> (opt_meshSkin) {
<a name="l00165"></a>00165     rc = <a class="code" href="group__Subset.html#gddbb3a2f8c43289a3c3754f1546462bc" title="Get the parent mesh of the subset.">fc_getMeshFromSubset</a>(*opt_meshSkin, &amp;temp_mesh);
<a name="l00166"></a>00166     <span class="keywordflow">if</span> (rc != <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce46687acb19dbc2e15e6e89cdc39e8e18e">FC_SUCCESS</a>)
<a name="l00167"></a>00167       <span class="keywordflow">return</span> rc;
<a name="l00168"></a>00168     <span class="keywordflow">if</span> (!<a class="code" href="group__Handles.html#g390004fca0870147d490f32c55afab8d" title="Check two handles for equality.">FC_HANDLE_EQUIV</a>(mesh, temp_mesh)) {
<a name="l00169"></a>00169       <a class="code" href="group__Library.html#g1473e77471cd1319f76eb9a32e4ad91f" title="Print an error message to stderr.">fc_printfErrorMessage</a>(<span class="stringliteral">"Subset and mesh sking must be on the same mesh"</span>);
<a name="l00170"></a>00170       <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce464a3d55131c355cdf036f95d0d7e1a6e">FC_INPUT_ERROR</a>;
<a name="l00171"></a>00171     }
<a name="l00172"></a>00172   }
<a name="l00173"></a>00173 
<a name="l00174"></a>00174   <span class="comment">// Error case - No dead elements // FIX? is this really an error?</span>
<a name="l00175"></a>00175   <span class="keywordflow">if</span> (numMember == 0) {
<a name="l00176"></a>00176     <a class="code" href="group__Library.html#g1473e77471cd1319f76eb9a32e4ad91f" title="Print an error message to stderr.">fc_printfErrorMessage</a>(<span class="stringliteral">"Cannot handle empty subset"</span>);
<a name="l00177"></a>00177     <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce464a3d55131c355cdf036f95d0d7e1a6e">FC_INPUT_ERROR</a>;
<a name="l00178"></a>00178   }
<a name="l00179"></a>00179     
<a name="l00180"></a>00180   <span class="comment">// Special case - all elements are dead</span>
<a name="l00181"></a>00181   <span class="keywordflow">if</span> (in_assoc == <a class="code" href="group__DataTypes.html#gg28b7cdba59395ddc988888d01dd19af62b7e38452f200e9abd5767534b43d670">FC_AT_WHOLE_MESH</a> ||  numMember == maxNumMember) {
<a name="l00182"></a>00182     <span class="comment">// return NULL handle</span>
<a name="l00183"></a>00183     <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce46687acb19dbc2e15e6e89cdc39e8e18e">FC_SUCCESS</a>;
<a name="l00184"></a>00184   }
<a name="l00185"></a>00185 
<a name="l00186"></a>00186   <span class="comment">// Setup - get the skin's of the mesh and the subset</span>
<a name="l00187"></a>00187   <span class="keywordflow">if</span> (opt_meshSkin)
<a name="l00188"></a>00188     mesh_skin = *opt_meshSkin;
<a name="l00189"></a>00189   <span class="keywordflow">else</span> {
<a name="l00190"></a>00190     rc = <a class="code" href="group__TopologyRelations.html#gc9cf699133b0d472adf19df31c8ce3bf" title="Create skin of the mesh.">fc_getMeshSkin</a>(mesh, &amp;mesh_skin);
<a name="l00191"></a>00191     <span class="keywordflow">if</span> (rc != <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce46687acb19dbc2e15e6e89cdc39e8e18e">FC_SUCCESS</a>)
<a name="l00192"></a>00192       <span class="keywordflow">return</span> rc;
<a name="l00193"></a>00193   }
<a name="l00194"></a>00194   rc = <a class="code" href="group__TopologyRelations.html#gba256da3e22e892863b569dbfcdcabf5" title="Create a skin of the subset.">fc_getSubsetSkin</a>(subset, &amp;subset_skin);
<a name="l00195"></a>00195   <span class="keywordflow">if</span> (rc != <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce46687acb19dbc2e15e6e89cdc39e8e18e">FC_SUCCESS</a>)
<a name="l00196"></a>00196     <span class="keywordflow">return</span> rc;
<a name="l00197"></a>00197 
<a name="l00198"></a>00198   <span class="comment">// Exposed enties are subset_skin - any skin shared with orig mesh</span>
<a name="l00199"></a>00199   <span class="comment">// Union of mesh &amp; subset skins will give us overlap</span>
<a name="l00200"></a>00200   rc = <a class="code" href="group__Subset.html#gebbcc05ef1a5287612b7767903e69b68" title="Create subset based on intersection of two input subsets.">fc_createSubsetIntersection</a>(mesh_skin, <span class="stringliteral">"AND"</span>, subset_skin, <span class="stringliteral">"temp"</span>,
<a name="l00201"></a>00201                        &amp;union_subset);
<a name="l00202"></a>00202   <span class="keywordflow">if</span> (!opt_meshSkin)
<a name="l00203"></a>00203     <a class="code" href="group__Subset.html#g550d0636e4f35c29d6dbc427b3165a24" title="Delete a subset.">fc_deleteSubset</a>(mesh_skin);
<a name="l00204"></a>00204   <span class="keywordflow">if</span> (rc != <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce46687acb19dbc2e15e6e89cdc39e8e18e">FC_SUCCESS</a>) {
<a name="l00205"></a>00205     <a class="code" href="group__Subset.html#g550d0636e4f35c29d6dbc427b3165a24" title="Delete a subset.">fc_deleteSubset</a>(subset_skin);
<a name="l00206"></a>00206     <span class="keywordflow">return</span> rc;
<a name="l00207"></a>00207   }
<a name="l00208"></a>00208   <span class="comment">// Xor of overlap and subset skin should give skin NOT overlapping</span>
<a name="l00209"></a>00209   rc = <a class="code" href="group__Subset.html#gebbcc05ef1a5287612b7767903e69b68" title="Create subset based on intersection of two input subsets.">fc_createSubsetIntersection</a>(subset_skin, <span class="stringliteral">"XOR"</span>, union_subset,
<a name="l00210"></a>00210                        <span class="stringliteral">"temp"</span>, exposed);
<a name="l00211"></a>00211   <a class="code" href="group__Subset.html#g550d0636e4f35c29d6dbc427b3165a24" title="Delete a subset.">fc_deleteSubset</a>(subset_skin);
<a name="l00212"></a>00212   <a class="code" href="group__Subset.html#g550d0636e4f35c29d6dbc427b3165a24" title="Delete a subset.">fc_deleteSubset</a>(union_subset);
<a name="l00213"></a>00213 
<a name="l00214"></a>00214   <span class="comment">// done</span>
<a name="l00215"></a>00215   <span class="keywordflow">return</span> rc;
<a name="l00216"></a>00216 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="g5cef93bfeb2c73c7990a26be98b44849"></a><!-- doxytag: member="elemdeath.c::fc_getShapeSidesDecayType" ref="g5cef93bfeb2c73c7990a26be98b44849" args="(FC_Subset deadSubset, FC_Shape *shape, int **sidedecayflag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DataTypes.html#g2a40aa471d085988d5b582669f766ce4">FC_ReturnCode</a> fc_getShapeSidesDecayType           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFC__Subset.html">FC_Subset</a>&nbsp;</td>
          <td class="paramname"> <em>deadSubset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structFC__Shape.html">FC_Shape</a> *&nbsp;</td>
          <td class="paramname"> <em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&nbsp;</td>
          <td class="paramname"> <em>sidedecayflag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get identifier telling if deadSubset intersects or entirely erodes the sides of a shape. 
<p>
<b>Description:</b> <p>
Given a dead subset, returns an array of identifiers, one for each side of a shape, telling if the deadSubset intersects or entirely erodes the sides of a shape.<p>
Identifier values:<ul>
<li>0 if the deadSubset doesnt intersect the sides at all.</li><li>1 if the deadSubset intersects the side</li><li>2 if the deadSubset erodes the whole side.</li><li>-1 in case of error</li></ul>
<p>
The dead subset can have assoc FC_AT_FACE or FC_AT_ELEM. The dead subset and shape have to be on the same mesh. This function is essentially a wrapper around <a class="el" href="group__ElemDeath.html#g7f53a591070ef1f242ee2574e1556a8e">fc_getSubsetDecayType</a>. If you want this functionally for only 1 side of the Shape, then call <a class="el" href="group__ElemDeath.html#g7f53a591070ef1f242ee2574e1556a8e">fc_getSubsetDecayType</a>.<p>
Right now, if any side fails, the whole thing fails, since you wouldnt have an empty or NULL side in a shape and therefore this is probably indicative of a more serious error in your shape.<p>
While this is expected to be used for a dead region and a shape, there is nothing that checks that it is a dead region and so it can be used more generally. It is being placed in elemdeath however, because this function was developed for a specific dead element need and using the deadelement terminology in this function name is beneficial.<p>
<dl compact><dt><b><a class="el" href="todo.html#_todo000006">Todo:</a></b></dt><dd><ul>
<li>do we want this to succeed if any one side is bad?</li></ul>
</dd></dl>
<b>Modifications:</b> <ul>
<li>02/14/2006 ACG fc_getSidesDecay created, which replaced fc_getDecayedMeshSkinSideIntersections.</li><li>07/17/2006 ACG new version born of fc_getSidesDecay. </li></ul>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>deadSubset</em>&nbsp;</td><td>
input - deadSubset </td></tr>
<tr><td valign="top"><em>shape</em>&nbsp;</td><td>
input - ptr to shape </td></tr>
<tr><td valign="top"><em>sidedecayflag</em>&nbsp;</td><td>
output - decay flag array </td></tr>
</table>
</dl>
<p>Definition at line <a class="el" href="elemdeath_8c-source.html#l00669">669</a> of file <a class="el" href="elemdeath_8c-source.html">elemdeath.c</a>.</p>

<p>References <a class="el" href="shape_8h-source.html#l00089">FC_Shape::elems</a>, <a class="el" href="shape_8h-source.html#l00088">FC_Shape::faces</a>, <a class="el" href="base_8h-source.html#l00196">FC_AT_ELEMENT</a>, <a class="el" href="base_8h-source.html#l00194">FC_AT_FACE</a>, <a class="el" href="base_8c-source.html#l00355">fc_getReturnCodeText()</a>, <a class="el" href="subset_8c-source.html#l02902">fc_getSubsetAssociationType()</a>, <a class="el" href="elemdeath_8c-source.html#l00410">fc_getSubsetDecayType()</a>, <a class="el" href="base_8h-source.html#l00107">FC_INPUT_ERROR</a>, <a class="el" href="subset_8c-source.html#l02622">fc_isSubsetValid()</a>, <a class="el" href="base_8h-source.html#l00106">FC_MEMORY_ERROR</a>, <a class="el" href="library_8h-source.html#l00120">fc_printfErrorMessage</a>, <a class="el" href="base_8h-source.html#l00104">FC_SUCCESS</a>, and <a class="el" href="shape_8h-source.html#l00087">FC_Shape::numSides</a>.</p>

<p>Referenced by <a class="el" href="screwBreaks_8c-source.html#l00676">eroded()</a>, and <a class="el" href="elemdeath__ex1_8c-source.html#l00147">main()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00673"></a>00673     {
<a name="l00674"></a>00674 
<a name="l00675"></a>00675   <a class="code" href="group__DataTypes.html#g2a40aa471d085988d5b582669f766ce4" title="Possible function return values.">FC_ReturnCode</a> rc;
<a name="l00676"></a>00676   <a class="code" href="group__DataTypes.html#g28b7cdba59395ddc988888d01dd19af6" title="Possible association of the data to the mesh.">FC_AssociationType</a> assocdead;
<a name="l00677"></a>00677   <span class="keywordtype">int</span> *flags;
<a name="l00678"></a>00678   <span class="keywordtype">int</span> usefaces = 0;
<a name="l00679"></a>00679   <span class="keywordtype">int</span> i;
<a name="l00680"></a>00680 
<a name="l00681"></a>00681   <span class="comment">//default returns</span>
<a name="l00682"></a>00682   <span class="keywordflow">if</span> (sidedecayflag)
<a name="l00683"></a>00683     *sidedecayflag = NULL;
<a name="l00684"></a>00684 
<a name="l00685"></a>00685   <span class="comment">//other things chekced inside</span>
<a name="l00686"></a>00686   <span class="keywordflow">if</span> (!<a class="code" href="group__Subset.html#g63bf248cb60435e458ea038036d6af90" title="Check that the handle refers to a valid subset.">fc_isSubsetValid</a>(deadSubset) || !shape ||
<a name="l00687"></a>00687       !sidedecayflag){
<a name="l00688"></a>00688     <a class="code" href="group__Library.html#g1473e77471cd1319f76eb9a32e4ad91f" title="Print an error message to stderr.">fc_printfErrorMessage</a>(<span class="stringliteral">"%s"</span>, <a class="code" href="group__DataTypes.html#g510d74cc1e13d4cdc5bde247a25d48e4" title="Return the name of the FC_ReturnCode&amp;#39;s value.">fc_getReturnCodeText</a>(<a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce464a3d55131c355cdf036f95d0d7e1a6e">FC_INPUT_ERROR</a>));
<a name="l00689"></a>00689     <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce464a3d55131c355cdf036f95d0d7e1a6e">FC_INPUT_ERROR</a>;
<a name="l00690"></a>00690   }
<a name="l00691"></a>00691 
<a name="l00692"></a>00692   flags = (<span class="keywordtype">int</span>*)malloc(shape-&gt;<a class="code" href="structFC__Shape.html#c9ea723452fe6cd941e3abb06ac4aee3">numSides</a>*<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
<a name="l00693"></a>00693   <span class="keywordflow">if</span> (!flags){
<a name="l00694"></a>00694     <a class="code" href="group__Library.html#g1473e77471cd1319f76eb9a32e4ad91f" title="Print an error message to stderr.">fc_printfErrorMessage</a>(<span class="stringliteral">"%s"</span>, <a class="code" href="group__DataTypes.html#g510d74cc1e13d4cdc5bde247a25d48e4" title="Return the name of the FC_ReturnCode&amp;#39;s value.">fc_getReturnCodeText</a>(<a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce4db79475c8e6c2fcf3e4e7979a4139658">FC_MEMORY_ERROR</a>));
<a name="l00695"></a>00695     <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce4db79475c8e6c2fcf3e4e7979a4139658">FC_MEMORY_ERROR</a>;  
<a name="l00696"></a>00696   }
<a name="l00697"></a>00697 
<a name="l00698"></a>00698   <span class="comment">//check assoc, mesh is checked in internal calls. </span>
<a name="l00699"></a>00699   rc = <a class="code" href="group__Subset.html#g7e34b0e8a2f9d42c44f0ee4ea00f5e8a" title="Get subset&amp;#39;s association type.">fc_getSubsetAssociationType</a>(deadSubset,&amp;assocdead);
<a name="l00700"></a>00700   <span class="keywordflow">if</span> (assocdead != <a class="code" href="group__DataTypes.html#gg28b7cdba59395ddc988888d01dd19af690a2a90b49747de25e69b3bfdad27f4a">FC_AT_ELEMENT</a> &amp;&amp; assocdead!= <a class="code" href="group__DataTypes.html#gg28b7cdba59395ddc988888d01dd19af640a4ba10b4045dfe3aef0e0c0588cbd0">FC_AT_FACE</a>){
<a name="l00701"></a>00701     <a class="code" href="group__Library.html#g1473e77471cd1319f76eb9a32e4ad91f" title="Print an error message to stderr.">fc_printfErrorMessage</a>(<span class="stringliteral">"deadSubset must have face or element assoc"</span>);
<a name="l00702"></a>00702     <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce464a3d55131c355cdf036f95d0d7e1a6e">FC_INPUT_ERROR</a>;
<a name="l00703"></a>00703   }
<a name="l00704"></a>00704   <span class="keywordflow">if</span> (assocdead == <a class="code" href="group__DataTypes.html#gg28b7cdba59395ddc988888d01dd19af640a4ba10b4045dfe3aef0e0c0588cbd0">FC_AT_FACE</a>){
<a name="l00705"></a>00705     usefaces = 1;
<a name="l00706"></a>00706   } <span class="comment">//otherwise use elems</span>
<a name="l00707"></a>00707 
<a name="l00708"></a>00708   <span class="keywordflow">for</span> (i = 0; i &lt; shape-&gt;<a class="code" href="structFC__Shape.html#c9ea723452fe6cd941e3abb06ac4aee3">numSides</a>; i++){
<a name="l00709"></a>00709     <a class="code" href="structFC__Subset.html" title="Subset Handle.">FC_Subset</a> tempSubset;
<a name="l00710"></a>00710     <span class="keywordflow">if</span> (usefaces){
<a name="l00711"></a>00711       tempSubset = shape-&gt;<a class="code" href="structFC__Shape.html#d3057d72e60c8f7f024bf3770a6d7c74">faces</a>[i];
<a name="l00712"></a>00712     }<span class="keywordflow">else</span>{
<a name="l00713"></a>00713       tempSubset = shape-&gt;<a class="code" href="structFC__Shape.html#840d2dfc7ec0e2c1a3624b94f5836679">elems</a>[i];
<a name="l00714"></a>00714     }
<a name="l00715"></a>00715     rc = <a class="code" href="group__ElemDeath.html#g7f53a591070ef1f242ee2574e1556a8e" title="Get identifier telling if deadSubset intersects, or entirely erodes a subset.">fc_getSubsetDecayType</a>(deadSubset,tempSubset,&amp;flags[i]);
<a name="l00716"></a>00716     <span class="keywordflow">if</span> (rc != <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce46687acb19dbc2e15e6e89cdc39e8e18e">FC_SUCCESS</a>){
<a name="l00717"></a>00717       <a class="code" href="group__Library.html#g1473e77471cd1319f76eb9a32e4ad91f" title="Print an error message to stderr.">fc_printfErrorMessage</a>(<span class="stringliteral">"Can't get decay type for side %d"</span>,i);
<a name="l00718"></a>00718       free(flags);
<a name="l00719"></a>00719       <span class="keywordflow">return</span> rc;
<a name="l00720"></a>00720     }
<a name="l00721"></a>00721   }
<a name="l00722"></a>00722 
<a name="l00723"></a>00723   *sidedecayflag = flags;
<a name="l00724"></a>00724 
<a name="l00725"></a>00725   <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce46687acb19dbc2e15e6e89cdc39e8e18e">FC_SUCCESS</a>;
<a name="l00726"></a>00726 };
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="g7f53a591070ef1f242ee2574e1556a8e"></a><!-- doxytag: member="elemdeath.c::fc_getSubsetDecayType" ref="g7f53a591070ef1f242ee2574e1556a8e" args="(FC_Subset deadSubset, FC_Subset compSubset, int *sidedecayflag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DataTypes.html#g2a40aa471d085988d5b582669f766ce4">FC_ReturnCode</a> fc_getSubsetDecayType           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFC__Subset.html">FC_Subset</a>&nbsp;</td>
          <td class="paramname"> <em>deadSubset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structFC__Subset.html">FC_Subset</a>&nbsp;</td>
          <td class="paramname"> <em>compSubset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>sidedecayflag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get identifier telling if deadSubset intersects, or entirely erodes a subset. 
<p>
<b>Description:</b> <p>
Given a dead subset, returns an identifier telling if the deadSubset intersects, or entirely erodes the comparisonSubset.<p>
Identifier values:<ul>
<li>0 if the deadSubset doesnt intersect the compSubset at all.</li><li>1 if the deadSubset intersects the compSubset.</li><li>2 if the deadSubset erodes the whole compSubset.</li><li>-1 in case of error</li></ul>
<p>
The deadSubset and the compSubset both have to have the same assocation. It must either be FC_AT_FACE or FC_AT_ELEMENT. They must also be on the same mesh. This function is currently a wrapper around <a class="el" href="group__Subset.html#gb7080f044773d103b850e93c3e023a44">fc_doSubsetsIntersect</a> and <a class="el" href="group__Subset.html#gc645c9d211fb235acd08870890794c43">fc_isSubsetSuperset</a> and is subject to the constraints of those methods.<p>
Fails if the compsubset is empty or null of if the deadsubset is null. The dead set can be empty and returns 0. (The inner calls would support permuations of empty and null, but the logic of the call does not).<p>
In general, it is expect that this will be used to compare a dead region and the side of a mesh, but there is nothing that checks that so this can in fact be used more generally, and also misused at your peril. It is being placed in elemdeath however, because this function was developed for a specific dead element need and using the deadelement terminology in this function name is beneficial. If you want to do this comparison for all the sides of a shape, use <a class="el" href="group__ElemDeath.html#g5cef93bfeb2c73c7990a26be98b44849">fc_getShapeSidesDecayType</a>.<p>
<dl compact><dt><b><a class="el" href="todo.html#_todo000005">Todo:</a></b></dt><dd><ul>
<li>make more efficient by not having to call both the intersection and the superset code.</li></ul>
</dd></dl>
<b>Modifications:</b> <ul>
<li>02/14/2006 ACG fc_getSidesDecay created, which replaced fc_getDecayedMeshSkinSideIntersections.</li><li>07/17/2006 ACG new version born of fc_getSidesDecay. </li></ul>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>deadSubset</em>&nbsp;</td><td>
input - deadSubset </td></tr>
<tr><td valign="top"><em>compSubset</em>&nbsp;</td><td>
input - comparison subset </td></tr>
<tr><td valign="top"><em>sidedecayflag</em>&nbsp;</td><td>
output - decay flag </td></tr>
</table>
</dl>
<p>Definition at line <a class="el" href="elemdeath_8c-source.html#l00410">410</a> of file <a class="el" href="elemdeath_8c-source.html">elemdeath.c</a>.</p>

<p>References <a class="el" href="base_8h-source.html#l00196">FC_AT_ELEMENT</a>, <a class="el" href="base_8h-source.html#l00194">FC_AT_FACE</a>, <a class="el" href="subset_8c-source.html#l01684">fc_doSubsetsIntersect()</a>, <a class="el" href="base_8c-source.html#l00355">fc_getReturnCodeText()</a>, <a class="el" href="subset_8c-source.html#l02902">fc_getSubsetAssociationType()</a>, <a class="el" href="subset_8c-source.html#l02828">fc_getSubsetNumMember()</a>, <a class="el" href="base_8h-source.html#l00319">FC_HANDLE_EQUIV</a>, <a class="el" href="base_8h-source.html#l00107">FC_INPUT_ERROR</a>, <a class="el" href="subset_8c-source.html#l01809">fc_isSubsetSuperset()</a>, <a class="el" href="subset_8c-source.html#l02622">fc_isSubsetValid()</a>, <a class="el" href="base_8c-source.html#l00784">FC_NULL_SUBSET</a>, <a class="el" href="library_8h-source.html#l00120">fc_printfErrorMessage</a>, and <a class="el" href="base_8h-source.html#l00104">FC_SUCCESS</a>.</p>

<p>Referenced by <a class="el" href="elemdeath_8c-source.html#l00669">fc_getShapeSidesDecayType()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00414"></a>00414     {
<a name="l00415"></a>00415 
<a name="l00416"></a>00416   <a class="code" href="group__DataTypes.html#g2a40aa471d085988d5b582669f766ce4" title="Possible function return values.">FC_ReturnCode</a> rc;
<a name="l00417"></a>00417   <a class="code" href="group__DataTypes.html#g28b7cdba59395ddc988888d01dd19af6" title="Possible association of the data to the mesh.">FC_AssociationType</a> assocdead, assoccomp;
<a name="l00418"></a>00418   <span class="keywordtype">int</span> ret = -1;
<a name="l00419"></a>00419   <span class="keywordtype">int</span> i;
<a name="l00420"></a>00420 
<a name="l00421"></a>00421   <span class="comment">//default returns</span>
<a name="l00422"></a>00422   <span class="keywordflow">if</span> (sidedecayflag)
<a name="l00423"></a>00423     *sidedecayflag = -1;
<a name="l00424"></a>00424 
<a name="l00425"></a>00425   <span class="keywordflow">if</span> (!<a class="code" href="group__Subset.html#g63bf248cb60435e458ea038036d6af90" title="Check that the handle refers to a valid subset.">fc_isSubsetValid</a>(deadSubset) || !<a class="code" href="group__Subset.html#g63bf248cb60435e458ea038036d6af90" title="Check that the handle refers to a valid subset.">fc_isSubsetValid</a>(compSubset) ||
<a name="l00426"></a>00426       !sidedecayflag){
<a name="l00427"></a>00427     <a class="code" href="group__Library.html#g1473e77471cd1319f76eb9a32e4ad91f" title="Print an error message to stderr.">fc_printfErrorMessage</a>(<span class="stringliteral">"%s"</span>, <a class="code" href="group__DataTypes.html#g510d74cc1e13d4cdc5bde247a25d48e4" title="Return the name of the FC_ReturnCode&amp;#39;s value.">fc_getReturnCodeText</a>(<a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce464a3d55131c355cdf036f95d0d7e1a6e">FC_INPUT_ERROR</a>));
<a name="l00428"></a>00428     <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce464a3d55131c355cdf036f95d0d7e1a6e">FC_INPUT_ERROR</a>;
<a name="l00429"></a>00429   }
<a name="l00430"></a>00430 
<a name="l00431"></a>00431   <span class="keywordflow">if</span> (<a class="code" href="group__Handles.html#g390004fca0870147d490f32c55afab8d" title="Check two handles for equality.">FC_HANDLE_EQUIV</a>(compSubset,<a class="code" href="group__Handles.html#gd007f5eb6e7e7f2febca17b53420fd15" title="Null (default) subset handle.">FC_NULL_SUBSET</a>)){
<a name="l00432"></a>00432     <a class="code" href="group__Library.html#g1473e77471cd1319f76eb9a32e4ad91f" title="Print an error message to stderr.">fc_printfErrorMessage</a>(<span class="stringliteral">"comp subset cannot be NULL"</span>);
<a name="l00433"></a>00433     <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce464a3d55131c355cdf036f95d0d7e1a6e">FC_INPUT_ERROR</a>;
<a name="l00434"></a>00434   } 
<a name="l00435"></a>00435 
<a name="l00436"></a>00436   rc = <a class="code" href="group__Subset.html#gdf7851470403bb379426110abf7923ba" title="Get number of members in a subset.">fc_getSubsetNumMember</a>(compSubset,&amp;i);
<a name="l00437"></a>00437   <span class="keywordflow">if</span> (rc != <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce46687acb19dbc2e15e6e89cdc39e8e18e">FC_SUCCESS</a>){
<a name="l00438"></a>00438     <a class="code" href="group__Library.html#g1473e77471cd1319f76eb9a32e4ad91f" title="Print an error message to stderr.">fc_printfErrorMessage</a>(<span class="stringliteral">"cant get num members of comp subset"</span>);
<a name="l00439"></a>00439     <span class="keywordflow">return</span> rc;
<a name="l00440"></a>00440   } 
<a name="l00441"></a>00441   <span class="keywordflow">if</span> (!i){
<a name="l00442"></a>00442     <a class="code" href="group__Library.html#g1473e77471cd1319f76eb9a32e4ad91f" title="Print an error message to stderr.">fc_printfErrorMessage</a>(<span class="stringliteral">"comp subset cannot be empty"</span>);
<a name="l00443"></a>00443     <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce464a3d55131c355cdf036f95d0d7e1a6e">FC_INPUT_ERROR</a>;
<a name="l00444"></a>00444   }
<a name="l00445"></a>00445 
<a name="l00446"></a>00446   <span class="comment">//check assoc, mesh is checked in internal calls. </span>
<a name="l00447"></a>00447   rc = <a class="code" href="group__Subset.html#g7e34b0e8a2f9d42c44f0ee4ea00f5e8a" title="Get subset&amp;#39;s association type.">fc_getSubsetAssociationType</a>(deadSubset,&amp;assocdead);
<a name="l00448"></a>00448   <span class="keywordflow">if</span> (assocdead != <a class="code" href="group__DataTypes.html#gg28b7cdba59395ddc988888d01dd19af690a2a90b49747de25e69b3bfdad27f4a">FC_AT_ELEMENT</a> &amp;&amp; assocdead!= <a class="code" href="group__DataTypes.html#gg28b7cdba59395ddc988888d01dd19af640a4ba10b4045dfe3aef0e0c0588cbd0">FC_AT_FACE</a>){
<a name="l00449"></a>00449     <a class="code" href="group__Library.html#g1473e77471cd1319f76eb9a32e4ad91f" title="Print an error message to stderr.">fc_printfErrorMessage</a>(<span class="stringliteral">"deadSubset must have face or element assoc"</span>);
<a name="l00450"></a>00450     <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce464a3d55131c355cdf036f95d0d7e1a6e">FC_INPUT_ERROR</a>;
<a name="l00451"></a>00451   }
<a name="l00452"></a>00452   rc = <a class="code" href="group__Subset.html#g7e34b0e8a2f9d42c44f0ee4ea00f5e8a" title="Get subset&amp;#39;s association type.">fc_getSubsetAssociationType</a>(compSubset,&amp;assoccomp);
<a name="l00453"></a>00453   <span class="keywordflow">if</span> (assoccomp != assocdead){
<a name="l00454"></a>00454     <a class="code" href="group__Library.html#g1473e77471cd1319f76eb9a32e4ad91f" title="Print an error message to stderr.">fc_printfErrorMessage</a>(<span class="stringliteral">"compSubset must have smae assoc as deadSubset"</span>);
<a name="l00455"></a>00455     <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce464a3d55131c355cdf036f95d0d7e1a6e">FC_INPUT_ERROR</a>;
<a name="l00456"></a>00456   }
<a name="l00457"></a>00457 
<a name="l00458"></a>00458   rc = <a class="code" href="group__Subset.html#gb7080f044773d103b850e93c3e023a44" title="Test if two subsets intersect.">fc_doSubsetsIntersect</a>(deadSubset,compSubset,&amp;ret);
<a name="l00459"></a>00459   <span class="keywordflow">if</span> (rc != <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce46687acb19dbc2e15e6e89cdc39e8e18e">FC_SUCCESS</a>){
<a name="l00460"></a>00460     <span class="keywordflow">return</span> rc;
<a name="l00461"></a>00461   }
<a name="l00462"></a>00462   <span class="keywordflow">if</span> (ret == 1){
<a name="l00463"></a>00463     <span class="keywordtype">int</span> ind2;
<a name="l00464"></a>00464     
<a name="l00465"></a>00465     rc = <a class="code" href="group__Subset.html#gc645c9d211fb235acd08870890794c43" title="Test if first subset is a superset of the second subset.">fc_isSubsetSuperset</a>(deadSubset,compSubset,&amp;ind2);
<a name="l00466"></a>00466     <span class="keywordflow">if</span> (rc != <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce46687acb19dbc2e15e6e89cdc39e8e18e">FC_SUCCESS</a>){
<a name="l00467"></a>00467       <span class="keywordflow">return</span> rc;
<a name="l00468"></a>00468     }
<a name="l00469"></a>00469     ret = (ind2 == 1 ? 2:1);
<a name="l00470"></a>00470   }
<a name="l00471"></a>00471 
<a name="l00472"></a>00472   *sidedecayflag  = ret;
<a name="l00473"></a>00473   <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce46687acb19dbc2e15e6e89cdc39e8e18e">FC_SUCCESS</a>;
<a name="l00474"></a>00474 };
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="ga5ee90cb8f509b4b15f6cdc8a029451a"></a><!-- doxytag: member="elemdeath.c::fc_subsetPlusNeighborGreaterSegmentationMesh" ref="ga5ee90cb8f509b4b15f6cdc8a029451a" args="(FC_Subset subset, int shared_neighbordim, int shared_segdim, int *numNbr, int **nbrIDs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DataTypes.html#g2a40aa471d085988d5b582669f766ce4">FC_ReturnCode</a> fc_subsetPlusNeighborGreaterSegmentationMesh           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFC__Subset.html">FC_Subset</a>&nbsp;</td>
          <td class="paramname"> <em>subset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>shared_neighbordim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>shared_segdim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>numNbr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&nbsp;</td>
          <td class="paramname"> <em>nbrIDs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
given an input subset and parameters for specifying neghbors, returns IDs of neighbors for which adding any single one individually to the subset will result in a greater segmentation of the mesh than results from segmenting based on the orginal subset 
<p>
<b>Description:</b> <p>
given an input subset and parameters for specifying neghbors, returns IDs of neighbors for which adding any single one individually to the subset will result in a greater segmentation of the mesh than results from segmenting based on the orginal subset.<p>
Returns -1 in case of error. Passing in an empty subset returns -1.<p>
Notes:<ul>
<li>No sense passing in anything more than level 1 since we are considering no element combos at this point.</li><li>This uses recursive innards that test on big sets of elem first and only narrow it down to smaller set if the big sets segment first. i.e., It is assumed that if a whole group doesnt result in any different segmenting, that the items of the group taken individually wont rest in different segmenting. There is the possibility that there could be offsetting effects that occur within the bigger set that will cuase this to be a faulty assumption, particularly when the dead region is near the boundary of the mesh. However, if this is used primarily for cases where we are looking for the mesh to be just about to break, then we expect that the num of elements that will satisfy the condition is small and so this should be ok.</li></ul>
<p>
<dl compact><dt><b><a class="el" href="todo.html#_todo000009">Todo:</a></b></dt><dd></dd></dl>
<ul>
<li>prob need a version that doesnt make the assumption that the recusion implies - esp for dead regions near boundary of mesh.</li><li>should this return IDS if it segments into fewer (ie subsumes the mesh, or causes to segments to combine ?). Note may cause problems with considering things as groups as effects might counter each other.</li><li>may want a version that does combos of elem. the recursive innards, would not support that.</li><li>should we return num of resulting segments ?</li><li>should we make a time version or no ?</li><li>note: will need to upate if change return vals of recurive innard</li><li>do we want to explicity test the shareddim earlier in the call, and the unittest ratehr than them just being caught in the innards ?</li></ul>
<p>
<b>Modifications:</b> <ul>
<li>8/24/2005 ACG. Created.</li><li>8/31/2005 ACG recusive version</li><li>9/20/2005 ACG changed so uses new recursive innards taht retrun segmenting nodes instead of non-segmenting nodes so dont have to invert the list at the end.</li><li>9/20/2005 ACG name change to reflect that will only be dealing with greater segmentation</li><li>9/22/2005 ACG added segmentation dim</li><li>10/9/05 ACG limited it to neighbor depth level 1 </li></ul>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>subset</em>&nbsp;</td><td>
input - subset testing on </td></tr>
<tr><td valign="top"><em>shared_neighbordim</em>&nbsp;</td><td>
input - minimum dimensionality of shared part of neighbors </td></tr>
<tr><td valign="top"><em>shared_segdim</em>&nbsp;</td><td>
input - shared dim for segmentation </td></tr>
<tr><td valign="top"><em>numNbr</em>&nbsp;</td><td>
output - number of neigbors that will individually cause greater segmentation </td></tr>
<tr><td valign="top"><em>nbrIDs</em>&nbsp;</td><td>
output - IDS of neighbors that will individually cause greater segmentation </td></tr>
</table>
</dl>
<p>Definition at line <a class="el" href="elemdeath_8c-source.html#l01072">1072</a> of file <a class="el" href="elemdeath_8c-source.html">elemdeath.c</a>.</p>

<p>References <a class="el" href="elemdeath_8c-source.html#l01268">_fc_recursive_IndividuallySegmentingNodes()</a>, <a class="el" href="base_8h-source.html#l00196">FC_AT_ELEMENT</a>, <a class="el" href="base_8h-source.html#l00197">FC_AT_WHOLE_MESH</a>, <a class="el" href="base_8c-source.html#l00355">fc_getReturnCodeText()</a>, <a class="el" href="subset_8c-source.html#l02782">fc_getSubsetInfo()</a>, <a class="el" href="topo_8c-source.html#l00603">fc_getSubsetNeighbors()</a>, <a class="el" href="base_8h-source.html#l00107">FC_INPUT_ERROR</a>, <a class="el" href="subset_8c-source.html#l02622">fc_isSubsetValid()</a>, <a class="el" href="base_8h-source.html#l00106">FC_MEMORY_ERROR</a>, <a class="el" href="library_8h-source.html#l00120">fc_printfErrorMessage</a>, <a class="el" href="library_8h-source.html#l00188">fc_printfLogMessage</a>, <a class="el" href="elemdeath_8c-source.html#l00778">fc_subsetSegmentsMesh()</a>, and <a class="el" href="base_8h-source.html#l00104">FC_SUCCESS</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l01078"></a>01078    {
<a name="l01079"></a>01079   <a class="code" href="group__DataTypes.html#g2a40aa471d085988d5b582669f766ce4" title="Possible function return values.">FC_ReturnCode</a> rc;
<a name="l01080"></a>01080   <a class="code" href="group__DataTypes.html#g28b7cdba59395ddc988888d01dd19af6" title="Possible association of the data to the mesh.">FC_AssociationType</a> in_assoc;
<a name="l01081"></a>01081   <span class="keywordtype">int</span> numMember, maxNumMember;
<a name="l01082"></a>01082   <span class="keywordtype">int</span> numSubset, natNbr, *natNbrIDs, nmaxnsegids, *maxnsegids;
<a name="l01083"></a>01083   <span class="keywordtype">int</span> i;
<a name="l01084"></a>01084   <span class="keywordtype">int</span> level = 1;
<a name="l01085"></a>01085 
<a name="l01086"></a>01086   <span class="comment">// default returns</span>
<a name="l01087"></a>01087   <span class="keywordflow">if</span> (numNbr)
<a name="l01088"></a>01088     *numNbr = -1;
<a name="l01089"></a>01089   <span class="keywordflow">if</span> (nbrIDs)
<a name="l01090"></a>01090     *nbrIDs = NULL;
<a name="l01091"></a>01091 
<a name="l01092"></a>01092 
<a name="l01093"></a>01093   <span class="comment">// Test input (segment will check shared_segdim)</span>
<a name="l01094"></a>01094   <span class="keywordflow">if</span> (!<a class="code" href="group__Subset.html#g63bf248cb60435e458ea038036d6af90" title="Check that the handle refers to a valid subset.">fc_isSubsetValid</a>(subset) ||  level &lt; 1 || shared_neighbordim &lt; 0 || 
<a name="l01095"></a>01095       shared_neighbordim &gt; 2 || !numNbr || !nbrIDs) {
<a name="l01096"></a>01096     <a class="code" href="group__Library.html#g1473e77471cd1319f76eb9a32e4ad91f" title="Print an error message to stderr.">fc_printfErrorMessage</a>(<span class="stringliteral">"%s"</span>, <a class="code" href="group__DataTypes.html#g510d74cc1e13d4cdc5bde247a25d48e4" title="Return the name of the FC_ReturnCode&amp;#39;s value.">fc_getReturnCodeText</a>(<a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce464a3d55131c355cdf036f95d0d7e1a6e">FC_INPUT_ERROR</a>));
<a name="l01097"></a>01097     <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce464a3d55131c355cdf036f95d0d7e1a6e">FC_INPUT_ERROR</a>;
<a name="l01098"></a>01098   }
<a name="l01099"></a>01099 
<a name="l01100"></a>01100   rc = <a class="code" href="group__Subset.html#g815857d0e2d573d0418a3892229c0d83" title="Get information about a subset.">fc_getSubsetInfo</a>(subset, &amp;numMember, &amp;maxNumMember, &amp;in_assoc);
<a name="l01101"></a>01101   <span class="keywordflow">if</span> (rc != <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce46687acb19dbc2e15e6e89cdc39e8e18e">FC_SUCCESS</a>)
<a name="l01102"></a>01102     <span class="keywordflow">return</span> rc;
<a name="l01103"></a>01103 
<a name="l01104"></a>01104   <span class="keywordflow">if</span> (in_assoc != <a class="code" href="group__DataTypes.html#gg28b7cdba59395ddc988888d01dd19af690a2a90b49747de25e69b3bfdad27f4a">FC_AT_ELEMENT</a> &amp;&amp; in_assoc != <a class="code" href="group__DataTypes.html#gg28b7cdba59395ddc988888d01dd19af62b7e38452f200e9abd5767534b43d670">FC_AT_WHOLE_MESH</a>) {
<a name="l01105"></a>01105     <a class="code" href="group__Library.html#g1473e77471cd1319f76eb9a32e4ad91f" title="Print an error message to stderr.">fc_printfErrorMessage</a>(<span class="stringliteral">"Subset must have element or whole association"</span>);
<a name="l01106"></a>01106     <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce464a3d55131c355cdf036f95d0d7e1a6e">FC_INPUT_ERROR</a>;
<a name="l01107"></a>01107   }
<a name="l01108"></a>01108 
<a name="l01109"></a>01109 
<a name="l01110"></a>01110   <span class="keywordflow">if</span> (numMember == 0) {
<a name="l01111"></a>01111     <a class="code" href="group__Library.html#g1473e77471cd1319f76eb9a32e4ad91f" title="Print an error message to stderr.">fc_printfErrorMessage</a>(<span class="stringliteral">"Cannot handle empty subset"</span>);
<a name="l01112"></a>01112     <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce464a3d55131c355cdf036f95d0d7e1a6e">FC_INPUT_ERROR</a>;
<a name="l01113"></a>01113   }
<a name="l01114"></a>01114 
<a name="l01115"></a>01115 
<a name="l01116"></a>01116   <a class="code" href="group__Library.html#g7e9664a8765cc08c313df880421c496b" title="Print a log message to stdout.">fc_printfLogMessage</a>(<span class="stringliteral">"subsetPlusNeighborsSegmentsMesh"</span>);
<a name="l01117"></a>01117 
<a name="l01118"></a>01118   <span class="comment">//first determine the orignal segmentation</span>
<a name="l01119"></a>01119   rc = <a class="code" href="group__ElemDeath.html#g332e59c8a844757b89063201843da456" title="returns the segments (and their number) that result from segmenting the mesh by the...">fc_subsetSegmentsMesh</a>(subset,shared_segdim,NULL,&amp;numSubset,NULL);
<a name="l01120"></a>01120   <span class="keywordflow">if</span> (rc != <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce46687acb19dbc2e15e6e89cdc39e8e18e">FC_SUCCESS</a>){
<a name="l01121"></a>01121     <a class="code" href="group__Library.html#g1473e77471cd1319f76eb9a32e4ad91f" title="Print an error message to stderr.">fc_printfErrorMessage</a>(<span class="stringliteral">"cant get original segmentation"</span>);
<a name="l01122"></a>01122     <span class="keywordflow">return</span> rc;
<a name="l01123"></a>01123   }
<a name="l01124"></a>01124 
<a name="l01125"></a>01125   <span class="comment">//now get the neighbors </span>
<a name="l01126"></a>01126   rc = <a class="code" href="group__TopologyRelations.html#g90b1b90dfd00245a14d585f3b7f0bf6d" title="Get the neighbors of a subset.">fc_getSubsetNeighbors</a>(subset,level,shared_neighbordim,
<a name="l01127"></a>01127                      &amp;in_assoc,
<a name="l01128"></a>01128                      &amp;natNbr,&amp;natNbrIDs);
<a name="l01129"></a>01129   <span class="keywordflow">if</span> (rc != <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce46687acb19dbc2e15e6e89cdc39e8e18e">FC_SUCCESS</a>){
<a name="l01130"></a>01130     <a class="code" href="group__Library.html#g1473e77471cd1319f76eb9a32e4ad91f" title="Print an error message to stderr.">fc_printfErrorMessage</a>(<span class="stringliteral">"cant get neighbors"</span>);
<a name="l01131"></a>01131     <span class="keywordflow">return</span> rc;
<a name="l01132"></a>01132   }
<a name="l01133"></a>01133   
<a name="l01134"></a>01134   <span class="keywordflow">if</span> (natNbr == 0){ <span class="comment">//no neighbors - treat this as valid</span>
<a name="l01135"></a>01135     *numNbr = 0;
<a name="l01136"></a>01136     <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce46687acb19dbc2e15e6e89cdc39e8e18e">FC_SUCCESS</a>;
<a name="l01137"></a>01137   }
<a name="l01138"></a>01138 
<a name="l01139"></a>01139   rc = <a class="code" href="group__PrivateElemDeath.html#ge61c8cc3cc48b9b3665baf788682abf7" title="helper function that recursively determines node ids that individually will result...">_fc_recursive_IndividuallySegmentingNodes</a>(subset,numSubset,shared_segdim,
<a name="l01140"></a>01140                         natNbr,natNbrIDs,
<a name="l01141"></a>01141                         &amp;nmaxnsegids, &amp;maxnsegids);
<a name="l01142"></a>01142   <span class="keywordflow">if</span> (rc != <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce46687acb19dbc2e15e6e89cdc39e8e18e">FC_SUCCESS</a>){
<a name="l01143"></a>01143     <a class="code" href="group__Library.html#g1473e77471cd1319f76eb9a32e4ad91f" title="Print an error message to stderr.">fc_printfErrorMessage</a>(<span class="stringliteral">"cant get recursive segmenting nodes"</span>);
<a name="l01144"></a>01144     <span class="keywordflow">if</span> (natNbrIDs) free(natNbrIDs);
<a name="l01145"></a>01145     <span class="keywordflow">return</span> rc;
<a name="l01146"></a>01146   }
<a name="l01147"></a>01147 
<a name="l01148"></a>01148   <span class="comment">//clean up neighbor arrays</span>
<a name="l01149"></a>01149   <span class="keywordflow">if</span> (natNbrIDs) free(natNbrIDs);
<a name="l01150"></a>01150 
<a name="l01151"></a>01151   <span class="comment">//return vals from recursive call are all the vals we want to return</span>
<a name="l01152"></a>01152   <span class="comment">//dont have to check them anymore</span>
<a name="l01153"></a>01153 
<a name="l01154"></a>01154   <span class="comment">//now set real return values</span>
<a name="l01155"></a>01155   *numNbr = nmaxnsegids;
<a name="l01156"></a>01156   <span class="keywordflow">if</span> (nmaxnsegids &gt; 0){
<a name="l01157"></a>01157     *nbrIDs = (<span class="keywordtype">int</span>*)malloc(nmaxnsegids*<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
<a name="l01158"></a>01158     <span class="keywordflow">if</span> (*nbrIDs == NULL){ <span class="comment">//no lcean up in case of memory error</span>
<a name="l01159"></a>01159       <a class="code" href="group__Library.html#g1473e77471cd1319f76eb9a32e4ad91f" title="Print an error message to stderr.">fc_printfErrorMessage</a>(<span class="stringliteral">"%s"</span>, <a class="code" href="group__DataTypes.html#g510d74cc1e13d4cdc5bde247a25d48e4" title="Return the name of the FC_ReturnCode&amp;#39;s value.">fc_getReturnCodeText</a>(<a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce4db79475c8e6c2fcf3e4e7979a4139658">FC_MEMORY_ERROR</a>));
<a name="l01160"></a>01160       <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce4db79475c8e6c2fcf3e4e7979a4139658">FC_MEMORY_ERROR</a>;
<a name="l01161"></a>01161     }
<a name="l01162"></a>01162 
<a name="l01163"></a>01163     <span class="keywordflow">for</span> (i = 0; i &lt; nmaxnsegids;i++){
<a name="l01164"></a>01164       (*nbrIDs)[i] = maxnsegids[i];
<a name="l01165"></a>01165     }
<a name="l01166"></a>01166   }
<a name="l01167"></a>01167   <span class="keywordflow">if</span> (maxnsegids) free(maxnsegids);
<a name="l01168"></a>01168 
<a name="l01169"></a>01169   <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce46687acb19dbc2e15e6e89cdc39e8e18e">FC_SUCCESS</a>;
<a name="l01170"></a>01170 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="g332e59c8a844757b89063201843da456"></a><!-- doxytag: member="elemdeath.c::fc_subsetSegmentsMesh" ref="g332e59c8a844757b89063201843da456" args="(FC_Subset subset, int shared_segdim, char *varname, int *numSubset, FC_Subset **newSubsets)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DataTypes.html#g2a40aa471d085988d5b582669f766ce4">FC_ReturnCode</a> fc_subsetSegmentsMesh           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFC__Subset.html">FC_Subset</a>&nbsp;</td>
          <td class="paramname"> <em>subset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>shared_segdim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>varname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>numSubset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structFC__Subset.html">FC_Subset</a> **&nbsp;</td>
          <td class="paramname"> <em>newSubsets</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
returns the segments (and their number) that result from segmenting the mesh by the input subset. 
<p>
<b>Description:</b> <p>
Returns the segments (and their number) that result from segmenting the mesh by the input subset. If you dont want the segment array, then newSubsets and varname are optional parameters. If you do want the segments, they will be named as the varname parameter pospended with "_Seg#" where # will be the index into the array of returned subsets.<p>
Returns -1 in case of error. If you pass in an empty subset -- this is not an error, unlike fc_exposedSkin.<p>
One can pass in subsets that have nothing to do with dead cells as well, of course, but we anticipate that this will be most often used with a dead region. If the number of returned segments &gt; the original number of segments then the subset has broken the mesh. If the number of returned segments = 0 then the subset has consumed the mesh, and therefore may also be considered to have broken the mesh.<p>
This is the mesh equivalent of <a class="el" href="group__ElemDeath.html#g666b97bf9ae5501aa0e296436f6dec7b">fc_subsetSegmentsSubset</a><p>
<dl compact><dt><b><a class="el" href="todo.html#_todo000007">Todo:</a></b></dt><dd><ul>
<li>test this for things other than elem</li></ul>
</dd></dl>
<b>Modifications:</b> <ul>
<li>8/2/2005 ACG. Created.</li><li>8/5/05 ACG. reincarnation of fc_subsetBreaksMesh</li><li>8/11/05 ACG made empty subset an ok case because the user prob wants to compare the number of segments to the orignal number to see if there are more. an empty subset is a valid case, esp if one is doing this over time.</li><li>9/22/05 ACG added shared segmentation dim </li></ul>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>subset</em>&nbsp;</td><td>
input - subset testing on </td></tr>
<tr><td valign="top"><em>shared_segdim</em>&nbsp;</td><td>
input - shared dim for segmentation </td></tr>
<tr><td valign="top"><em>varname</em>&nbsp;</td><td>
input - prefix for returned segments (optional) </td></tr>
<tr><td valign="top"><em>numSubset</em>&nbsp;</td><td>
output - number of resulting segments </td></tr>
<tr><td valign="top"><em>newSubsets</em>&nbsp;</td><td>
output - array of resulting segments (optional) </td></tr>
</table>
</dl>
<p>Definition at line <a class="el" href="elemdeath_8c-source.html#l00778">778</a> of file <a class="el" href="elemdeath_8c-source.html">elemdeath.c</a>.</p>

<p>References <a class="el" href="subset_8c-source.html#l00963">fc_createSubsetComplement()</a>, <a class="el" href="subset_8c-source.html#l02482">fc_deleteSubset()</a>, <a class="el" href="base_8c-source.html#l00355">fc_getReturnCodeText()</a>, <a class="el" href="base_8h-source.html#l00107">FC_INPUT_ERROR</a>, <a class="el" href="subset_8c-source.html#l02622">fc_isSubsetValid()</a>, <a class="el" href="library_8h-source.html#l00120">fc_printfErrorMessage</a>, <a class="el" href="library_8h-source.html#l00188">fc_printfLogMessage</a>, <a class="el" href="topo_8c-source.html#l01432">fc_segment()</a>, and <a class="el" href="base_8h-source.html#l00104">FC_SUCCESS</a>.</p>

<p>Referenced by <a class="el" href="elemdeath_8c-source.html#l01268">_fc_recursive_IndividuallySegmentingNodes()</a>, and <a class="el" href="elemdeath_8c-source.html#l01072">fc_subsetPlusNeighborGreaterSegmentationMesh()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00785"></a>00785  {
<a name="l00786"></a>00786   <a class="code" href="group__DataTypes.html#g2a40aa471d085988d5b582669f766ce4" title="Possible function return values.">FC_ReturnCode</a> rc;
<a name="l00787"></a>00787   <a class="code" href="structFC__Subset.html" title="Subset Handle.">FC_Subset</a> tempSubset,*tempsubarray;
<a name="l00788"></a>00788   <span class="comment">//  FC_AssociationType in_assoc;</span>
<a name="l00789"></a>00789   <span class="comment">//  int numMember, maxNumMember;</span>
<a name="l00790"></a>00790   <span class="keywordtype">int</span> i;
<a name="l00791"></a>00791   <span class="keywordtype">char</span>* tempname;
<a name="l00792"></a>00792 
<a name="l00793"></a>00793   <span class="comment">// default returns</span>
<a name="l00794"></a>00794   <span class="keywordflow">if</span> (numSubset)
<a name="l00795"></a>00795     *numSubset = -1;
<a name="l00796"></a>00796   <span class="keywordflow">if</span> (newSubsets)
<a name="l00797"></a>00797     *newSubsets = NULL;
<a name="l00798"></a>00798 
<a name="l00799"></a>00799 
<a name="l00800"></a>00800   <span class="comment">// Test input. (shared_segdim checked in fc_segment)</span>
<a name="l00801"></a>00801   <span class="keywordflow">if</span> (!<a class="code" href="group__Subset.html#g63bf248cb60435e458ea038036d6af90" title="Check that the handle refers to a valid subset.">fc_isSubsetValid</a>(subset) || !numSubset || 
<a name="l00802"></a>00802       (!newSubsets &amp;&amp; varname) || (newSubsets &amp;&amp; !varname))
<a name="l00803"></a>00803        <span class="comment">//couldnt get xor (^) to work</span>
<a name="l00804"></a>00804     {
<a name="l00805"></a>00805     <a class="code" href="group__Library.html#g1473e77471cd1319f76eb9a32e4ad91f" title="Print an error message to stderr.">fc_printfErrorMessage</a>(<span class="stringliteral">"%s"</span>, <a class="code" href="group__DataTypes.html#g510d74cc1e13d4cdc5bde247a25d48e4" title="Return the name of the FC_ReturnCode&amp;#39;s value.">fc_getReturnCodeText</a>(<a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce464a3d55131c355cdf036f95d0d7e1a6e">FC_INPUT_ERROR</a>));
<a name="l00806"></a>00806     <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce464a3d55131c355cdf036f95d0d7e1a6e">FC_INPUT_ERROR</a>;
<a name="l00807"></a>00807   }
<a name="l00808"></a>00808 
<a name="l00809"></a>00809   <span class="comment">// no - dont limit this to elems</span>
<a name="l00810"></a>00810   <span class="comment">//NOTE: next two test sections copied from getExposedSkin above </span>
<a name="l00811"></a>00811   <span class="comment">//  rc = fc_getSubsetInfo(subset, &amp;numMember, &amp;maxNumMember, &amp;in_assoc);</span>
<a name="l00812"></a>00812   <span class="comment">//  if (rc != FC_SUCCESS)</span>
<a name="l00813"></a>00813   <span class="comment">//    return rc;</span>
<a name="l00814"></a>00814   <span class="comment">//</span>
<a name="l00815"></a>00815   <span class="comment">//  if (in_assoc != FC_AT_ELEMENT &amp;&amp; in_assoc != FC_AT_WHOLE_MESH) {</span>
<a name="l00816"></a>00816   <span class="comment">//    fc_printfErrorMessage("Subset must have element or whole association");</span>
<a name="l00817"></a>00817   <span class="comment">//    return FC_INPUT_ERROR;</span>
<a name="l00818"></a>00818   <span class="comment">//  }</span>
<a name="l00819"></a>00819 
<a name="l00820"></a>00820   <a class="code" href="group__Library.html#g7e9664a8765cc08c313df880421c496b" title="Print a log message to stdout.">fc_printfLogMessage</a>(<span class="stringliteral">"subsetSegmentsMesh"</span>);
<a name="l00821"></a>00821 
<a name="l00822"></a>00822   
<a name="l00823"></a>00823   tempname = varname ? varname : <span class="stringliteral">"temp_subset"</span>;
<a name="l00824"></a>00824 
<a name="l00825"></a>00825   <span class="comment">//this works for empty subset</span>
<a name="l00826"></a>00826   rc = <a class="code" href="group__Subset.html#g3a49a5ba4d326c47af68da14be364bf8" title="Create subset containing complement of the subset (NOT operator).">fc_createSubsetComplement</a>(subset,tempname, &amp;tempSubset);
<a name="l00827"></a>00827   <span class="keywordflow">if</span> (rc != <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce46687acb19dbc2e15e6e89cdc39e8e18e">FC_SUCCESS</a>){
<a name="l00828"></a>00828     <span class="keywordflow">return</span> rc;
<a name="l00829"></a>00829   }
<a name="l00830"></a>00830 
<a name="l00831"></a>00831   <span class="keywordflow">if</span> (newSubsets){ <span class="comment">//even though this is more code, onyl 1 if check </span>
<a name="l00832"></a>00832     <span class="comment">//to determine the arg and do the delete, vs doing a temp</span>
<a name="l00833"></a>00833     <span class="comment">//pts variable like i did for the name above and then</span>
<a name="l00834"></a>00834     <span class="comment">//having to check again for the delete</span>
<a name="l00835"></a>00835     rc = <a class="code" href="group__TopologyRelations.html#g45c86dc9ebd4835c3f96efdf2a6003d9" title="Created separate connected components.">fc_segment</a>(tempSubset,shared_segdim, numSubset,newSubsets);
<a name="l00836"></a>00836     <span class="keywordflow">if</span> (rc != <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce46687acb19dbc2e15e6e89cdc39e8e18e">FC_SUCCESS</a>){
<a name="l00837"></a>00837       <a class="code" href="group__Subset.html#g550d0636e4f35c29d6dbc427b3165a24" title="Delete a subset.">fc_deleteSubset</a>(tempSubset);
<a name="l00838"></a>00838       <span class="keywordflow">return</span> rc;
<a name="l00839"></a>00839     }
<a name="l00840"></a>00840   } <span class="keywordflow">else</span> {
<a name="l00841"></a>00841     rc = <a class="code" href="group__TopologyRelations.html#g45c86dc9ebd4835c3f96efdf2a6003d9" title="Created separate connected components.">fc_segment</a>(tempSubset,shared_segdim, numSubset,&amp;tempsubarray);
<a name="l00842"></a>00842     <span class="keywordflow">if</span> (rc != <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce46687acb19dbc2e15e6e89cdc39e8e18e">FC_SUCCESS</a>){
<a name="l00843"></a>00843       <a class="code" href="group__Subset.html#g550d0636e4f35c29d6dbc427b3165a24" title="Delete a subset.">fc_deleteSubset</a>(tempSubset);
<a name="l00844"></a>00844       <span class="keywordflow">return</span> rc;
<a name="l00845"></a>00845     }
<a name="l00846"></a>00846     <span class="keywordflow">for</span> (i = 0; i &lt; *numSubset; i++){
<a name="l00847"></a>00847       <a class="code" href="group__Subset.html#g550d0636e4f35c29d6dbc427b3165a24" title="Delete a subset.">fc_deleteSubset</a>(tempsubarray[i]);
<a name="l00848"></a>00848     }
<a name="l00849"></a>00849     free(tempsubarray);
<a name="l00850"></a>00850   }
<a name="l00851"></a>00851 
<a name="l00852"></a>00852   <span class="comment">//clean up</span>
<a name="l00853"></a>00853   <a class="code" href="group__Subset.html#g550d0636e4f35c29d6dbc427b3165a24" title="Delete a subset.">fc_deleteSubset</a>(tempSubset);
<a name="l00854"></a>00854 
<a name="l00855"></a>00855   <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce46687acb19dbc2e15e6e89cdc39e8e18e">FC_SUCCESS</a>;
<a name="l00856"></a>00856 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="g666b97bf9ae5501aa0e296436f6dec7b"></a><!-- doxytag: member="elemdeath.c::fc_subsetSegmentsSubset" ref="g666b97bf9ae5501aa0e296436f6dec7b" args="(FC_Subset subset_inner, FC_Subset subset_outer, int shared_segdim, char *varname, int *numSubset, FC_Subset **newSubsets)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DataTypes.html#g2a40aa471d085988d5b582669f766ce4">FC_ReturnCode</a> fc_subsetSegmentsSubset           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFC__Subset.html">FC_Subset</a>&nbsp;</td>
          <td class="paramname"> <em>subset_inner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structFC__Subset.html">FC_Subset</a>&nbsp;</td>
          <td class="paramname"> <em>subset_outer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>shared_segdim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>varname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>numSubset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structFC__Subset.html">FC_Subset</a> **&nbsp;</td>
          <td class="paramname"> <em>newSubsets</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
returns the segments (and their number) that result from segmenting a subset by another subset. 
<p>
<b>Description:</b> <p>
Returns the segments (and their number) that result from segmenting a subset by another subset. If you dont want the segment array, then newSubsets and varname are optional parameters. If you do want the segments, they will be named as the varname parameter postpended with "_Seg#" where # will be the index into the array of returned subsets. Note: this is not the additional number of segments that result, but the total - that is,<p>
Returns -1 in case of error. If the outer subset is empty or MULL this returns with an error. If the inner subset is empty or NULL this is not an error, unlike fc_exposedSkin. Both subsets must have the same association and be on the same mesh. See <a class="el" href="group__TopologyRelations.html#g45c86dc9ebd4835c3f96efdf2a6003d9">fc_segment</a> for restrictions on the segmentation dimension.<p>
One can pass in subsets that have nothing to do with dead cells as well, of course, but we anticipate that this will be most often used with a dead region. If the number of returned segments &gt; the original number of segments then the inner subset has broken the outer. If the number of returned segments = 0 then the inner subset has consumed the outer, and therefore may also be considered to have broken the outer.<p>
This is the subset equivalent of <a class="el" href="group__ElemDeath.html#g332e59c8a844757b89063201843da456">fc_subsetSegmentsMesh</a><p>
<dl compact><dt><b><a class="el" href="todo.html#_todo000008">Todo:</a></b></dt><dd><ul>
<li>test this for things other than elem</li></ul>
</dd></dl>
<b>Modifications:</b> <ul>
<li>2/23/06 ACG created </li></ul>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>subset_inner</em>&nbsp;</td><td>
input - subset that cuases the segmentation </td></tr>
<tr><td valign="top"><em>subset_outer</em>&nbsp;</td><td>
input - subset being segmented </td></tr>
<tr><td valign="top"><em>shared_segdim</em>&nbsp;</td><td>
input - shared dim for segmentation </td></tr>
<tr><td valign="top"><em>varname</em>&nbsp;</td><td>
input - prefix for returned segments (optional) </td></tr>
<tr><td valign="top"><em>numSubset</em>&nbsp;</td><td>
output - number of resulting segments </td></tr>
<tr><td valign="top"><em>newSubsets</em>&nbsp;</td><td>
output - array of resulting segments (optional) </td></tr>
</table>
</dl>
<p>Definition at line <a class="el" href="elemdeath_8c-source.html#l00898">898</a> of file <a class="el" href="elemdeath_8c-source.html">elemdeath.c</a>.</p>

<p>References <a class="el" href="subset_8c-source.html#l00351">fc_copySubset()</a>, <a class="el" href="subset_8c-source.html#l02249">fc_deleteArrayMembersFromSubset()</a>, <a class="el" href="subset_8c-source.html#l02482">fc_deleteSubset()</a>, <a class="el" href="subset_8c-source.html#l02741">fc_getMeshFromSubset()</a>, <a class="el" href="base_8c-source.html#l00355">fc_getReturnCodeText()</a>, <a class="el" href="subset_8c-source.html#l02782">fc_getSubsetInfo()</a>, <a class="el" href="subset_8c-source.html#l03001">fc_getSubsetMembersAsArray()</a>, <a class="el" href="base_8h-source.html#l00319">FC_HANDLE_EQUIV</a>, <a class="el" href="base_8h-source.html#l00107">FC_INPUT_ERROR</a>, <a class="el" href="subset_8c-source.html#l02622">fc_isSubsetValid()</a>, <a class="el" href="base_8c-source.html#l00784">FC_NULL_SUBSET</a>, <a class="el" href="library_8h-source.html#l00120">fc_printfErrorMessage</a>, <a class="el" href="topo_8c-source.html#l01432">fc_segment()</a>, and <a class="el" href="base_8h-source.html#l00104">FC_SUCCESS</a>.</p>

<p>Referenced by <a class="el" href="screwBreaks_8c-source.html#l00652">broken()</a>, and <a class="el" href="tears_8c-source.html#l00686">calcShapeIntersection()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00906"></a>00906  {
<a name="l00907"></a>00907   <a class="code" href="group__DataTypes.html#g2a40aa471d085988d5b582669f766ce4" title="Possible function return values.">FC_ReturnCode</a> rc1, rc2;
<a name="l00908"></a>00908   <a class="code" href="structFC__Subset.html" title="Subset Handle.">FC_Subset</a> tempSubset,*tempsubarray;
<a name="l00909"></a>00909   <a class="code" href="structFC__Mesh.html" title="Mesh Handle.">FC_Mesh</a> mesh_inner, mesh_outer;
<a name="l00910"></a>00910   <a class="code" href="group__DataTypes.html#g28b7cdba59395ddc988888d01dd19af6" title="Possible association of the data to the mesh.">FC_AssociationType</a> assoc_inner, assoc_outer;
<a name="l00911"></a>00911   <span class="keywordtype">int</span> numMember_inner, numMember_outer;
<a name="l00912"></a>00912   <span class="keywordtype">int</span> maxNumMember_inner, maxNumMember_outer;
<a name="l00913"></a>00913   <span class="keywordtype">int</span> i;
<a name="l00914"></a>00914   <span class="keywordtype">char</span>* tempname;
<a name="l00915"></a>00915 
<a name="l00916"></a>00916   <span class="comment">// default returns</span>
<a name="l00917"></a>00917   <span class="keywordflow">if</span> (numSubset)
<a name="l00918"></a>00918     *numSubset = -1;
<a name="l00919"></a>00919   <span class="keywordflow">if</span> (newSubsets)
<a name="l00920"></a>00920     *newSubsets = NULL;
<a name="l00921"></a>00921 
<a name="l00922"></a>00922 
<a name="l00923"></a>00923   <span class="comment">// Test input. (shared_segdim checked in fc_segment)</span>
<a name="l00924"></a>00924   <span class="keywordflow">if</span> (!<a class="code" href="group__Subset.html#g63bf248cb60435e458ea038036d6af90" title="Check that the handle refers to a valid subset.">fc_isSubsetValid</a>(subset_inner) ||!<a class="code" href="group__Subset.html#g63bf248cb60435e458ea038036d6af90" title="Check that the handle refers to a valid subset.">fc_isSubsetValid</a>(subset_outer) ||
<a name="l00925"></a>00925       !numSubset || (!newSubsets &amp;&amp; varname) ||(newSubsets &amp;&amp; !varname)){
<a name="l00926"></a>00926     <a class="code" href="group__Library.html#g1473e77471cd1319f76eb9a32e4ad91f" title="Print an error message to stderr.">fc_printfErrorMessage</a>(<span class="stringliteral">"%s"</span>, <a class="code" href="group__DataTypes.html#g510d74cc1e13d4cdc5bde247a25d48e4" title="Return the name of the FC_ReturnCode&amp;#39;s value.">fc_getReturnCodeText</a>(<a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce464a3d55131c355cdf036f95d0d7e1a6e">FC_INPUT_ERROR</a>));
<a name="l00927"></a>00927     <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce464a3d55131c355cdf036f95d0d7e1a6e">FC_INPUT_ERROR</a>;
<a name="l00928"></a>00928   }
<a name="l00929"></a>00929 
<a name="l00930"></a>00930   rc1 = <a class="code" href="group__Subset.html#gddbb3a2f8c43289a3c3754f1546462bc" title="Get the parent mesh of the subset.">fc_getMeshFromSubset</a>(subset_inner,&amp;mesh_inner);
<a name="l00931"></a>00931   rc2 = <a class="code" href="group__Subset.html#gddbb3a2f8c43289a3c3754f1546462bc" title="Get the parent mesh of the subset.">fc_getMeshFromSubset</a>(subset_outer,&amp;mesh_outer);
<a name="l00932"></a>00932   <span class="keywordflow">if</span> (rc1 != <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce46687acb19dbc2e15e6e89cdc39e8e18e">FC_SUCCESS</a>)
<a name="l00933"></a>00933     <span class="keywordflow">return</span> rc1;
<a name="l00934"></a>00934   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rc2 != <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce46687acb19dbc2e15e6e89cdc39e8e18e">FC_SUCCESS</a>)
<a name="l00935"></a>00935     <span class="keywordflow">return</span> rc2;
<a name="l00936"></a>00936   <span class="keywordflow">if</span> (!<a class="code" href="group__Handles.html#g390004fca0870147d490f32c55afab8d" title="Check two handles for equality.">FC_HANDLE_EQUIV</a>(mesh_outer, mesh_inner)){
<a name="l00937"></a>00937     <a class="code" href="group__Library.html#g1473e77471cd1319f76eb9a32e4ad91f" title="Print an error message to stderr.">fc_printfErrorMessage</a>(<span class="stringliteral">"Subsets must be on same mesh"</span>);
<a name="l00938"></a>00938     <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce464a3d55131c355cdf036f95d0d7e1a6e">FC_INPUT_ERROR</a>;
<a name="l00939"></a>00939   }
<a name="l00940"></a>00940 
<a name="l00941"></a>00941   rc1 = <a class="code" href="group__Subset.html#g815857d0e2d573d0418a3892229c0d83" title="Get information about a subset.">fc_getSubsetInfo</a>(subset_inner, &amp;numMember_inner, &amp;maxNumMember_inner, &amp;assoc_inner);
<a name="l00942"></a>00942   rc2 = <a class="code" href="group__Subset.html#g815857d0e2d573d0418a3892229c0d83" title="Get information about a subset.">fc_getSubsetInfo</a>(subset_outer, &amp;numMember_outer, &amp;maxNumMember_outer, &amp;assoc_outer);
<a name="l00943"></a>00943   <span class="keywordflow">if</span> (rc1 != <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce46687acb19dbc2e15e6e89cdc39e8e18e">FC_SUCCESS</a>)
<a name="l00944"></a>00944     <span class="keywordflow">return</span> rc1;
<a name="l00945"></a>00945   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rc2 != <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce46687acb19dbc2e15e6e89cdc39e8e18e">FC_SUCCESS</a>)
<a name="l00946"></a>00946     <span class="keywordflow">return</span> rc2;
<a name="l00947"></a>00947 
<a name="l00948"></a>00948   <span class="keywordflow">if</span> (<a class="code" href="group__Handles.html#g390004fca0870147d490f32c55afab8d" title="Check two handles for equality.">FC_HANDLE_EQUIV</a>(subset_outer, <a class="code" href="group__Handles.html#gd007f5eb6e7e7f2febca17b53420fd15" title="Null (default) subset handle.">FC_NULL_SUBSET</a>) || numMember_outer == 0){
<a name="l00949"></a>00949     <a class="code" href="group__Library.html#g1473e77471cd1319f76eb9a32e4ad91f" title="Print an error message to stderr.">fc_printfErrorMessage</a>(<span class="stringliteral">"Outer subset cannot be empty or NULL "</span>);
<a name="l00950"></a>00950     <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce464a3d55131c355cdf036f95d0d7e1a6e">FC_INPUT_ERROR</a>;
<a name="l00951"></a>00951   }
<a name="l00952"></a>00952 
<a name="l00953"></a>00953   <span class="comment">//  if (assoc_inner != FC_AT_ELEMENT || assoc_outer != FC_AT_ELEMENT) {</span>
<a name="l00954"></a>00954   <span class="comment">//    fc_printfErrorMessage("Subsets must have element assoc ");</span>
<a name="l00955"></a>00955   <span class="comment">//    return FC_INPUT_ERROR;</span>
<a name="l00956"></a>00956   <span class="comment">//  }</span>
<a name="l00957"></a>00957 
<a name="l00958"></a>00958   <span class="keywordflow">if</span> (assoc_inner !=  assoc_outer) {
<a name="l00959"></a>00959     <a class="code" href="group__Library.html#g1473e77471cd1319f76eb9a32e4ad91f" title="Print an error message to stderr.">fc_printfErrorMessage</a>(<span class="stringliteral">"Subsets must have same assoc "</span>);
<a name="l00960"></a>00960     <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce464a3d55131c355cdf036f95d0d7e1a6e">FC_INPUT_ERROR</a>;
<a name="l00961"></a>00961   }
<a name="l00962"></a>00962 
<a name="l00963"></a>00963   tempname = varname ? varname : <span class="stringliteral">"temp_subset"</span>;
<a name="l00964"></a>00964 
<a name="l00965"></a>00965 
<a name="l00966"></a>00966   rc1 = <a class="code" href="group__Subset.html#g8c233583d14e8205bbfe4aca0d196772" title="Copy subset to a new subset.">fc_copySubset</a>(subset_outer,mesh_outer,tempname, &amp;tempSubset);
<a name="l00967"></a>00967   <span class="keywordflow">if</span> (rc1 != <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce46687acb19dbc2e15e6e89cdc39e8e18e">FC_SUCCESS</a>)
<a name="l00968"></a>00968     <span class="keywordflow">return</span> rc1;
<a name="l00969"></a>00969   <span class="keywordflow">if</span> (!<a class="code" href="group__Handles.html#g390004fca0870147d490f32c55afab8d" title="Check two handles for equality.">FC_HANDLE_EQUIV</a>(subset_inner,<a class="code" href="group__Handles.html#gd007f5eb6e7e7f2febca17b53420fd15" title="Null (default) subset handle.">FC_NULL_SUBSET</a>) &amp;&amp; !numMember_inner == 0){
<a name="l00970"></a>00970     <span class="keywordtype">int</span>* array;
<a name="l00971"></a>00971 
<a name="l00972"></a>00972     rc1 = <a class="code" href="group__Subset.html#g6cebfda6e20e2a518636838b170185da" title="Get a copy of subset members as array.">fc_getSubsetMembersAsArray</a>(subset_inner, &amp;numMember_inner, &amp;array);
<a name="l00973"></a>00973     <span class="keywordflow">if</span> (rc1 != <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce46687acb19dbc2e15e6e89cdc39e8e18e">FC_SUCCESS</a>)
<a name="l00974"></a>00974       <span class="keywordflow">return</span> rc1;
<a name="l00975"></a>00975     rc1 = <a class="code" href="group__Subset.html#g581838fadfd530107eefe1560d58c027" title="Delete array members from a subset.">fc_deleteArrayMembersFromSubset</a>(tempSubset, numMember_inner, array);
<a name="l00976"></a>00976     <span class="keywordflow">if</span> (rc1 != <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce46687acb19dbc2e15e6e89cdc39e8e18e">FC_SUCCESS</a>)
<a name="l00977"></a>00977       <span class="keywordflow">return</span> rc1;
<a name="l00978"></a>00978     free(array);
<a name="l00979"></a>00979   }
<a name="l00980"></a>00980 
<a name="l00981"></a>00981   <span class="keywordflow">if</span> (newSubsets){ <span class="comment">//even though this is more code, onyl 1 if check </span>
<a name="l00982"></a>00982     <span class="comment">//to determine the arg and do the delete, vs doing a temp</span>
<a name="l00983"></a>00983     <span class="comment">//pts variable like i did for the name above and then</span>
<a name="l00984"></a>00984     <span class="comment">//having to check again for the delete</span>
<a name="l00985"></a>00985     rc1 = <a class="code" href="group__TopologyRelations.html#g45c86dc9ebd4835c3f96efdf2a6003d9" title="Created separate connected components.">fc_segment</a>(tempSubset,shared_segdim, numSubset,newSubsets);
<a name="l00986"></a>00986     <span class="keywordflow">if</span> (rc1 != <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce46687acb19dbc2e15e6e89cdc39e8e18e">FC_SUCCESS</a>){
<a name="l00987"></a>00987       <a class="code" href="group__Subset.html#g550d0636e4f35c29d6dbc427b3165a24" title="Delete a subset.">fc_deleteSubset</a>(tempSubset);
<a name="l00988"></a>00988       <span class="keywordflow">return</span> rc1;
<a name="l00989"></a>00989     }
<a name="l00990"></a>00990   } <span class="keywordflow">else</span> {
<a name="l00991"></a>00991     rc1 = <a class="code" href="group__TopologyRelations.html#g45c86dc9ebd4835c3f96efdf2a6003d9" title="Created separate connected components.">fc_segment</a>(tempSubset,shared_segdim, numSubset,&amp;tempsubarray);
<a name="l00992"></a>00992     <span class="keywordflow">if</span> (rc1 != <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce46687acb19dbc2e15e6e89cdc39e8e18e">FC_SUCCESS</a>){
<a name="l00993"></a>00993       <a class="code" href="group__Subset.html#g550d0636e4f35c29d6dbc427b3165a24" title="Delete a subset.">fc_deleteSubset</a>(tempSubset);
<a name="l00994"></a>00994       <span class="keywordflow">return</span> rc1;
<a name="l00995"></a>00995     }
<a name="l00996"></a>00996     <span class="keywordflow">for</span> (i = 0; i &lt; *numSubset; i++){
<a name="l00997"></a>00997       <a class="code" href="group__Subset.html#g550d0636e4f35c29d6dbc427b3165a24" title="Delete a subset.">fc_deleteSubset</a>(tempsubarray[i]);
<a name="l00998"></a>00998     }
<a name="l00999"></a>00999     free(tempsubarray);
<a name="l01000"></a>01000   }
<a name="l01001"></a>01001 
<a name="l01002"></a>01002   <span class="comment">//clean up</span>
<a name="l01003"></a>01003   <a class="code" href="group__Subset.html#g550d0636e4f35c29d6dbc427b3165a24" title="Delete a subset.">fc_deleteSubset</a>(tempSubset);
<a name="l01004"></a>01004 
<a name="l01005"></a>01005   <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce46687acb19dbc2e15e6e89cdc39e8e18e">FC_SUCCESS</a>;
<a name="l01006"></a>01006 }
</pre></div>
<p>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Mon Oct 27 13:26:19 2008 for FCLib by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
