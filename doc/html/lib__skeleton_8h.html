<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>FCLib: tools/skeleton/lib_skeleton.h File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="classes.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>tools/skeleton/lib_skeleton.h File Reference</h1>
<p>

<p>
<div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dynsection">
<p><center><img src="lib__skeleton_8h__dep__incl.gif" border="0" usemap="#tools/skeleton/lib_skeleton.hdep_map" alt=""></center>
<map name="tools/skeleton/lib_skeleton.hdep_map">
<area shape="rect" href="build__ensemble_8c.html" title="tools/skeleton/build_ensemble.c" alt="" coords="5,84,256,111"><area shape="rect" href="generate__tree_8c.html" title="tools/skeleton/generate_tree.c" alt="" coords="280,84,520,111"><area shape="rect" href="lib__skeleton_8c.html" title="tools/skeleton/lib_skeleton.c" alt="" coords="544,84,765,111"><area shape="rect" href="whittle__tree_8c.html" title="tools/skeleton/whittle_tree.c" alt="" coords="789,84,1011,111"></map>
</div>

<p>
<a href="lib__skeleton_8h-source.html">Go to the source code of this file.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspanning__tree__node__t.html">spanning_tree_node_t</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspanning__tree__t.html">spanning_tree_t</a></td></tr>

<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lib__skeleton_8h.html#86d286aba1a39e49e5acb2d860e0fe84">emsg</a>(a, args...)&nbsp;&nbsp;&nbsp;{fprintf(stderr,&quot;Error in %s()[%s:%d] &quot; a &quot;\n&quot;, __func__, __FILE__, __LINE__, ## args); exit(-1); }</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lib__skeleton_8h.html#15989531a38db782bfe33ebed139dad7">dbg</a>(a, args...)&nbsp;&nbsp;&nbsp;{ if(<a class="el" href="lib__skeleton_8h.html#733f286889c9c15dcbfddcf65b28290d">_skeleton_dbg</a>&gt;1) printf(&quot;DBG:&quot; a &quot;\n&quot;, ## args); }</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lib__skeleton_8h.html#0017ada9be12f3b512275e039cff6f26">info</a>(a, args...)&nbsp;&nbsp;&nbsp;{ if(<a class="el" href="lib__skeleton_8h.html#733f286889c9c15dcbfddcf65b28290d">_skeleton_dbg</a>)   printf(a &quot;\n&quot;, ## args); }</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lib__skeleton_8h.html#834f31033781e091a3dbdfe16f7e8285">FREE</a>(a)&nbsp;&nbsp;&nbsp;{ if(!a) emsg(&quot;Free on NULL pointer?&quot;); free(a); a=NULL; }</td></tr>

<tr><td colspan="2"><br><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lib__skeleton_8h.html#e8816f1d3f4ad9da003a2123bda65c0e">whittleAlgorithm_t</a> { <br>
&nbsp;&nbsp;<a class="el" href="lib__skeleton_8h.html#e8816f1d3f4ad9da003a2123bda65c0e2ffdcd095fbdb569f7125bc08db08162">FC_WA_UNKNOWN</a> =  -1, 
<br>
&nbsp;&nbsp;<a class="el" href="lib__skeleton_8h.html#e8816f1d3f4ad9da003a2123bda65c0e60e55e13721c9628dc932147834f3a25">FC_WA_UNSPECIFIED</a> =  0, 
<br>
&nbsp;&nbsp;<a class="el" href="lib__skeleton_8h.html#e8816f1d3f4ad9da003a2123bda65c0e13314f2f047ef7babc50d4783fed7308">FC_WA_OCTANTS</a> =  1, 
<br>
&nbsp;&nbsp;<a class="el" href="lib__skeleton_8h.html#e8816f1d3f4ad9da003a2123bda65c0e74d840c1a76d5638ed42259ac2d11db8">FC_WA_MIN_DESCENDANTS</a> =  2, 
<br>
&nbsp;&nbsp;<a class="el" href="lib__skeleton_8h.html#e8816f1d3f4ad9da003a2123bda65c0e9bc01b48a2e49f9743e4f9a423ac7ee9">FC_WA_MIN_SEGMENT_LENGTHS</a> =  3, 
<br>
&nbsp;&nbsp;<a class="el" href="lib__skeleton_8h.html#e8816f1d3f4ad9da003a2123bda65c0e9fa17d3a07983a98e01afdd865792d42">FC_WA_MIN_ANGLE_CHANGE</a> =  4
<br>
 }</td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lib__skeleton_8h.html#73e9c7cf3c7be3b4925a1e1e5dd10593">_fc_compareSpanningTreeNodes</a> (const void *a, const void *b)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DataTypes.html#g2a40aa471d085988d5b582669f766ce4">FC_ReturnCode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lib__skeleton_8h.html#23c5542a94ebd3ac35089b5a82d172a5">_fc_getIntersectionPointBetweenElements</a> (int elemID_1, int elemID_2, int dim, int vertPerElement, int *conn_list, double *verts, <a class="el" href="group__SimpleDataObjects.html#gf0a2bdabac4a21b42f4b480baf9128d7">FC_Coords</a> *results)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lib__skeleton_8h.html#01a08f714eaaf8313f3b0d4191deed40">doesSeqVarExist</a> (<a class="el" href="structFC__Mesh.html">FC_Mesh</a> m, char *seqvar_name)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DataTypes.html#g2a40aa471d085988d5b582669f766ce4">FC_ReturnCode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lib__skeleton_8h.html#3764a93ca0b255a7955d588ff5f2c2b6">fc_getElementCenters</a> (<a class="el" href="structFC__Mesh.html">FC_Mesh</a> m, <a class="el" href="structFC__Variable.html">FC_Variable</a> displ, double **centers)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lib__skeleton_8h.html#248d921501f4739e2562082945e4e9de">printTree</a> (<a class="el" href="structspanning__tree__t.html">spanning_tree_t</a> *t, int include_nodes)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DataTypes.html#g2a40aa471d085988d5b582669f766ce4">FC_ReturnCode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lib__skeleton_8h.html#1bbd7a44f7bed3ef955121c22434dca3">fc_computeTreeDistances</a> (<a class="el" href="structspanning__tree__t.html">spanning_tree_t</a> *t)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DataTypes.html#g2a40aa471d085988d5b582669f766ce4">FC_ReturnCode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lib__skeleton_8h.html#dd3df4be2e7ca2ba3f19258cffb2e08a">fc_computeTreeDescendantsAncestors</a> (<a class="el" href="structspanning__tree__t.html">spanning_tree_t</a> *tree)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DataTypes.html#g2a40aa471d085988d5b582669f766ce4">FC_ReturnCode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lib__skeleton_8h.html#cda51e71e5503db42ef14e39a1646c57">fc_makeSpanningTree</a> (<a class="el" href="structFC__Mesh.html">FC_Mesh</a> m, int starting_element_id, <a class="el" href="structspanning__tree__t.html">spanning_tree_t</a> **tree)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DataTypes.html#g2a40aa471d085988d5b582669f766ce4">FC_ReturnCode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lib__skeleton_8h.html#eff58d67e5060be9f0f284711530c02b">fc_saveSkeleton</a> (<a class="el" href="structspanning__tree__t.html">spanning_tree_t</a> tree, char *displacement_var_name, char *<a class="el" href="subsetter_8c.html#8505c513bc640d1f69e5f76fb32b24a8">file_name</a>)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DataTypes.html#g2a40aa471d085988d5b582669f766ce4">FC_ReturnCode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lib__skeleton_8h.html#a0ec845ef4749dd88d295e8f407ac582">fc_convertTreeToMesh</a> (<a class="el" href="structFC__Dataset.html">FC_Dataset</a> <a class="el" href="subsetter_8c.html#5470d1fe286b8864424987862ea74aae">ds</a>, <a class="el" href="structspanning__tree__t.html">spanning_tree_t</a> tree, char *mesh_name, char *displacement_var_name, <a class="el" href="structFC__Mesh.html">FC_Mesh</a> *mesh_out)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DataTypes.html#g2a40aa471d085988d5b582669f766ce4">FC_ReturnCode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lib__skeleton_8h.html#1f8a114a3c3842487b9de9aa9a9fd1ae">replicateSpanningTreeWithMask</a> (<a class="el" href="structspanning__tree__t.html">spanning_tree_t</a> *ti, char *mask, <a class="el" href="structspanning__tree__t.html">spanning_tree_t</a> **to)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DataTypes.html#g2a40aa471d085988d5b582669f766ce4">FC_ReturnCode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lib__skeleton_8h.html#3a87b0160af49f652c2d68f1a89f4fda">replicateSpanningTree</a> (<a class="el" href="structspanning__tree__t.html">spanning_tree_t</a> *ti, <a class="el" href="structspanning__tree__t.html">spanning_tree_t</a> **to)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DataTypes.html#g2a40aa471d085988d5b582669f766ce4">FC_ReturnCode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lib__skeleton_8h.html#b5c9306837e2cd641fe31648e1a3d8cd">treeTagNodesAncestorsMask</a> (<a class="el" href="structspanning__tree__t.html">spanning_tree_t</a> *ti, int node_id, char *mask)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lib__skeleton_8h.html#86855ab9e0052da9fc707bdab89f654c">whittleSkeletonByNumDescendents</a> (<a class="el" href="structspanning__tree__t.html">spanning_tree_t</a> *ti, int min, <a class="el" href="structspanning__tree__t.html">spanning_tree_t</a> **to)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lib__skeleton_8h.html#52797a8bfd7f87a6b7885e7d7d899164">whittleSkeletonOctants</a> (<a class="el" href="structspanning__tree__t.html">spanning_tree_t</a> *ti, int per_oct, <a class="el" href="structspanning__tree__t.html">spanning_tree_t</a> **to)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lib__skeleton_8h.html#eee1feae7f79973980a4240ba7927336">whittleSkeletonBySegmentLengths</a> (<a class="el" href="structspanning__tree__t.html">spanning_tree_t</a> *ti, <a class="el" href="structspanning__tree__t.html">spanning_tree_t</a> **to)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lib__skeleton_8h.html#c37ad820c3b0940495acdd8a8fba3381">whittleSkeletonByDullestAngles</a> (<a class="el" href="structspanning__tree__t.html">spanning_tree_t</a> *ti, <a class="el" href="structspanning__tree__t.html">spanning_tree_t</a> **to)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DataTypes.html#g2a40aa471d085988d5b582669f766ce4">FC_ReturnCode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lib__skeleton_8h.html#c60a857709aa48fcb4a3675296525afb">whittleSkeleton</a> (<a class="el" href="structspanning__tree__t.html">spanning_tree_t</a> *ti, <a class="el" href="lib__skeleton_8h.html#e8816f1d3f4ad9da003a2123bda65c0e">whittleAlgorithm_t</a> wtype, double desired_remaining_fraction, <a class="el" href="structspanning__tree__t.html">spanning_tree_t</a> **to)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lib__skeleton_8h.html#e469928ca4475c0849c9f604db071a85">fc_unpackSkeletonFromMesh</a> (<a class="el" href="structFC__Mesh.html">FC_Mesh</a> m, <a class="el" href="structspanning__tree__t.html">spanning_tree_t</a> **tptr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="lib__skeleton_8h.html#e8816f1d3f4ad9da003a2123bda65c0e">whittleAlgorithm_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lib__skeleton_8h.html#0a6c9b5257f3f6211f6277114e74d678">convertStringToWhittleAlg</a> (char *s)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lib__skeleton_8h.html#c1977d3330108bced4fedc5c63f6a355">convertWhittleAlgToString</a> (<a class="el" href="lib__skeleton_8h.html#e8816f1d3f4ad9da003a2123bda65c0e">whittleAlgorithm_t</a> w)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lib__skeleton_8h.html#4bfc93887121689d8263fbf6a950dc9e">getWhittleAlgorithmName</a> (<a class="el" href="lib__skeleton_8h.html#e8816f1d3f4ad9da003a2123bda65c0e">whittleAlgorithm_t</a> alg_id)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lib__skeleton_8h.html#ac78e2814a6fc9f0fd29535537a2dad7">getNextWhittleAlgorithmDescription</a> (int count, char **name, char **sname, <a class="el" href="lib__skeleton_8h.html#e8816f1d3f4ad9da003a2123bda65c0e">whittleAlgorithm_t</a> *id, char **description)</td></tr>

<tr><td colspan="2"><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lib__skeleton_8h.html#733f286889c9c15dcbfddcf65b28290d">_skeleton_dbg</a></td></tr>

</table>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="15989531a38db782bfe33ebed139dad7"></a><!-- doxytag: member="lib_skeleton.h::dbg" ref="15989531a38db782bfe33ebed139dad7" args="(a, args...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define dbg          </td>
          <td>(</td>
          <td class="paramtype">a,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">args...&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;{ if(<a class="el" href="lib__skeleton_8h.html#733f286889c9c15dcbfddcf65b28290d">_skeleton_dbg</a>&gt;1) printf(&quot;DBG:&quot; a &quot;\n&quot;, ## args); }</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="lib__skeleton_8h-source.html#l00045">45</a> of file <a class="el" href="lib__skeleton_8h-source.html">lib_skeleton.h</a>.</p>

<p>Referenced by <a class="el" href="lib__skeleton_8c-source.html#l00342">fc_makeSpanningTree()</a>, and <a class="el" href="lib__skeleton_8c-source.html#l00651">fc_saveSkeleton()</a>.</p>

</div>
</div><p>
<a class="anchor" name="86d286aba1a39e49e5acb2d860e0fe84"></a><!-- doxytag: member="lib_skeleton.h::emsg" ref="86d286aba1a39e49e5acb2d860e0fe84" args="(a, args...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define emsg          </td>
          <td>(</td>
          <td class="paramtype">a,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">args...&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;{fprintf(stderr,&quot;Error in %s()[%s:%d] &quot; a &quot;\n&quot;, __func__, __FILE__, __LINE__, ## args); exit(-1); }</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="lib__skeleton_8h-source.html#l00044">44</a> of file <a class="el" href="lib__skeleton_8h-source.html">lib_skeleton.h</a>.</p>

<p>Referenced by <a class="el" href="lib__skeleton_8c-source.html#l00208">_getParentIndexForIndex()</a>, <a class="el" href="lib__skeleton_8c-source.html#l00267">fc_computeTreeDescendantsAncestors()</a>, <a class="el" href="lib__skeleton_8c-source.html#l00817">fc_convertTreeToMesh()</a>, <a class="el" href="lib__skeleton_8c-source.html#l00107">fc_getElementCenters()</a>, <a class="el" href="lib__skeleton_8c-source.html#l00651">fc_saveSkeleton()</a>, <a class="el" href="lib__skeleton_8c-source.html#l01146">findNetDistanceChangeWhenRemovingNode()</a>, <a class="el" href="lib__skeleton_8c-source.html#l01291">findSharpestAngleForNodeIndex()</a>, <a class="el" href="build__ensemble_8c-source.html#l00208">getMeshByNameOrDie()</a>, <a class="el" href="build__ensemble_8c-source.html#l00236">main()</a>, and <a class="el" href="build__ensemble_8c-source.html#l00227">mallocOrDie()</a>.</p>

</div>
</div><p>
<a class="anchor" name="834f31033781e091a3dbdfe16f7e8285"></a><!-- doxytag: member="lib_skeleton.h::FREE" ref="834f31033781e091a3dbdfe16f7e8285" args="(a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FREE          </td>
          <td>(</td>
          <td class="paramtype">a&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;{ if(!a) emsg(&quot;Free on NULL pointer?&quot;); free(a); a=NULL; }</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="lib__skeleton_8h-source.html#l00047">47</a> of file <a class="el" href="lib__skeleton_8h-source.html">lib_skeleton.h</a>.</p>

<p>Referenced by <a class="el" href="lib__skeleton_8c-source.html#l00624">doesSeqVarExist()</a>, <a class="el" href="lib__skeleton_8c-source.html#l00107">fc_getElementCenters()</a>, <a class="el" href="lib__skeleton_8c-source.html#l00342">fc_makeSpanningTree()</a>, <a class="el" href="build__ensemble_8c-source.html#l00208">getMeshByNameOrDie()</a>, <a class="el" href="build__ensemble_8c-source.html#l00236">main()</a>, and <a class="el" href="lib__skeleton_8c-source.html#l01567">whittleSkeleton()</a>.</p>

</div>
</div><p>
<a class="anchor" name="0017ada9be12f3b512275e039cff6f26"></a><!-- doxytag: member="lib_skeleton.h::info" ref="0017ada9be12f3b512275e039cff6f26" args="(a, args...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define info          </td>
          <td>(</td>
          <td class="paramtype">a,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">args...&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;{ if(<a class="el" href="lib__skeleton_8h.html#733f286889c9c15dcbfddcf65b28290d">_skeleton_dbg</a>)   printf(a &quot;\n&quot;, ## args); }</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="lib__skeleton_8h-source.html#l00046">46</a> of file <a class="el" href="lib__skeleton_8h-source.html">lib_skeleton.h</a>.</p>

<p>Referenced by <a class="el" href="build__ensemble_8c-source.html#l00122">checkArgs()</a>, <a class="el" href="build__ensemble_8c-source.html#l00078">dumpHelp()</a>, <a class="el" href="lib__skeleton_8c-source.html#l00342">fc_makeSpanningTree()</a>, <a class="el" href="lib__skeleton_8c-source.html#l01519">fc_unpackSkeletonFromMesh()</a>, <a class="el" href="build__ensemble_8c-source.html#l00236">main()</a>, and <a class="el" href="lib__skeleton_8c-source.html#l01567">whittleSkeleton()</a>.</p>

</div>
</div><p>
<hr><h2>Enumeration Type Documentation</h2>
<a class="anchor" name="e8816f1d3f4ad9da003a2123bda65c0e"></a><!-- doxytag: member="lib_skeleton.h::whittleAlgorithm_t" ref="e8816f1d3f4ad9da003a2123bda65c0e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="lib__skeleton_8h.html#e8816f1d3f4ad9da003a2123bda65c0e">whittleAlgorithm_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="e8816f1d3f4ad9da003a2123bda65c0e2ffdcd095fbdb569f7125bc08db08162"></a><!-- doxytag: member="FC_WA_UNKNOWN" ref="e8816f1d3f4ad9da003a2123bda65c0e2ffdcd095fbdb569f7125bc08db08162" args="" -->FC_WA_UNKNOWN</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="e8816f1d3f4ad9da003a2123bda65c0e60e55e13721c9628dc932147834f3a25"></a><!-- doxytag: member="FC_WA_UNSPECIFIED" ref="e8816f1d3f4ad9da003a2123bda65c0e60e55e13721c9628dc932147834f3a25" args="" -->FC_WA_UNSPECIFIED</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="e8816f1d3f4ad9da003a2123bda65c0e13314f2f047ef7babc50d4783fed7308"></a><!-- doxytag: member="FC_WA_OCTANTS" ref="e8816f1d3f4ad9da003a2123bda65c0e13314f2f047ef7babc50d4783fed7308" args="" -->FC_WA_OCTANTS</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="e8816f1d3f4ad9da003a2123bda65c0e74d840c1a76d5638ed42259ac2d11db8"></a><!-- doxytag: member="FC_WA_MIN_DESCENDANTS" ref="e8816f1d3f4ad9da003a2123bda65c0e74d840c1a76d5638ed42259ac2d11db8" args="" -->FC_WA_MIN_DESCENDANTS</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="e8816f1d3f4ad9da003a2123bda65c0e9bc01b48a2e49f9743e4f9a423ac7ee9"></a><!-- doxytag: member="FC_WA_MIN_SEGMENT_LENGTHS" ref="e8816f1d3f4ad9da003a2123bda65c0e9bc01b48a2e49f9743e4f9a423ac7ee9" args="" -->FC_WA_MIN_SEGMENT_LENGTHS</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="e8816f1d3f4ad9da003a2123bda65c0e9fa17d3a07983a98e01afdd865792d42"></a><!-- doxytag: member="FC_WA_MIN_ANGLE_CHANGE" ref="e8816f1d3f4ad9da003a2123bda65c0e9fa17d3a07983a98e01afdd865792d42" args="" -->FC_WA_MIN_ANGLE_CHANGE</em>&nbsp;</td><td>
</td></tr>
</table>
</dl>

<p>Definition at line <a class="el" href="lib__skeleton_8h-source.html#l00050">50</a> of file <a class="el" href="lib__skeleton_8h-source.html">lib_skeleton.h</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00050"></a>00050              {
<a name="l00051"></a>00051   <a class="code" href="lib__skeleton_8h.html#e8816f1d3f4ad9da003a2123bda65c0e2ffdcd095fbdb569f7125bc08db08162">FC_WA_UNKNOWN</a>             = -1,
<a name="l00052"></a>00052   <a class="code" href="lib__skeleton_8h.html#e8816f1d3f4ad9da003a2123bda65c0e60e55e13721c9628dc932147834f3a25">FC_WA_UNSPECIFIED</a>         = 0,
<a name="l00053"></a>00053 
<a name="l00054"></a>00054   <a class="code" href="lib__skeleton_8h.html#e8816f1d3f4ad9da003a2123bda65c0e13314f2f047ef7babc50d4783fed7308">FC_WA_OCTANTS</a>             = 1,
<a name="l00055"></a>00055   <a class="code" href="lib__skeleton_8h.html#e8816f1d3f4ad9da003a2123bda65c0e74d840c1a76d5638ed42259ac2d11db8">FC_WA_MIN_DESCENDANTS</a>     = 2,
<a name="l00056"></a>00056   <a class="code" href="lib__skeleton_8h.html#e8816f1d3f4ad9da003a2123bda65c0e9bc01b48a2e49f9743e4f9a423ac7ee9">FC_WA_MIN_SEGMENT_LENGTHS</a> = 3,
<a name="l00057"></a>00057   <a class="code" href="lib__skeleton_8h.html#e8816f1d3f4ad9da003a2123bda65c0e9fa17d3a07983a98e01afdd865792d42">FC_WA_MIN_ANGLE_CHANGE</a>    = 4  
<a name="l00058"></a>00058 
<a name="l00059"></a>00059 } <a class="code" href="lib__skeleton_8h.html#e8816f1d3f4ad9da003a2123bda65c0e">whittleAlgorithm_t</a>;
</pre></div>
<p>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="73e9c7cf3c7be3b4925a1e1e5dd10593"></a><!-- doxytag: member="lib_skeleton.h::_fc_compareSpanningTreeNodes" ref="73e9c7cf3c7be3b4925a1e1e5dd10593" args="(const void *a, const void *b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int _fc_compareSpanningTreeNodes           </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="23c5542a94ebd3ac35089b5a82d172a5"></a><!-- doxytag: member="lib_skeleton.h::_fc_getIntersectionPointBetweenElements" ref="23c5542a94ebd3ac35089b5a82d172a5" args="(int elemID_1, int elemID_2, int dim, int vertPerElement, int *conn_list, double *verts, FC_Coords *results)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DataTypes.html#g2a40aa471d085988d5b582669f766ce4">FC_ReturnCode</a> _fc_getIntersectionPointBetweenElements           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>elemID_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>elemID_2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>vertPerElement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>conn_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>verts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SimpleDataObjects.html#gf0a2bdabac4a21b42f4b480baf9128d7">FC_Coords</a> *&nbsp;</td>
          <td class="paramname"> <em>results</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="lib__skeleton_8c-source.html#l00166">166</a> of file <a class="el" href="lib__skeleton_8c-source.html">lib_skeleton.c</a>.</p>

<p>References <a class="el" href="base_8h-source.html#l00105">FC_ERROR</a>, and <a class="el" href="base_8h-source.html#l00104">FC_SUCCESS</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00170"></a>00170                                    {
<a name="l00171"></a>00171 
<a name="l00172"></a>00172   <span class="keywordtype">int</span> verts_in_common=0;
<a name="l00173"></a>00173   <a class="code" href="group__SimpleDataObjects.html#gf0a2bdabac4a21b42f4b480baf9128d7" title="Coordinates data structure.">FC_Coords</a> sum = {0.0,0.0,0.0};
<a name="l00174"></a>00174   <span class="keywordtype">int</span> i,j;
<a name="l00175"></a>00175   <span class="keywordtype">int</span> vert_id1;
<a name="l00176"></a>00176 
<a name="l00177"></a>00177   assert(elemID_1&gt;=0);
<a name="l00178"></a>00178   assert(elemID_2&gt;=0);
<a name="l00179"></a>00179 
<a name="l00180"></a>00180 
<a name="l00181"></a>00181   <span class="keywordflow">for</span>(i=0;i&lt;vertPerElement;i++){
<a name="l00182"></a>00182     <span class="comment">//See if the elements share this vert in common</span>
<a name="l00183"></a>00183     vert_id1 = conn_list[elemID_1*vertPerElement+i];
<a name="l00184"></a>00184     <span class="keywordflow">for</span>(j=0; (j&lt;vertPerElement) &amp;&amp; (vert_id1 != conn_list[elemID_2*vertPerElement+j]); j++);
<a name="l00185"></a>00185     <span class="keywordflow">if</span>(j!=vertPerElement){
<a name="l00186"></a>00186       <span class="comment">//This vert is common to both, add it in to the sum</span>
<a name="l00187"></a>00187       <span class="keywordflow">for</span>(j=0;j&lt;dim;j++)
<a name="l00188"></a>00188      sum[j] += verts[ vert_id1 * dim + j];
<a name="l00189"></a>00189   
<a name="l00190"></a>00190       verts_in_common++;
<a name="l00191"></a>00191     }
<a name="l00192"></a>00192   }
<a name="l00193"></a>00193 
<a name="l00194"></a>00194   <span class="keywordflow">if</span>(!verts_in_common) <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce4dfe7727a339a5a362cd2b90d81aeef76">FC_ERROR</a>; <span class="comment">//no intersection point</span>
<a name="l00195"></a>00195 
<a name="l00196"></a>00196   <span class="keywordflow">for</span>(i=0;i&lt;dim;i++)
<a name="l00197"></a>00197     (*results)[i] = sum[i] / (double)verts_in_common;
<a name="l00198"></a>00198 
<a name="l00199"></a>00199   <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce46687acb19dbc2e15e6e89cdc39e8e18e">FC_SUCCESS</a>;  
<a name="l00200"></a>00200 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="0a6c9b5257f3f6211f6277114e74d678"></a><!-- doxytag: member="lib_skeleton.h::convertStringToWhittleAlg" ref="0a6c9b5257f3f6211f6277114e74d678" args="(char *s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="lib__skeleton_8h.html#e8816f1d3f4ad9da003a2123bda65c0e">whittleAlgorithm_t</a> convertStringToWhittleAlg           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>s</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="lib__skeleton_8c-source.html#l00071">71</a> of file <a class="el" href="lib__skeleton_8c-source.html">lib_skeleton.c</a>.</p>

<p>References <a class="el" href="lib__skeleton_8c-source.html#l00057">whittleAlgorithmDescription_t::alg_id</a>, <a class="el" href="lib__skeleton_8h-source.html#l00051">FC_WA_UNKNOWN</a>, <a class="el" href="lib__skeleton_8c-source.html#l00058">whittleAlgorithmDescription_t::name</a>, and <a class="el" href="lib__skeleton_8c-source.html#l00059">whittleAlgorithmDescription_t::shortname</a>.</p>

<p>Referenced by <a class="el" href="build__ensemble_8c-source.html#l00122">checkArgs()</a>, and <a class="el" href="whittle__tree_8c-source.html#l00103">main()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00071"></a>00071                                                      {
<a name="l00072"></a>00072   <a class="code" href="structwhittleAlgorithmDescription__t.html">whittleAlgorithmDescription_t</a> *w;
<a name="l00073"></a>00073 
<a name="l00074"></a>00074   <span class="keywordflow">if</span>(!s) <span class="keywordflow">return</span> <a class="code" href="lib__skeleton_8h.html#e8816f1d3f4ad9da003a2123bda65c0e2ffdcd095fbdb569f7125bc08db08162">FC_WA_UNKNOWN</a>;
<a name="l00075"></a>00075   <span class="keywordflow">for</span>(w=<a class="code" href="lib__skeleton_8c.html#2afaabe4f594132496b9ace1419583e6">whittleAlgorithmDescription</a>; w-&gt;<a class="code" href="structwhittleAlgorithmDescription__t.html#5ba8795146e81aa44d9d6ed8955b42f4">name</a>; w++){
<a name="l00076"></a>00076     <span class="keywordflow">if</span>(!strcasecmp(s, w-&gt;<a class="code" href="structwhittleAlgorithmDescription__t.html#4bb8776dc96d6754f40e73a34778eff9">shortname</a>)) <span class="keywordflow">return</span> w-&gt;<a class="code" href="structwhittleAlgorithmDescription__t.html#b37fefa58a0a8da047b1ff16023a9b6c">alg_id</a>;
<a name="l00077"></a>00077   }
<a name="l00078"></a>00078   <span class="keywordflow">return</span> <a class="code" href="lib__skeleton_8h.html#e8816f1d3f4ad9da003a2123bda65c0e2ffdcd095fbdb569f7125bc08db08162">FC_WA_UNKNOWN</a>;
<a name="l00079"></a>00079 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="c1977d3330108bced4fedc5c63f6a355"></a><!-- doxytag: member="lib_skeleton.h::convertWhittleAlgToString" ref="c1977d3330108bced4fedc5c63f6a355" args="(whittleAlgorithm_t w)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* convertWhittleAlgToString           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lib__skeleton_8h.html#e8816f1d3f4ad9da003a2123bda65c0e">whittleAlgorithm_t</a>&nbsp;</td>
          <td class="paramname"> <em>w</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="lib__skeleton_8c-source.html#l01633">1633</a> of file <a class="el" href="lib__skeleton_8c-source.html">lib_skeleton.c</a>.</p>

<p>References <a class="el" href="lib__skeleton_8h-source.html#l00057">FC_WA_MIN_ANGLE_CHANGE</a>, <a class="el" href="lib__skeleton_8h-source.html#l00055">FC_WA_MIN_DESCENDANTS</a>, <a class="el" href="lib__skeleton_8h-source.html#l00056">FC_WA_MIN_SEGMENT_LENGTHS</a>, <a class="el" href="lib__skeleton_8h-source.html#l00054">FC_WA_OCTANTS</a>, <a class="el" href="lib__skeleton_8h-source.html#l00051">FC_WA_UNKNOWN</a>, and <a class="el" href="lib__skeleton_8h-source.html#l00052">FC_WA_UNSPECIFIED</a>.</p>

<p>Referenced by <a class="el" href="build__ensemble_8c-source.html#l00236">main()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l01633"></a>01633                                                       {
<a name="l01634"></a>01634   <span class="keywordflow">switch</span>(w){
<a name="l01635"></a>01635   <span class="keywordflow">case</span> <a class="code" href="lib__skeleton_8h.html#e8816f1d3f4ad9da003a2123bda65c0e13314f2f047ef7babc50d4783fed7308">FC_WA_OCTANTS</a>:             <span class="keywordflow">return</span> <span class="stringliteral">"FC_WA_OCTANTS"</span>;
<a name="l01636"></a>01636   <span class="keywordflow">case</span> <a class="code" href="lib__skeleton_8h.html#e8816f1d3f4ad9da003a2123bda65c0e74d840c1a76d5638ed42259ac2d11db8">FC_WA_MIN_DESCENDANTS</a>:     <span class="keywordflow">return</span> <span class="stringliteral">"FC_WA_MIN_DESCENDANTS"</span>;
<a name="l01637"></a>01637   <span class="keywordflow">case</span> <a class="code" href="lib__skeleton_8h.html#e8816f1d3f4ad9da003a2123bda65c0e9bc01b48a2e49f9743e4f9a423ac7ee9">FC_WA_MIN_SEGMENT_LENGTHS</a>: <span class="keywordflow">return</span> <span class="stringliteral">"FC_WA_MIN_SEGMENT_LENGTHS"</span>;
<a name="l01638"></a>01638   <span class="keywordflow">case</span> <a class="code" href="lib__skeleton_8h.html#e8816f1d3f4ad9da003a2123bda65c0e9fa17d3a07983a98e01afdd865792d42">FC_WA_MIN_ANGLE_CHANGE</a>:    <span class="keywordflow">return</span> <span class="stringliteral">"FC_WA_MIN_ANGLE_CHANGE"</span>;
<a name="l01639"></a>01639   <span class="keywordflow">case</span> <a class="code" href="lib__skeleton_8h.html#e8816f1d3f4ad9da003a2123bda65c0e2ffdcd095fbdb569f7125bc08db08162">FC_WA_UNKNOWN</a>:             <span class="keywordflow">return</span> <span class="stringliteral">"FC_WA_UNKNOWN"</span>;
<a name="l01640"></a>01640   <span class="keywordflow">case</span> <a class="code" href="lib__skeleton_8h.html#e8816f1d3f4ad9da003a2123bda65c0e60e55e13721c9628dc932147834f3a25">FC_WA_UNSPECIFIED</a>:         <span class="keywordflow">return</span> <span class="stringliteral">"FC_WA_UNSPECIFIED"</span>;
<a name="l01641"></a>01641   <span class="keywordflow">default</span>: <span class="keywordflow">return</span> <span class="stringliteral">"ERROR:Unknown Alg?"</span>;
<a name="l01642"></a>01642   }
<a name="l01643"></a>01643 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="01a08f714eaaf8313f3b0d4191deed40"></a><!-- doxytag: member="lib_skeleton.h::doesSeqVarExist" ref="01a08f714eaaf8313f3b0d4191deed40" args="(FC_Mesh m, char *seqvar_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int doesSeqVarExist           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFC__Mesh.html">FC_Mesh</a>&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>seqvar_name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="lib__skeleton_8c-source.html#l00624">624</a> of file <a class="el" href="lib__skeleton_8c-source.html">lib_skeleton.c</a>.</p>

<p>References <a class="el" href="variable_8c-source.html#l04392">fc_getSeqVariableByName()</a>, <a class="el" href="mesh_8c-source.html#l02742">fc_isMeshValid()</a>, <a class="el" href="base_8h-source.html#l00104">FC_SUCCESS</a>, and <a class="el" href="lib__skeleton_8h-source.html#l00047">FREE</a>.</p>

<p>Referenced by <a class="el" href="lib__skeleton_8c-source.html#l00651">fc_saveSkeleton()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00624"></a>00624                                                  {
<a name="l00625"></a>00625 
<a name="l00626"></a>00626   <a class="code" href="group__DataTypes.html#g2a40aa471d085988d5b582669f766ce4" title="Possible function return values.">FC_ReturnCode</a> rc;
<a name="l00627"></a>00627   <span class="keywordtype">int</span> num_seqVar;
<a name="l00628"></a>00628   <span class="keywordtype">int</span> *numStepPerVar;
<a name="l00629"></a>00629   <a class="code" href="structFC__Variable.html" title="Variable Handle.">FC_Variable</a> **seqVars;
<a name="l00630"></a>00630   <span class="keywordtype">int</span> i;
<a name="l00631"></a>00631 
<a name="l00632"></a>00632   <span class="keywordflow">if</span>(!<a class="code" href="group__Mesh.html#gab6b9ca1bc6e1e7d549ce9fcd396a5e6" title="Check that the handle refers to a valid mesh.">fc_isMeshValid</a>(m)) <span class="keywordflow">return</span> 0; <span class="comment">//Invalid mesh</span>
<a name="l00633"></a>00633   <span class="keywordflow">if</span>(!seqvar_name)       <span class="keywordflow">return</span> 0; <span class="comment">//Null name</span>
<a name="l00634"></a>00634 
<a name="l00635"></a>00635   rc = <a class="code" href="group__Variable.html#g23372bf294117d6761d750446516f0d3" title="Get sequence variables of a given name from the mesh.">fc_getSeqVariableByName</a>(m, seqvar_name, 
<a name="l00636"></a>00636                       &amp;num_seqVar, &amp;numStepPerVar, &amp;seqVars);
<a name="l00637"></a>00637   <span class="keywordflow">if</span>(rc!=<a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce46687acb19dbc2e15e6e89cdc39e8e18e">FC_SUCCESS</a>) <span class="keywordflow">return</span> 0;
<a name="l00638"></a>00638 
<a name="l00639"></a>00639   <span class="keywordflow">if</span>(num_seqVar){
<a name="l00640"></a>00640     <a class="code" href="lib__skeleton_8h.html#834f31033781e091a3dbdfe16f7e8285">FREE</a>(numStepPerVar);
<a name="l00641"></a>00641     <span class="keywordflow">for</span>(i=0; i&lt;num_seqVar; i++)
<a name="l00642"></a>00642       <a class="code" href="lib__skeleton_8h.html#834f31033781e091a3dbdfe16f7e8285">FREE</a>(seqVars[i]);
<a name="l00643"></a>00643     <a class="code" href="lib__skeleton_8h.html#834f31033781e091a3dbdfe16f7e8285">FREE</a>(seqVars);
<a name="l00644"></a>00644   }
<a name="l00645"></a>00645 
<a name="l00646"></a>00646   <span class="keywordflow">return</span> num_seqVar;
<a name="l00647"></a>00647 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="dd3df4be2e7ca2ba3f19258cffb2e08a"></a><!-- doxytag: member="lib_skeleton.h::fc_computeTreeDescendantsAncestors" ref="dd3df4be2e7ca2ba3f19258cffb2e08a" args="(spanning_tree_t *tree)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DataTypes.html#g2a40aa471d085988d5b582669f766ce4">FC_ReturnCode</a> fc_computeTreeDescendantsAncestors           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structspanning__tree__t.html">spanning_tree_t</a> *&nbsp;</td>
          <td class="paramname"> <em>tree</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="lib__skeleton_8c-source.html#l00267">267</a> of file <a class="el" href="lib__skeleton_8c-source.html">lib_skeleton.c</a>.</p>

<p>References <a class="el" href="storage_8c-source.html#l01577">_fc_lookupIntInSortedIntArray()</a>, <a class="el" href="lib__skeleton_8h-source.html#l00044">emsg</a>, <a class="el" href="storage_8c-source.html#l00441">fc_addIntArrayToSortedIntArray()</a>, <a class="el" href="error_8h-source.html#l00080">fc_exitIfError</a>, <a class="el" href="storage_8c-source.html#l00846">fc_freeSortedIntArray()</a>, <a class="el" href="storage_8c-source.html#l00095">fc_initSortedIntArray()</a>, <a class="el" href="base_8h-source.html#l00107">FC_INPUT_ERROR</a>, <a class="el" href="library_8h-source.html#l00120">fc_printfErrorMessage</a>, <a class="el" href="base_8h-source.html#l00104">FC_SUCCESS</a>, <a class="el" href="lib__skeleton_8h-source.html#l00066">spanning_tree_node_t::id_start</a>, <a class="el" href="lib__skeleton_8h-source.html#l00067">spanning_tree_node_t::id_stop</a>, <a class="el" href="lib__skeleton_8h-source.html#l00077">spanning_tree_t::nodes</a>, <a class="el" href="lib__skeleton_8h-source.html#l00070">spanning_tree_node_t::num_ancestors</a>, <a class="el" href="lib__skeleton_8h-source.html#l00069">spanning_tree_node_t::num_descendants</a>, <a class="el" href="lib__skeleton_8h-source.html#l00076">spanning_tree_t::numNodes</a>, <a class="el" href="lib__skeleton_8h-source.html#l00075">spanning_tree_t::root</a>, and <a class="el" href="storage_8h-source.html#l00103">FC_SortedIntArray::tickets</a>.</p>

<p>Referenced by <a class="el" href="lib__skeleton_8c-source.html#l00342">fc_makeSpanningTree()</a>, <a class="el" href="lib__skeleton_8c-source.html#l01519">fc_unpackSkeletonFromMesh()</a>, <a class="el" href="lib__skeleton_8c-source.html#l00988">replicateSpanningTreeWithMask()</a>, and <a class="el" href="lib__skeleton_8c-source.html#l01103">whittleSkeletonByNumDescendents()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00267"></a>00267                                                                        {
<a name="l00268"></a>00268 
<a name="l00269"></a>00269   
<a name="l00270"></a>00270   <span class="keywordtype">int</span> i,j,k;
<a name="l00271"></a>00271   <span class="keywordtype">int</span> hops_up;
<a name="l00272"></a>00272 
<a name="l00273"></a>00273   <a class="code" href="structFC__SortedIntArray.html" title="Sorted, exclusive, self-exanding int array.">FC_SortedIntArray</a> lut;
<a name="l00274"></a>00274   <a class="code" href="group__DataTypes.html#g2a40aa471d085988d5b582669f766ce4" title="Possible function return values.">FC_ReturnCode</a> rc;
<a name="l00275"></a>00275   <span class="keywordtype">int</span> *tmp;
<a name="l00276"></a>00276 
<a name="l00277"></a>00277   <span class="comment">//printf("Starting anc/dec\n");</span>
<a name="l00278"></a>00278   <span class="comment">//Build a lookup table to speedup search of vals</span>
<a name="l00279"></a>00279   tmp = (<span class="keywordtype">int</span> *) malloc(tree-&gt;<a class="code" href="structspanning__tree__t.html#5ccb47c8e349067ee6017e091d02306e">numNodes</a> * <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
<a name="l00280"></a>00280   <span class="keywordflow">for</span>(i=0;i&lt;tree-&gt;<a class="code" href="structspanning__tree__t.html#5ccb47c8e349067ee6017e091d02306e">numNodes</a>;i++){
<a name="l00281"></a>00281     tree-&gt;<a class="code" href="structspanning__tree__t.html#31d1d9e54040f7634f16cdddd1c24760">nodes</a>[i].<a class="code" href="structspanning__tree__node__t.html#96be82e2c2d02cb47d9e71c2938a9ced">num_ancestors</a> = tree-&gt;<a class="code" href="structspanning__tree__t.html#31d1d9e54040f7634f16cdddd1c24760">nodes</a>[i].<a class="code" href="structspanning__tree__node__t.html#48095c9cb31a1f850c5eb6e1a843de1e">num_descendants</a> = 0;
<a name="l00282"></a>00282     tmp[i] = tree-&gt;<a class="code" href="structspanning__tree__t.html#31d1d9e54040f7634f16cdddd1c24760">nodes</a>[i].<a class="code" href="structspanning__tree__node__t.html#a7f8f7a44d9a169bf101223b7106d91a">id_stop</a>;
<a name="l00283"></a>00283   }
<a name="l00284"></a>00284   
<a name="l00285"></a>00285   rc = <a class="code" href="group__SimpleDataObjects.html#g2a977bec6f7ae75297a4dcf7ec079bb7" title="Initialize a sorted int array.">fc_initSortedIntArray</a>(&amp;lut);                                   <a class="code" href="group__ErrorHandling.html#gcc9949110ba62c7ec8fabf7b455f1c0b" title="If the return code is an error, print diagnostic and exit.">fc_exitIfError</a>(rc);
<a name="l00286"></a>00286   rc = <a class="code" href="group__SimpleDataObjects.html#gf842f060b1f39a0acfc54421bbe0865a" title="Add an array of ints to a sorted int array.">fc_addIntArrayToSortedIntArray</a>(&amp;lut, tree-&gt;<a class="code" href="structspanning__tree__t.html#5ccb47c8e349067ee6017e091d02306e">numNodes</a>, tmp, 0);
<a name="l00287"></a>00287   <span class="keywordflow">if</span>(rc!=tree-&gt;<a class="code" href="structspanning__tree__t.html#5ccb47c8e349067ee6017e091d02306e">numNodes</a>)
<a name="l00288"></a>00288     <a class="code" href="lib__skeleton_8h.html#86d286aba1a39e49e5acb2d860e0fe84">emsg</a>(<span class="stringliteral">"Wrong number of sorted vals?"</span>);
<a name="l00289"></a>00289 
<a name="l00290"></a>00290 <span class="preprocessor">#if 0</span>
<a name="l00291"></a>00291 <span class="preprocessor"></span>  <span class="comment">//Verify</span>
<a name="l00292"></a>00292   <span class="keywordflow">for</span>(i=0; i&lt;tree-&gt;<a class="code" href="structspanning__tree__t.html#5ccb47c8e349067ee6017e091d02306e">numNodes</a>;i++){
<a name="l00293"></a>00293     <span class="keywordtype">int</span> found, spot;
<a name="l00294"></a>00294     rc = <a class="code" href="group__PrivateSimpleDataObjects.html#g14397daf9a9991034e57513c720dedaa" title="Lookup int in the sorted int array.">_fc_lookupIntInSortedIntArray</a>(&amp;lut, tree-&gt;<a class="code" href="structspanning__tree__t.html#31d1d9e54040f7634f16cdddd1c24760">nodes</a>[i].<a class="code" href="structspanning__tree__node__t.html#a7f8f7a44d9a169bf101223b7106d91a">id_stop</a>, &amp;found, &amp;spot);
<a name="l00295"></a>00295     <a class="code" href="group__ErrorHandling.html#gcc9949110ba62c7ec8fabf7b455f1c0b" title="If the return code is an error, print diagnostic and exit.">fc_exitIfError</a>(rc);
<a name="l00296"></a>00296 
<a name="l00297"></a>00297     <span class="keywordflow">if</span>(lut.<a class="code" href="structFC__SortedIntArray.html#365d6ece2a2baebf25294397d16b6f44">tickets</a>[spot] != i)
<a name="l00298"></a>00298       <a class="code" href="lib__skeleton_8h.html#86d286aba1a39e49e5acb2d860e0fe84">emsg</a>(<span class="stringliteral">"Got bad ticket for  %d"</span>, i);
<a name="l00299"></a>00299   }
<a name="l00300"></a>00300   printf(<span class="stringliteral">"Verified lut\n"</span>);
<a name="l00301"></a>00301 <span class="preprocessor">#endif</span>
<a name="l00302"></a>00302 <span class="preprocessor"></span>
<a name="l00303"></a>00303 
<a name="l00304"></a>00304   <span class="comment">//visit all nodes</span>
<a name="l00305"></a>00305   <span class="keywordflow">for</span>(i=0; i&lt;tree-&gt;<a class="code" href="structspanning__tree__t.html#5ccb47c8e349067ee6017e091d02306e">numNodes</a>;i++){
<a name="l00306"></a>00306     <span class="comment">//For each node, trace the path back to the root. Along the way,</span>
<a name="l00307"></a>00307     <span class="comment">//increment the number of descendants each visited node has. After</span>
<a name="l00308"></a>00308     <span class="comment">//all is done for this node, store the number of hops it took to</span>
<a name="l00309"></a>00309     <span class="comment">//get to the root.</span>
<a name="l00310"></a>00310     hops_up=1; <span class="comment">//always at least one, since root not in tree</span>
<a name="l00311"></a>00311     j=tree-&gt;<a class="code" href="structspanning__tree__t.html#31d1d9e54040f7634f16cdddd1c24760">nodes</a>[i].<a class="code" href="structspanning__tree__node__t.html#e63a247a928451c07c9ee6b20a0f393b">id_start</a>;
<a name="l00312"></a>00312     <span class="keywordflow">while</span>(j!=tree-&gt;<a class="code" href="structspanning__tree__t.html#2f7ebb14ff208bc06e6a184175c8b8ff">root</a>){
<a name="l00313"></a>00313 <span class="preprocessor">      #if 0</span>
<a name="l00314"></a>00314 <span class="preprocessor"></span>         <span class="keywordflow">for</span>(k=0; (k&lt;tree-&gt;<a class="code" href="structspanning__tree__t.html#5ccb47c8e349067ee6017e091d02306e">numNodes</a>) &amp;&amp; (tree-&gt;<a class="code" href="structspanning__tree__t.html#31d1d9e54040f7634f16cdddd1c24760">nodes</a>[k].<a class="code" href="structspanning__tree__node__t.html#a7f8f7a44d9a169bf101223b7106d91a">id_stop</a>!=j) ; k++); <span class="comment">//Find location of this node</span>
<a name="l00315"></a>00315          <span class="keywordflow">if</span>(k==tree-&gt;<a class="code" href="structspanning__tree__t.html#5ccb47c8e349067ee6017e091d02306e">numNodes</a>){
<a name="l00316"></a>00316         <a class="code" href="group__Library.html#g1473e77471cd1319f76eb9a32e4ad91f" title="Print an error message to stderr.">fc_printfErrorMessage</a>(<span class="stringliteral">"Did not find requested node %d in tree with %d nodes\n"</span>, j, tree-&gt;<a class="code" href="structspanning__tree__t.html#5ccb47c8e349067ee6017e091d02306e">numNodes</a>);
<a name="l00317"></a>00317         <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce464a3d55131c355cdf036f95d0d7e1a6e">FC_INPUT_ERROR</a>;
<a name="l00318"></a>00318          }
<a name="l00319"></a>00319 <span class="preprocessor">      #else</span>
<a name="l00320"></a>00320 <span class="preprocessor"></span>      <span class="keywordtype">int</span> found, spot;
<a name="l00321"></a>00321       rc = <a class="code" href="group__PrivateSimpleDataObjects.html#g14397daf9a9991034e57513c720dedaa" title="Lookup int in the sorted int array.">_fc_lookupIntInSortedIntArray</a>(&amp;lut, j, &amp;found, &amp;spot);
<a name="l00322"></a>00322       <span class="keywordflow">if</span>(!found)
<a name="l00323"></a>00323         <a class="code" href="lib__skeleton_8h.html#86d286aba1a39e49e5acb2d860e0fe84">emsg</a>(<span class="stringliteral">"Didn't find parent?"</span>);
<a name="l00324"></a>00324       k = lut.<a class="code" href="structFC__SortedIntArray.html#365d6ece2a2baebf25294397d16b6f44">tickets</a>[spot];
<a name="l00325"></a>00325 <span class="preprocessor">      #endif</span>
<a name="l00326"></a>00326 <span class="preprocessor"></span>
<a name="l00327"></a>00327       tree-&gt;<a class="code" href="structspanning__tree__t.html#31d1d9e54040f7634f16cdddd1c24760">nodes</a>[k].<a class="code" href="structspanning__tree__node__t.html#48095c9cb31a1f850c5eb6e1a843de1e">num_descendants</a>++;
<a name="l00328"></a>00328       j=tree-&gt;<a class="code" href="structspanning__tree__t.html#31d1d9e54040f7634f16cdddd1c24760">nodes</a>[k].<a class="code" href="structspanning__tree__node__t.html#e63a247a928451c07c9ee6b20a0f393b">id_start</a>;
<a name="l00329"></a>00329       hops_up++;
<a name="l00330"></a>00330     }
<a name="l00331"></a>00331     tree-&gt;<a class="code" href="structspanning__tree__t.html#31d1d9e54040f7634f16cdddd1c24760">nodes</a>[i].<a class="code" href="structspanning__tree__node__t.html#96be82e2c2d02cb47d9e71c2938a9ced">num_ancestors</a> = hops_up;
<a name="l00332"></a>00332   }
<a name="l00333"></a>00333 
<a name="l00334"></a>00334   <a class="code" href="group__SimpleDataObjects.html#g20daa2fb7f38e75da823116f5c41a579" title="Free the sorted int array&amp;#39;s values.">fc_freeSortedIntArray</a>(&amp;lut);
<a name="l00335"></a>00335 
<a name="l00336"></a>00336   <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce46687acb19dbc2e15e6e89cdc39e8e18e">FC_SUCCESS</a>;
<a name="l00337"></a>00337 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="1bbd7a44f7bed3ef955121c22434dca3"></a><!-- doxytag: member="lib_skeleton.h::fc_computeTreeDistances" ref="1bbd7a44f7bed3ef955121c22434dca3" args="(spanning_tree_t *t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DataTypes.html#g2a40aa471d085988d5b582669f766ce4">FC_ReturnCode</a> fc_computeTreeDistances           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structspanning__tree__t.html">spanning_tree_t</a> *&nbsp;</td>
          <td class="paramname"> <em>t</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="lib__skeleton_8c-source.html#l00237">237</a> of file <a class="el" href="lib__skeleton_8c-source.html">lib_skeleton.c</a>.</p>

<p>References <a class="el" href="lib__skeleton_8c-source.html#l00208">_getParentIndexForIndex()</a>, <a class="el" href="lib__skeleton_8h-source.html#l00068">spanning_tree_node_t::dist_center</a>, <a class="el" href="lib__skeleton_8h-source.html#l00084">spanning_tree_t::elementCenters</a>, <a class="el" href="geom_8c-source.html#l00163">fc_calcSquaredEuclideanDistance()</a>, <a class="el" href="error_8h-source.html#l00080">fc_exitIfError</a>, <a class="el" href="base_8h-source.html#l00104">FC_SUCCESS</a>, <a class="el" href="lib__skeleton_8h-source.html#l00066">spanning_tree_node_t::id_start</a>, <a class="el" href="lib__skeleton_8h-source.html#l00067">spanning_tree_node_t::id_stop</a>, <a class="el" href="lib__skeleton_8h-source.html#l00077">spanning_tree_t::nodes</a>, and <a class="el" href="lib__skeleton_8h-source.html#l00076">spanning_tree_t::numNodes</a>.</p>

<p>Referenced by <a class="el" href="lib__skeleton_8c-source.html#l01519">fc_unpackSkeletonFromMesh()</a>, and <a class="el" href="lib__skeleton_8c-source.html#l00988">replicateSpanningTreeWithMask()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00237"></a>00237                                                          {
<a name="l00238"></a>00238   
<a name="l00239"></a>00239   <span class="keywordtype">int</span> i;
<a name="l00240"></a>00240   <span class="keywordtype">int</span> parent_spot;
<a name="l00241"></a>00241   <span class="keywordtype">double</span> sum;
<a name="l00242"></a>00242   <a class="code" href="group__DataTypes.html#g2a40aa471d085988d5b582669f766ce4" title="Possible function return values.">FC_ReturnCode</a> rc;
<a name="l00243"></a>00243 
<a name="l00244"></a>00244 
<a name="l00245"></a>00245   <span class="keywordflow">for</span>(i=0; i&lt;t-&gt;<a class="code" href="structspanning__tree__t.html#5ccb47c8e349067ee6017e091d02306e">numNodes</a>; i++){
<a name="l00246"></a>00246 
<a name="l00247"></a>00247     parent_spot = <a class="code" href="lib__skeleton_8c.html#11b44926cb30faa29be3bb384933025d">_getParentIndexForIndex</a>(t, i);
<a name="l00248"></a>00248 
<a name="l00249"></a>00249     <span class="comment">//Find distance for this link</span>
<a name="l00250"></a>00250     rc = <a class="code" href="group__GeometricRelations.html#gf1520cdaf3f984812aae127263fcd864" title="Compute the squared distance between two vertices.">fc_calcSquaredEuclideanDistance</a>(&amp;t-&gt;<a class="code" href="structspanning__tree__t.html#4a6035ff3412486e6beff9f9a636401b">elementCenters</a>[ t-&gt;<a class="code" href="structspanning__tree__t.html#31d1d9e54040f7634f16cdddd1c24760">nodes</a>[i].<a class="code" href="structspanning__tree__node__t.html#e63a247a928451c07c9ee6b20a0f393b">id_start</a> * 3],
<a name="l00251"></a>00251                           &amp;t-&gt;<a class="code" href="structspanning__tree__t.html#4a6035ff3412486e6beff9f9a636401b">elementCenters</a>[ t-&gt;<a class="code" href="structspanning__tree__t.html#31d1d9e54040f7634f16cdddd1c24760">nodes</a>[i].<a class="code" href="structspanning__tree__node__t.html#a7f8f7a44d9a169bf101223b7106d91a">id_stop</a>  * 3],
<a name="l00252"></a>00252                           3, &amp;sum);
<a name="l00253"></a>00253     <a class="code" href="group__ErrorHandling.html#gcc9949110ba62c7ec8fabf7b455f1c0b" title="If the return code is an error, print diagnostic and exit.">fc_exitIfError</a>(rc);
<a name="l00254"></a>00254     
<a name="l00255"></a>00255     <span class="comment">//Add it to the distance accumulated at the parent</span>
<a name="l00256"></a>00256     sum += (parent_spot&lt;0) ? 0.0 : t-&gt;<a class="code" href="structspanning__tree__t.html#31d1d9e54040f7634f16cdddd1c24760">nodes</a>[parent_spot].<a class="code" href="structspanning__tree__node__t.html#5e905b8fea407e8c86606ffc956cd4ef">dist_center</a>;
<a name="l00257"></a>00257     
<a name="l00258"></a>00258     t-&gt;<a class="code" href="structspanning__tree__t.html#31d1d9e54040f7634f16cdddd1c24760">nodes</a>[i].<a class="code" href="structspanning__tree__node__t.html#5e905b8fea407e8c86606ffc956cd4ef">dist_center</a> = sum;    
<a name="l00259"></a>00259   }
<a name="l00260"></a>00260   <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce46687acb19dbc2e15e6e89cdc39e8e18e">FC_SUCCESS</a>;
<a name="l00261"></a>00261 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="a0ec845ef4749dd88d295e8f407ac582"></a><!-- doxytag: member="lib_skeleton.h::fc_convertTreeToMesh" ref="a0ec845ef4749dd88d295e8f407ac582" args="(FC_Dataset ds, spanning_tree_t tree, char *mesh_name, char *displacement_var_name, FC_Mesh *mesh_out)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DataTypes.html#g2a40aa471d085988d5b582669f766ce4">FC_ReturnCode</a> fc_convertTreeToMesh           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFC__Dataset.html">FC_Dataset</a>&nbsp;</td>
          <td class="paramname"> <em>ds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structspanning__tree__t.html">spanning_tree_t</a>&nbsp;</td>
          <td class="paramname"> <em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>mesh_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>displacement_var_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structFC__Mesh.html">FC_Mesh</a> *&nbsp;</td>
          <td class="paramname"> <em>mesh_out</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="lib__skeleton_8c-source.html#l00817">817</a> of file <a class="el" href="lib__skeleton_8c-source.html">lib_skeleton.c</a>.</p>

<p>References <a class="el" href="lib__skeleton_8h-source.html#l00081">spanning_tree_t::dim</a>, <a class="el" href="lib__skeleton_8h-source.html#l00084">spanning_tree_t::elementCenters</a>, <a class="el" href="lib__skeleton_8h-source.html#l00044">emsg</a>, <a class="el" href="base_8h-source.html#l00191">FC_AT_VERTEX</a>, <a class="el" href="sequence_8c-source.html#l00310">fc_copySequence()</a>, <a class="el" href="mesh_8c-source.html#l00119">fc_createMesh()</a>, <a class="el" href="variable_8c-source.html#l00350">fc_createSeqVariable()</a>, <a class="el" href="variable_8c-source.html#l00286">fc_createVariable()</a>, <a class="el" href="base_8h-source.html#l00150">FC_DT_DOUBLE</a>, <a class="el" href="base_8h-source.html#l00143">FC_DT_INT</a>, <a class="el" href="base_8h-source.html#l00121">FC_ET_LINE</a>, <a class="el" href="error_8h-source.html#l00080">fc_exitIfError</a>, <a class="el" href="lib__skeleton_8c-source.html#l00107">fc_getElementCenters()</a>, <a class="el" href="mesh_8c-source.html#l03762">fc_getMeshElementConnsPtr()</a>, <a class="el" href="variable_8c-source.html#l04695">fc_getOrGenerateUniqueSeqVariableByName()</a>, <a class="el" href="sequence_8c-source.html#l01251">fc_getSequenceByName()</a>, <a class="el" href="variable_8c-source.html#l05317">fc_getSequenceFromSeqVariable()</a>, <a class="el" href="variable_8c-source.html#l05715">fc_getVariableDataPtr()</a>, <a class="el" href="base_8h-source.html#l00107">FC_INPUT_ERROR</a>, <a class="el" href="base_8h-source.html#l00170">FC_MT_SCALAR</a>, <a class="el" href="base_8h-source.html#l00171">FC_MT_VECTOR</a>, <a class="el" href="library_8h-source.html#l00120">fc_printfErrorMessage</a>, <a class="el" href="mesh_8c-source.html#l00193">fc_setMeshCoords()</a>, <a class="el" href="mesh_8c-source.html#l00321">fc_setMeshElementConns()</a>, <a class="el" href="variable_8c-source.html#l00604">fc_setVariableDataPtr()</a>, <a class="el" href="base_8h-source.html#l00104">FC_SUCCESS</a>, <a class="el" href="lib__skeleton_8h-source.html#l00066">spanning_tree_node_t::id_start</a>, <a class="el" href="lib__skeleton_8h-source.html#l00067">spanning_tree_node_t::id_stop</a>, <a class="el" href="lib__skeleton_8h-source.html#l00080">spanning_tree_t::mesh</a>, <a class="el" href="lib__skeleton_8h-source.html#l00085">spanning_tree_t::mesh_is_centers</a>, <a class="el" href="lib__skeleton_8h-source.html#l00077">spanning_tree_t::nodes</a>, <a class="el" href="lib__skeleton_8h-source.html#l00070">spanning_tree_node_t::num_ancestors</a>, <a class="el" href="lib__skeleton_8h-source.html#l00069">spanning_tree_node_t::num_descendants</a>, <a class="el" href="lib__skeleton_8h-source.html#l00082">spanning_tree_t::numElement</a>, <a class="el" href="lib__skeleton_8h-source.html#l00076">spanning_tree_t::numNodes</a>, and <a class="el" href="lib__skeleton_8h-source.html#l00075">spanning_tree_t::root</a>.</p>

<p>Referenced by <a class="el" href="build__ensemble_8c-source.html#l00236">main()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00822"></a>00822                     {
<a name="l00823"></a>00823 
<a name="l00824"></a>00824 
<a name="l00825"></a>00825 
<a name="l00826"></a>00826   <a class="code" href="structFC__Mesh.html" title="Mesh Handle.">FC_Mesh</a> m_src;
<a name="l00827"></a>00827 
<a name="l00828"></a>00828 
<a name="l00829"></a>00829   <a class="code" href="structFC__Mesh.html" title="Mesh Handle.">FC_Mesh</a> m_skel;
<a name="l00830"></a>00830   <a class="code" href="structFC__Variable.html" title="Variable Handle.">FC_Variable</a> v_ancestors, v_descendants;
<a name="l00831"></a>00831   <span class="keywordtype">int</span> *tmp_ancestors, *tmp_descendants;
<a name="l00832"></a>00832 
<a name="l00833"></a>00833   <a class="code" href="group__DataTypes.html#g2a40aa471d085988d5b582669f766ce4" title="Possible function return values.">FC_ReturnCode</a> rc;
<a name="l00834"></a>00834   <span class="keywordtype">int</span> *id_conns;
<a name="l00835"></a>00835   <span class="keywordtype">int</span> numElement;
<a name="l00836"></a>00836   <span class="keywordtype">int</span> i,j;
<a name="l00837"></a>00837 
<a name="l00838"></a>00838   <span class="keywordtype">int</span> dim;
<a name="l00839"></a>00839   <span class="keywordtype">double</span> *coords;
<a name="l00840"></a>00840   <span class="keywordtype">int</span> numCoords, numLinks;
<a name="l00841"></a>00841 
<a name="l00842"></a>00842 
<a name="l00843"></a>00843 
<a name="l00844"></a>00844 
<a name="l00845"></a>00845 
<a name="l00846"></a>00846   <span class="keywordflow">if</span>(tree.<a class="code" href="structspanning__tree__t.html#5ccb47c8e349067ee6017e091d02306e">numNodes</a>&lt;1){
<a name="l00847"></a>00847     <a class="code" href="group__Library.html#g1473e77471cd1319f76eb9a32e4ad91f" title="Print an error message to stderr.">fc_printfErrorMessage</a>(<span class="stringliteral">"Skeleton did not have any links in it\n"</span>);
<a name="l00848"></a>00848     <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce464a3d55131c355cdf036f95d0d7e1a6e">FC_INPUT_ERROR</a>;
<a name="l00849"></a>00849   }
<a name="l00850"></a>00850 
<a name="l00851"></a>00851   
<a name="l00852"></a>00852   <span class="comment">//elem_centers = tree.element_centers;</span>
<a name="l00853"></a>00853   dim          = tree.<a class="code" href="structspanning__tree__t.html#6aca20c85f139938862367cc664ef52f">dim</a>;
<a name="l00854"></a>00854   numElement   = tree.<a class="code" href="structspanning__tree__t.html#602d7926e681ac4e1ca97843dabd2d4e">numElement</a>;
<a name="l00855"></a>00855   m_src        = tree.<a class="code" href="structspanning__tree__t.html#8047cfbd3e20f76c779de639f2b0b04f">mesh</a>;
<a name="l00856"></a>00856 
<a name="l00857"></a>00857 
<a name="l00858"></a>00858 
<a name="l00859"></a>00859   <span class="comment">//Simple case: just doing centers</span>
<a name="l00860"></a>00860   
<a name="l00861"></a>00861   numCoords = tree.<a class="code" href="structspanning__tree__t.html#602d7926e681ac4e1ca97843dabd2d4e">numElement</a>;
<a name="l00862"></a>00862   numLinks  = tree.<a class="code" href="structspanning__tree__t.html#5ccb47c8e349067ee6017e091d02306e">numNodes</a>; 
<a name="l00863"></a>00863   
<a name="l00864"></a>00864   <span class="comment">//Coords: made up of all element centers, nothing else</span>
<a name="l00865"></a>00865   coords = (<span class="keywordtype">double</span> *)malloc(numCoords*dim*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l00866"></a>00866   memcpy(coords, tree.<a class="code" href="structspanning__tree__t.html#4a6035ff3412486e6beff9f9a636401b">elementCenters</a>, numCoords*dim*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l00867"></a>00867   
<a name="l00868"></a>00868   <span class="comment">//Conns: every node gets one link</span>
<a name="l00869"></a>00869   id_conns = (<span class="keywordtype">int</span> *) malloc(numLinks*2*<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
<a name="l00870"></a>00870   <span class="keywordflow">for</span>(i=0; i&lt;numLinks; i++){    
<a name="l00871"></a>00871     <span class="comment">//printf("%d/%d start/stop = %d/%d  max=%d\n", i,num_links, links[i+1].id_start, links[i+1].id_stop, numElement);</span>
<a name="l00872"></a>00872     assert((tree.<a class="code" href="structspanning__tree__t.html#31d1d9e54040f7634f16cdddd1c24760">nodes</a>[i].<a class="code" href="structspanning__tree__node__t.html#e63a247a928451c07c9ee6b20a0f393b">id_start</a>&gt;=0) &amp;&amp; (tree.<a class="code" href="structspanning__tree__t.html#31d1d9e54040f7634f16cdddd1c24760">nodes</a>[i].<a class="code" href="structspanning__tree__node__t.html#e63a247a928451c07c9ee6b20a0f393b">id_start</a>&lt;numCoords));
<a name="l00873"></a>00873     assert((tree.<a class="code" href="structspanning__tree__t.html#31d1d9e54040f7634f16cdddd1c24760">nodes</a>[i].<a class="code" href="structspanning__tree__node__t.html#a7f8f7a44d9a169bf101223b7106d91a">id_stop</a> &gt;=0) &amp;&amp; (tree.<a class="code" href="structspanning__tree__t.html#31d1d9e54040f7634f16cdddd1c24760">nodes</a>[i].<a class="code" href="structspanning__tree__node__t.html#a7f8f7a44d9a169bf101223b7106d91a">id_stop</a> &lt;numCoords));
<a name="l00874"></a>00874     
<a name="l00875"></a>00875     id_conns[i*2+0] = tree.<a class="code" href="structspanning__tree__t.html#31d1d9e54040f7634f16cdddd1c24760">nodes</a>[i].<a class="code" href="structspanning__tree__node__t.html#e63a247a928451c07c9ee6b20a0f393b">id_start</a>; <span class="comment">//First entry is not a link, it's </span>
<a name="l00876"></a>00876     id_conns[i*2+1] = tree.<a class="code" href="structspanning__tree__t.html#31d1d9e54040f7634f16cdddd1c24760">nodes</a>[i].<a class="code" href="structspanning__tree__node__t.html#a7f8f7a44d9a169bf101223b7106d91a">id_stop</a>;  <span class="comment">//the origin</span>
<a name="l00877"></a>00877   }
<a name="l00878"></a>00878   
<a name="l00879"></a>00879 
<a name="l00880"></a>00880   <span class="comment">//Create the Mesh</span>
<a name="l00881"></a>00881   rc=<a class="code" href="group__Mesh.html#g3928a328006617330e735ca1644e7cb3" title="Create a new mesh.">fc_createMesh</a>(ds, mesh_name, &amp;m_skel);                                                               <a class="code" href="group__ErrorHandling.html#gcc9949110ba62c7ec8fabf7b455f1c0b" title="If the return code is an error, print diagnostic and exit.">fc_exitIfError</a>(rc);
<a name="l00882"></a>00882   rc=<a class="code" href="group__Mesh.html#gbe7f568d5b8fe72693ad308d15194e01" title="Set the mesh coordinates by copy.">fc_setMeshCoords</a>(m_skel, dim, numCoords, coords);                                                           <a class="code" href="group__ErrorHandling.html#gcc9949110ba62c7ec8fabf7b455f1c0b" title="If the return code is an error, print diagnostic and exit.">fc_exitIfError</a>(rc);
<a name="l00883"></a>00883   rc=<a class="code" href="group__Mesh.html#gd7bb8a0f67d6c0b44edbfe864a53b218" title="Set the mesh element to vertex connectivities by copy.">fc_setMeshElementConns</a>(m_skel, <a class="code" href="group__DataTypes.html#gg57a0abe7a63cc2c6c9fb0a3db339884a80b8143aeefa54756df4ea881fb21fea">FC_ET_LINE</a>, numLinks, id_conns);                                             <a class="code" href="group__ErrorHandling.html#gcc9949110ba62c7ec8fabf7b455f1c0b" title="If the return code is an error, print diagnostic and exit.">fc_exitIfError</a>(rc);
<a name="l00884"></a>00884 
<a name="l00885"></a>00885   <span class="comment">//Create variables for giving the number of ancestors and descendants </span>
<a name="l00886"></a>00886   rc=<a class="code" href="group__Variable.html#ga2ffd025a786dbe93fc7f8defb969631" title="Create a new variable.">fc_createVariable</a>(m_skel, <span class="stringliteral">"num_ancestors"</span>,   &amp;v_ancestors);                                                 <a class="code" href="group__ErrorHandling.html#gcc9949110ba62c7ec8fabf7b455f1c0b" title="If the return code is an error, print diagnostic and exit.">fc_exitIfError</a>(rc);
<a name="l00887"></a>00887   rc=<a class="code" href="group__Variable.html#ga2ffd025a786dbe93fc7f8defb969631" title="Create a new variable.">fc_createVariable</a>(m_skel, <span class="stringliteral">"num_descendants"</span>, &amp;v_descendants);                                               <a class="code" href="group__ErrorHandling.html#gcc9949110ba62c7ec8fabf7b455f1c0b" title="If the return code is an error, print diagnostic and exit.">fc_exitIfError</a>(rc);
<a name="l00888"></a>00888 
<a name="l00889"></a>00889   tmp_ancestors   = (<span class="keywordtype">int</span> *)calloc(numCoords,<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
<a name="l00890"></a>00890   tmp_descendants = (<span class="keywordtype">int</span> *)calloc(numCoords,<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
<a name="l00891"></a>00891   tmp_ancestors[   tree.<a class="code" href="structspanning__tree__t.html#2f7ebb14ff208bc06e6a184175c8b8ff">root</a> ] = 0;
<a name="l00892"></a>00892   tmp_descendants[ tree.<a class="code" href="structspanning__tree__t.html#2f7ebb14ff208bc06e6a184175c8b8ff">root</a> ] = tree.<a class="code" href="structspanning__tree__t.html#5ccb47c8e349067ee6017e091d02306e">numNodes</a>;
<a name="l00893"></a>00893   <span class="keywordflow">for</span>(i=0;i&lt;tree.<a class="code" href="structspanning__tree__t.html#5ccb47c8e349067ee6017e091d02306e">numNodes</a>; i++){
<a name="l00894"></a>00894     tmp_ancestors[   tree.<a class="code" href="structspanning__tree__t.html#31d1d9e54040f7634f16cdddd1c24760">nodes</a>[i].<a class="code" href="structspanning__tree__node__t.html#a7f8f7a44d9a169bf101223b7106d91a">id_stop</a> ] = tree.<a class="code" href="structspanning__tree__t.html#31d1d9e54040f7634f16cdddd1c24760">nodes</a>[i].<a class="code" href="structspanning__tree__node__t.html#96be82e2c2d02cb47d9e71c2938a9ced">num_ancestors</a>;
<a name="l00895"></a>00895     tmp_descendants[ tree.<a class="code" href="structspanning__tree__t.html#31d1d9e54040f7634f16cdddd1c24760">nodes</a>[i].<a class="code" href="structspanning__tree__node__t.html#a7f8f7a44d9a169bf101223b7106d91a">id_stop</a> ] = tree.<a class="code" href="structspanning__tree__t.html#31d1d9e54040f7634f16cdddd1c24760">nodes</a>[i].<a class="code" href="structspanning__tree__node__t.html#48095c9cb31a1f850c5eb6e1a843de1e">num_descendants</a>;
<a name="l00896"></a>00896   }
<a name="l00897"></a>00897 
<a name="l00898"></a>00898   { <span class="comment">//error Check</span>
<a name="l00899"></a>00899     printf(<span class="stringliteral">"Root is %d\n"</span>, tree.<a class="code" href="structspanning__tree__t.html#2f7ebb14ff208bc06e6a184175c8b8ff">root</a>);
<a name="l00900"></a>00900     <span class="keywordflow">for</span>(i=0; i&lt;tree.<a class="code" href="structspanning__tree__t.html#5ccb47c8e349067ee6017e091d02306e">numNodes</a>; i++){
<a name="l00901"></a>00901       <span class="keywordflow">if</span>(tree.<a class="code" href="structspanning__tree__t.html#31d1d9e54040f7634f16cdddd1c24760">nodes</a>[i].<a class="code" href="structspanning__tree__node__t.html#96be82e2c2d02cb47d9e71c2938a9ced">num_ancestors</a>&lt;=0)
<a name="l00902"></a>00902      <a class="code" href="lib__skeleton_8h.html#86d286aba1a39e49e5acb2d860e0fe84">emsg</a>(<span class="stringliteral">"spot %d (node %d) had %d ancestors\n"</span>, i, tree.<a class="code" href="structspanning__tree__t.html#31d1d9e54040f7634f16cdddd1c24760">nodes</a>[i].<a class="code" href="structspanning__tree__node__t.html#a7f8f7a44d9a169bf101223b7106d91a">id_stop</a>,tree.<a class="code" href="structspanning__tree__t.html#31d1d9e54040f7634f16cdddd1c24760">nodes</a>[i].<a class="code" href="structspanning__tree__node__t.html#96be82e2c2d02cb47d9e71c2938a9ced">num_ancestors</a> );
<a name="l00903"></a>00903       <span class="comment">//printf("spot %d : id %d  anc/dec= %d/%d\n", i, tree.nodes[i].id_stop,tree.nodes[i].num_ancestors, tree.nodes[i].num_descendants );</span>
<a name="l00904"></a>00904     }
<a name="l00905"></a>00905   }
<a name="l00906"></a>00906 
<a name="l00907"></a>00907 
<a name="l00908"></a>00908   rc=<a class="code" href="group__Variable.html#g87015cda75e038cc73c1d584537d81fc" title="Set the pointer to the variable data.">fc_setVariableDataPtr</a>(v_ancestors,   numCoords, 1, <a class="code" href="group__DataTypes.html#gg28b7cdba59395ddc988888d01dd19af644ec6296999025f1ac12940f0c8e36d3">FC_AT_VERTEX</a>, <a class="code" href="group__DataTypes.html#gg60d16c50c365cd12f1f61ce8f4cebb206d3b58fc952172de6c4a1b3f75b8b5b2">FC_MT_SCALAR</a>, <a class="code" href="group__DataTypes.html#ggcca24e957488bb76e40a84ea651975d963896eb450c264fe236185788362b270">FC_DT_INT</a>, tmp_ancestors);   <a class="code" href="group__ErrorHandling.html#gcc9949110ba62c7ec8fabf7b455f1c0b" title="If the return code is an error, print diagnostic and exit.">fc_exitIfError</a>(rc);
<a name="l00909"></a>00909   rc=<a class="code" href="group__Variable.html#g87015cda75e038cc73c1d584537d81fc" title="Set the pointer to the variable data.">fc_setVariableDataPtr</a>(v_descendants, numCoords, 1, <a class="code" href="group__DataTypes.html#gg28b7cdba59395ddc988888d01dd19af644ec6296999025f1ac12940f0c8e36d3">FC_AT_VERTEX</a>, <a class="code" href="group__DataTypes.html#gg60d16c50c365cd12f1f61ce8f4cebb206d3b58fc952172de6c4a1b3f75b8b5b2">FC_MT_SCALAR</a>, <a class="code" href="group__DataTypes.html#ggcca24e957488bb76e40a84ea651975d963896eb450c264fe236185788362b270">FC_DT_INT</a>, tmp_descendants); <a class="code" href="group__ErrorHandling.html#gcc9949110ba62c7ec8fabf7b455f1c0b" title="If the return code is an error, print diagnostic and exit.">fc_exitIfError</a>(rc);
<a name="l00910"></a>00910 
<a name="l00911"></a>00911 
<a name="l00912"></a>00912   <span class="keywordflow">if</span>(displacement_var_name){
<a name="l00913"></a>00913     <a class="code" href="structFC__Sequence.html" title="Sequence Handle.">FC_Sequence</a> src_seq, dst_seq;
<a name="l00914"></a>00914     <a class="code" href="structFC__Variable.html" title="Variable Handle.">FC_Variable</a> *src_dispSV, *dst_dispSV_skel;
<a name="l00915"></a>00915     <span class="keywordtype">int</span> src_dispSV_steps, dst_dispSV_steps;
<a name="l00916"></a>00916     
<a name="l00917"></a>00917     <span class="keywordtype">int</span> *orig_conns; <span class="comment">//read only</span>
<a name="l00918"></a>00918 
<a name="l00919"></a>00919     <span class="comment">//Create displacement vars for the ball and skeleton</span>
<a name="l00920"></a>00920     rc = <a class="code" href="group__Variable.html#g9022a4933230e252076467a05f101a68" title="Gets a unique seq var if it exists, otherwise generate it from components if possible...">fc_getOrGenerateUniqueSeqVariableByName</a>(m_src, displacement_var_name, &amp;src_dispSV_steps, &amp;src_dispSV);  <a class="code" href="group__ErrorHandling.html#gcc9949110ba62c7ec8fabf7b455f1c0b" title="If the return code is an error, print diagnostic and exit.">fc_exitIfError</a>(rc);
<a name="l00921"></a>00921     
<a name="l00922"></a>00922 
<a name="l00923"></a>00923     { <span class="comment">//We should only create one sequence for all meshes</span>
<a name="l00924"></a>00924       <span class="keywordtype">int</span>          tmp_numSeq;
<a name="l00925"></a>00925       <a class="code" href="structFC__Sequence.html" title="Sequence Handle.">FC_Sequence</a> *tmp_seqs;
<a name="l00926"></a>00926 
<a name="l00927"></a>00927       rc = <a class="code" href="group__Sequence.html#gea35f13c19e88c30cda4e23af42c78f5" title="Get all sequences with a given name from a dataset.">fc_getSequenceByName</a>(ds, <span class="stringliteral">"tree_sequence"</span>, &amp;tmp_numSeq, &amp;tmp_seqs);  <a class="code" href="group__ErrorHandling.html#gcc9949110ba62c7ec8fabf7b455f1c0b" title="If the return code is an error, print diagnostic and exit.">fc_exitIfError</a>(rc);
<a name="l00928"></a>00928 
<a name="l00929"></a>00929       <span class="keywordflow">if</span>(!tmp_numSeq){
<a name="l00930"></a>00930      <span class="comment">//Nothing created yet- copy in from original</span>
<a name="l00931"></a>00931      rc = <a class="code" href="group__Variable.html#g314a992ec5ba07d7075f1172b13ef166" title="Get the parent sequence of a sequence variable.">fc_getSequenceFromSeqVariable</a>(src_dispSV_steps, src_dispSV, &amp;src_seq);                                  <a class="code" href="group__ErrorHandling.html#gcc9949110ba62c7ec8fabf7b455f1c0b" title="If the return code is an error, print diagnostic and exit.">fc_exitIfError</a>(rc);
<a name="l00932"></a>00932      rc = <a class="code" href="group__Sequence.html#g75c324c79f7f053ef9e7c568dcb7bc5b" title="Copy a sequence.">fc_copySequence</a>(src_seq, ds, <span class="stringliteral">"tree_sequence"</span>, &amp;dst_seq);                                                <a class="code" href="group__ErrorHandling.html#gcc9949110ba62c7ec8fabf7b455f1c0b" title="If the return code is an error, print diagnostic and exit.">fc_exitIfError</a>(rc);
<a name="l00933"></a>00933       } <span class="keywordflow">else</span> {
<a name="l00934"></a>00934      <span class="comment">//Something already here - use it</span>
<a name="l00935"></a>00935      dst_seq = tmp_seqs[0];
<a name="l00936"></a>00936      free(tmp_seqs);
<a name="l00937"></a>00937       } 
<a name="l00938"></a>00938     }
<a name="l00939"></a>00939     
<a name="l00940"></a>00940     
<a name="l00941"></a>00941     rc = <a class="code" href="group__Variable.html#g05d5098e68c1761ac851b2509dfbea70" title="Create a new sequence variable.">fc_createSeqVariable</a>(m_skel, dst_seq, <span class="stringliteral">"displacement"</span>, &amp;dst_dispSV_steps, &amp;dst_dispSV_skel);             <a class="code" href="group__ErrorHandling.html#gcc9949110ba62c7ec8fabf7b455f1c0b" title="If the return code is an error, print diagnostic and exit.">fc_exitIfError</a>(rc);
<a name="l00942"></a>00942     
<a name="l00943"></a>00943     <span class="comment">//Need connections for original mesh if generating new intersection points</span>
<a name="l00944"></a>00944     rc = <a class="code" href="group__Mesh.html#g19906bcae562d226991740da142000c0" title="Return element to vertex connectivities for the mesh.">fc_getMeshElementConnsPtr</a>(tree.<a class="code" href="structspanning__tree__t.html#8047cfbd3e20f76c779de639f2b0b04f">mesh</a>, &amp;orig_conns);                                                      <a class="code" href="group__ErrorHandling.html#gcc9949110ba62c7ec8fabf7b455f1c0b" title="If the return code is an error, print diagnostic and exit.">fc_exitIfError</a>(rc);
<a name="l00945"></a>00945 
<a name="l00946"></a>00946     <span class="keywordflow">for</span>(i=0; i&lt;dst_dispSV_steps; i++){
<a name="l00947"></a>00947       <span class="keywordtype">double</span> *dst_centers_disp;
<a name="l00948"></a>00948 
<a name="l00949"></a>00949       <span class="keywordflow">if</span>(!tree.<a class="code" href="structspanning__tree__t.html#e13fa21139ec7c4675d4703b48ab0898">mesh_is_centers</a>){
<a name="l00950"></a>00950      <span class="comment">//Need to calculate the centers and figure out the displacements</span>
<a name="l00951"></a>00951      rc = <a class="code" href="lib__skeleton_8c.html#3764a93ca0b255a7955d588ff5f2c2b6">fc_getElementCenters</a>(m_src, src_dispSV[i], &amp;dst_centers_disp);                                        <a class="code" href="group__ErrorHandling.html#gcc9949110ba62c7ec8fabf7b455f1c0b" title="If the return code is an error, print diagnostic and exit.">fc_exitIfError</a>(rc);
<a name="l00952"></a>00952      
<a name="l00953"></a>00953      <span class="comment">//Change to a displacement</span>
<a name="l00954"></a>00954      <span class="keywordflow">for</span>(j=0;j&lt;numCoords*dim;j++)
<a name="l00955"></a>00955        dst_centers_disp[j] -= coords[j];
<a name="l00956"></a>00956 
<a name="l00957"></a>00957       } <span class="keywordflow">else</span> {
<a name="l00958"></a>00958      <span class="keywordtype">double</span> *tmp_disp;
<a name="l00959"></a>00959      <span class="keywordtype">double</span>  tmp_center[dim];
<a name="l00960"></a>00960 
<a name="l00961"></a>00961      dst_centers_disp = (<span class="keywordtype">double</span> *)malloc(numCoords*dim*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l00962"></a>00962      rc = <a class="code" href="group__Variable.html#g40a4d68cafd7134b908b78d053d3c47d" title="Get the data in a variable.">fc_getVariableDataPtr</a>(src_dispSV[i], (<span class="keywordtype">void</span> *) &amp;tmp_disp);                                             <a class="code" href="group__ErrorHandling.html#gcc9949110ba62c7ec8fabf7b455f1c0b" title="If the return code is an error, print diagnostic and exit.">fc_exitIfError</a>(rc);
<a name="l00963"></a>00963      memcpy(dst_centers_disp, tmp_disp, numCoords*dim*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l00964"></a>00964      
<a name="l00965"></a>00965      <span class="keywordflow">for</span>(j=0;j&lt;dim;j++)
<a name="l00966"></a>00966        tmp_center[j] = coords[tree.<a class="code" href="structspanning__tree__t.html#2f7ebb14ff208bc06e6a184175c8b8ff">root</a>*dim+j] + dst_centers_disp[tree.<a class="code" href="structspanning__tree__t.html#2f7ebb14ff208bc06e6a184175c8b8ff">root</a>*dim + j];
<a name="l00967"></a>00967  
<a name="l00968"></a>00968       }
<a name="l00969"></a>00969 
<a name="l00970"></a>00970       rc = <a class="code" href="group__Variable.html#g87015cda75e038cc73c1d584537d81fc" title="Set the pointer to the variable data.">fc_setVariableDataPtr</a>(dst_dispSV_skel[i], numCoords, dim, <a class="code" href="group__DataTypes.html#gg28b7cdba59395ddc988888d01dd19af644ec6296999025f1ac12940f0c8e36d3">FC_AT_VERTEX</a>, <a class="code" href="group__DataTypes.html#gg60d16c50c365cd12f1f61ce8f4cebb207f48fe9fd9efb7bc772bbb41106e217f">FC_MT_VECTOR</a>, <a class="code" href="group__DataTypes.html#ggcca24e957488bb76e40a84ea651975d9250e83e5dab9b5c1872f0f82665ff905">FC_DT_DOUBLE</a>, dst_centers_disp);
<a name="l00971"></a>00971       <a class="code" href="group__ErrorHandling.html#gcc9949110ba62c7ec8fabf7b455f1c0b" title="If the return code is an error, print diagnostic and exit.">fc_exitIfError</a>(rc); <span class="comment">//note: above absorbs the dst_centers pointer</span>
<a name="l00972"></a>00972  
<a name="l00973"></a>00973     }
<a name="l00974"></a>00974   }
<a name="l00975"></a>00975 
<a name="l00976"></a>00976   <span class="comment">//rc=fc_writeDataset(ds, file_name, FC_FT_EXODUS); fc_exitIfError(rc);</span>
<a name="l00977"></a>00977 
<a name="l00978"></a>00978   <span class="keywordflow">if</span>(mesh_out)
<a name="l00979"></a>00979     *mesh_out = m_skel;
<a name="l00980"></a>00980 
<a name="l00981"></a>00981   <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce46687acb19dbc2e15e6e89cdc39e8e18e">FC_SUCCESS</a>;
<a name="l00982"></a>00982 
<a name="l00983"></a>00983 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="3764a93ca0b255a7955d588ff5f2c2b6"></a><!-- doxytag: member="lib_skeleton.h::fc_getElementCenters" ref="3764a93ca0b255a7955d588ff5f2c2b6" args="(FC_Mesh m, FC_Variable displ, double **centers)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DataTypes.html#g2a40aa471d085988d5b582669f766ce4">FC_ReturnCode</a> fc_getElementCenters           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFC__Mesh.html">FC_Mesh</a>&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structFC__Variable.html">FC_Variable</a>&nbsp;</td>
          <td class="paramname"> <em>displ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&nbsp;</td>
          <td class="paramname"> <em>centers</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="lib__skeleton_8c-source.html#l00107">107</a> of file <a class="el" href="lib__skeleton_8c-source.html">lib_skeleton.c</a>.</p>

<p>References <a class="el" href="lib__skeleton_8h-source.html#l00044">emsg</a>, <a class="el" href="error_8h-source.html#l00080">fc_exitIfError</a>, <a class="el" href="geom_8c-source.html#l00352">fc_getDisplacedMeshCoords()</a>, <a class="el" href="base_8c-source.html#l00550">fc_getElementTypeNumVertex()</a>, <a class="el" href="mesh_8c-source.html#l03436">fc_getMeshCoordsPtr()</a>, <a class="el" href="mesh_8c-source.html#l03762">fc_getMeshElementConnsPtr()</a>, <a class="el" href="mesh_8c-source.html#l02848">fc_getMeshInfo()</a>, <a class="el" href="base_8h-source.html#l00319">FC_HANDLE_EQUIV</a>, <a class="el" href="base_8c-source.html#l00779">FC_NULL_VARIABLE</a>, <a class="el" href="base_8h-source.html#l00104">FC_SUCCESS</a>, and <a class="el" href="lib__skeleton_8h-source.html#l00047">FREE</a>.</p>

<p>Referenced by <a class="el" href="lib__skeleton_8c-source.html#l00817">fc_convertTreeToMesh()</a>, <a class="el" href="lib__skeleton_8c-source.html#l00342">fc_makeSpanningTree()</a>, and <a class="el" href="lib__skeleton_8c-source.html#l00651">fc_saveSkeleton()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00108"></a>00108                                         {
<a name="l00109"></a>00109 
<a name="l00110"></a>00110 
<a name="l00111"></a>00111   <a class="code" href="group__DataTypes.html#g2a40aa471d085988d5b582669f766ce4" title="Possible function return values.">FC_ReturnCode</a> rc;
<a name="l00112"></a>00112   <a class="code" href="group__DataTypes.html#g57a0abe7a63cc2c6c9fb0a3db339884a" title="Possible element types.">FC_ElementType</a> elemType;
<a name="l00113"></a>00113   <span class="keywordtype">int</span> i,j,k;
<a name="l00114"></a>00114   <span class="keywordtype">double</span> *mesh_coords;
<a name="l00115"></a>00115   <span class="keywordtype">int</span> *elem_conns;
<a name="l00116"></a>00116   <span class="keywordtype">int</span> numElement, vertPerElem;
<a name="l00117"></a>00117   <span class="keywordtype">int</span> dim;
<a name="l00118"></a>00118   <span class="keywordtype">double</span> sum;
<a name="l00119"></a>00119   <span class="keywordtype">double</span> *elem_centers;
<a name="l00120"></a>00120   <span class="keywordtype">int</span> spot;
<a name="l00121"></a>00121  
<a name="l00122"></a>00122 
<a name="l00123"></a>00123   <span class="comment">//Get basic mesh info</span>
<a name="l00124"></a>00124   rc = <a class="code" href="group__Mesh.html#ged61b1f684fc2a6ac489c10841cdb591" title="Get information about a mesh.">fc_getMeshInfo</a>(m, NULL, &amp;dim, NULL, &amp;numElement, &amp;elemType); <a class="code" href="group__ErrorHandling.html#gcc9949110ba62c7ec8fabf7b455f1c0b" title="If the return code is an error, print diagnostic and exit.">fc_exitIfError</a>(rc);
<a name="l00125"></a>00125   vertPerElem = <a class="code" href="group__DataTypes.html#g2a400f7126e79f149032162c87c4eee8" title="Returns number of vertices in a type of element.">fc_getElementTypeNumVertex</a>(elemType);
<a name="l00126"></a>00126 
<a name="l00127"></a>00127   <span class="comment">//Get the (possibly displaced) vert coords</span>
<a name="l00128"></a>00128   <span class="keywordflow">if</span>(<a class="code" href="group__Handles.html#g390004fca0870147d490f32c55afab8d" title="Check two handles for equality.">FC_HANDLE_EQUIV</a>(displ, <a class="code" href="group__Handles.html#g82162b8ad3f5476855507c3c6450db09" title="Null (default) variable handle.">FC_NULL_VARIABLE</a>)){
<a name="l00129"></a>00129     <span class="comment">//Note: mesh_coords is read-only in this case</span>
<a name="l00130"></a>00130     rc = <a class="code" href="group__Mesh.html#gff8561557c19ae03be9ff18cc73a6823" title="Return the vertex coordinates of the mesh.">fc_getMeshCoordsPtr</a>(m, &amp;mesh_coords); <a class="code" href="group__ErrorHandling.html#gcc9949110ba62c7ec8fabf7b455f1c0b" title="If the return code is an error, print diagnostic and exit.">fc_exitIfError</a>(rc);
<a name="l00131"></a>00131   } <span class="keywordflow">else</span> {
<a name="l00132"></a>00132     <span class="comment">//Note: mesh_coords needs to be freed in this case</span>
<a name="l00133"></a>00133     rc = <a class="code" href="group__GeometricRelations.html#g49b9b92b6a40c6646c0640b38a1f0eee" title="Create displaced vertex coordinates.">fc_getDisplacedMeshCoords</a>(m, displ, &amp;mesh_coords); <a class="code" href="group__ErrorHandling.html#gcc9949110ba62c7ec8fabf7b455f1c0b" title="If the return code is an error, print diagnostic and exit.">fc_exitIfError</a>(rc);
<a name="l00134"></a>00134   }
<a name="l00135"></a>00135 
<a name="l00136"></a>00136 
<a name="l00137"></a>00137   <span class="comment">//Get the element connectivity list</span>
<a name="l00138"></a>00138   rc = <a class="code" href="group__Mesh.html#g19906bcae562d226991740da142000c0" title="Return element to vertex connectivities for the mesh.">fc_getMeshElementConnsPtr</a>(m, &amp;elem_conns); <a class="code" href="group__ErrorHandling.html#gcc9949110ba62c7ec8fabf7b455f1c0b" title="If the return code is an error, print diagnostic and exit.">fc_exitIfError</a>(rc);
<a name="l00139"></a>00139 
<a name="l00140"></a>00140   <span class="comment">//Calculate the center of all elements</span>
<a name="l00141"></a>00141   elem_centers = (<span class="keywordtype">double</span> *) malloc(numElement*dim*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l00142"></a>00142   <span class="keywordflow">if</span>(!elem_centers) <a class="code" href="lib__skeleton_8h.html#86d286aba1a39e49e5acb2d860e0fe84">emsg</a>(<span class="stringliteral">"Bad malloc"</span>);
<a name="l00143"></a>00143 
<a name="l00144"></a>00144   <span class="keywordflow">for</span>(i=0; i&lt;numElement; i++){
<a name="l00145"></a>00145     <span class="keywordflow">for</span>(j=0; j&lt;dim; j++){
<a name="l00146"></a>00146       sum=0.0;
<a name="l00147"></a>00147       <span class="keywordflow">for</span>(k=0; k&lt;vertPerElem; k++){
<a name="l00148"></a>00148      spot = elem_conns[i*vertPerElem + k];
<a name="l00149"></a>00149      sum += mesh_coords[spot*dim + j];
<a name="l00150"></a>00150       }
<a name="l00151"></a>00151       elem_centers[i*dim + j] = sum / (double)vertPerElem;
<a name="l00152"></a>00152     }
<a name="l00153"></a>00153   }
<a name="l00154"></a>00154 
<a name="l00155"></a>00155   <span class="keywordflow">if</span>(!<a class="code" href="group__Handles.html#g390004fca0870147d490f32c55afab8d" title="Check two handles for equality.">FC_HANDLE_EQUIV</a>(displ, <a class="code" href="group__Handles.html#g82162b8ad3f5476855507c3c6450db09" title="Null (default) variable handle.">FC_NULL_VARIABLE</a>)){
<a name="l00156"></a>00156     <span class="comment">//When doing displacement we need to free the copy</span>
<a name="l00157"></a>00157     <a class="code" href="lib__skeleton_8h.html#834f31033781e091a3dbdfe16f7e8285">FREE</a>(mesh_coords);
<a name="l00158"></a>00158   }
<a name="l00159"></a>00159 
<a name="l00160"></a>00160   *centers = elem_centers;
<a name="l00161"></a>00161   <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce46687acb19dbc2e15e6e89cdc39e8e18e">FC_SUCCESS</a>;
<a name="l00162"></a>00162 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="cda51e71e5503db42ef14e39a1646c57"></a><!-- doxytag: member="lib_skeleton.h::fc_makeSpanningTree" ref="cda51e71e5503db42ef14e39a1646c57" args="(FC_Mesh m, int starting_element_id, spanning_tree_t **tree)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DataTypes.html#g2a40aa471d085988d5b582669f766ce4">FC_ReturnCode</a> fc_makeSpanningTree           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFC__Mesh.html">FC_Mesh</a>&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>starting_element_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structspanning__tree__t.html">spanning_tree_t</a> **&nbsp;</td>
          <td class="paramname"> <em>tree</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="lib__skeleton_8c-source.html#l00342">342</a> of file <a class="el" href="lib__skeleton_8c-source.html">lib_skeleton.c</a>.</p>

<p>References <a class="el" href="lib__skeleton_8h-source.html#l00045">dbg</a>, <a class="el" href="lib__skeleton_8h-source.html#l00081">spanning_tree_t::dim</a>, <a class="el" href="lib__skeleton_8h-source.html#l00068">spanning_tree_node_t::dist_center</a>, <a class="el" href="lib__skeleton_8h-source.html#l00084">spanning_tree_t::elementCenters</a>, <a class="el" href="base_8h-source.html#l00196">FC_AT_ELEMENT</a>, <a class="el" href="geom_8c-source.html#l00163">fc_calcSquaredEuclideanDistance()</a>, <a class="el" href="lib__skeleton_8c-source.html#l00267">fc_computeTreeDescendantsAncestors()</a>, <a class="el" href="util_8c-source.html#l00606">fc_eqd()</a>, <a class="el" href="error_8h-source.html#l00080">fc_exitIfError</a>, <a class="el" href="lib__skeleton_8c-source.html#l00107">fc_getElementCenters()</a>, <a class="el" href="base_8c-source.html#l00550">fc_getElementTypeNumVertex()</a>, <a class="el" href="geom_8c-source.html#l02590">fc_getMeshCentroid()</a>, <a class="el" href="mesh_8c-source.html#l03436">fc_getMeshCoordsPtr()</a>, <a class="el" href="mesh_8c-source.html#l03762">fc_getMeshElementConnsPtr()</a>, <a class="el" href="topo_8c-source.html#l00510">fc_getMeshEntityNeighbors()</a>, <a class="el" href="mesh_8c-source.html#l02848">fc_getMeshInfo()</a>, <a class="el" href="util_8c-source.html#l00645">fc_ltd()</a>, <a class="el" href="base_8c-source.html#l00779">FC_NULL_VARIABLE</a>, <a class="el" href="library_8h-source.html#l00154">fc_printfWarningMessage</a>, <a class="el" href="base_8h-source.html#l00104">FC_SUCCESS</a>, <a class="el" href="lib__skeleton_8h-source.html#l00047">FREE</a>, <a class="el" href="lib__skeleton_8h-source.html#l00066">spanning_tree_node_t::id_start</a>, <a class="el" href="lib__skeleton_8h-source.html#l00067">spanning_tree_node_t::id_stop</a>, <a class="el" href="lib__skeleton_8h-source.html#l00046">info</a>, <a class="el" href="lib__skeleton_8h-source.html#l00080">spanning_tree_t::mesh</a>, <a class="el" href="lib__skeleton_8h-source.html#l00085">spanning_tree_t::mesh_is_centers</a>, <a class="el" href="lib__skeleton_8h-source.html#l00077">spanning_tree_t::nodes</a>, <a class="el" href="lib__skeleton_8h-source.html#l00070">spanning_tree_node_t::num_ancestors</a>, <a class="el" href="lib__skeleton_8h-source.html#l00069">spanning_tree_node_t::num_descendants</a>, <a class="el" href="lib__skeleton_8h-source.html#l00082">spanning_tree_t::numElement</a>, <a class="el" href="lib__skeleton_8h-source.html#l00076">spanning_tree_t::numNodes</a>, <a class="el" href="lib__skeleton_8h-source.html#l00075">spanning_tree_t::root</a>, and <a class="el" href="lib__skeleton_8h-source.html#l00083">spanning_tree_t::vertPerElement</a>.</p>

<p>Referenced by <a class="el" href="build__ensemble_8c-source.html#l00236">main()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00343"></a>00343                                              {
<a name="l00344"></a>00344 
<a name="l00345"></a>00345 
<a name="l00346"></a>00346   <a class="code" href="group__DataTypes.html#g2a40aa471d085988d5b582669f766ce4" title="Possible function return values.">FC_ReturnCode</a> rc;
<a name="l00347"></a>00347   <a class="code" href="group__DataTypes.html#g57a0abe7a63cc2c6c9fb0a3db339884a" title="Possible element types.">FC_ElementType</a> elemType;
<a name="l00348"></a>00348 
<a name="l00349"></a>00349   <span class="keywordtype">int</span> numElement, vertPerElement;
<a name="l00350"></a>00350   
<a name="l00351"></a>00351   <span class="keywordtype">double</span> *elem_centers;
<a name="l00352"></a>00352 
<a name="l00353"></a>00353   <span class="keywordtype">int</span> dim;
<a name="l00354"></a>00354   <a class="code" href="group__SimpleDataObjects.html#gf0a2bdabac4a21b42f4b480baf9128d7" title="Coordinates data structure.">FC_Coords</a> centroid_coord;
<a name="l00355"></a>00355 
<a name="l00356"></a>00356   <span class="keywordtype">int</span> i,j;
<a name="l00357"></a>00357   <span class="keywordtype">double</span> dist,best_dist;
<a name="l00358"></a>00358   <span class="keywordtype">int</span> spot, prv_spot, best_spot;
<a name="l00359"></a>00359   <span class="keywordtype">double</span> *mesh_coords;
<a name="l00360"></a>00360 
<a name="l00361"></a>00361   <a class="code" href="structspanning__tree__node__t.html">spanning_tree_node_t</a>  *assembly, *neighbor;
<a name="l00362"></a>00362   <span class="keywordtype">int</span> assembly_num, neighbor_num;
<a name="l00363"></a>00363   
<a name="l00364"></a>00364   <span class="keywordtype">int</span> *elem_conns;
<a name="l00365"></a>00365 
<a name="l00366"></a>00366   <span class="keywordtype">int</span> *new_neighbors;
<a name="l00367"></a>00367   <span class="keywordtype">int</span> new_neighbors_num;
<a name="l00368"></a>00368 
<a name="l00369"></a>00369   <span class="keyword">const</span> <span class="keywordtype">int</span> NEIGHBOR_SEARCH_DIM = 1; <span class="comment">//1=can share edges, 2=can only share faces</span>
<a name="l00370"></a>00370 
<a name="l00371"></a>00371   <span class="keywordtype">char</span> *visited_mask;
<a name="l00372"></a>00372 
<a name="l00373"></a>00373 
<a name="l00374"></a>00374 
<a name="l00375"></a>00375   <span class="comment">//Get basic info about the mesh and elements</span>
<a name="l00376"></a>00376   rc = <a class="code" href="group__Mesh.html#ged61b1f684fc2a6ac489c10841cdb591" title="Get information about a mesh.">fc_getMeshInfo</a>(m, NULL, &amp;dim, NULL, &amp;numElement, &amp;elemType); <a class="code" href="group__ErrorHandling.html#gcc9949110ba62c7ec8fabf7b455f1c0b" title="If the return code is an error, print diagnostic and exit.">fc_exitIfError</a>(rc);
<a name="l00377"></a>00377   vertPerElement = <a class="code" href="group__DataTypes.html#g2a400f7126e79f149032162c87c4eee8" title="Returns number of vertices in a type of element.">fc_getElementTypeNumVertex</a>(elemType);
<a name="l00378"></a>00378   rc = <a class="code" href="group__Mesh.html#gff8561557c19ae03be9ff18cc73a6823" title="Return the vertex coordinates of the mesh.">fc_getMeshCoordsPtr</a>(m, &amp;mesh_coords); <a class="code" href="group__ErrorHandling.html#gcc9949110ba62c7ec8fabf7b455f1c0b" title="If the return code is an error, print diagnostic and exit.">fc_exitIfError</a>(rc);
<a name="l00379"></a>00379 
<a name="l00380"></a>00380   <span class="comment">//Get the element connectivity list</span>
<a name="l00381"></a>00381   rc = <a class="code" href="group__Mesh.html#g19906bcae562d226991740da142000c0" title="Return element to vertex connectivities for the mesh.">fc_getMeshElementConnsPtr</a>(m, &amp;elem_conns); <a class="code" href="group__ErrorHandling.html#gcc9949110ba62c7ec8fabf7b455f1c0b" title="If the return code is an error, print diagnostic and exit.">fc_exitIfError</a>(rc);
<a name="l00382"></a>00382 
<a name="l00383"></a>00383 
<a name="l00384"></a>00384   <span class="comment">//First find the centers for all the elements</span>
<a name="l00385"></a>00385   rc = <a class="code" href="lib__skeleton_8c.html#3764a93ca0b255a7955d588ff5f2c2b6">fc_getElementCenters</a>(m, <a class="code" href="group__Handles.html#g82162b8ad3f5476855507c3c6450db09" title="Null (default) variable handle.">FC_NULL_VARIABLE</a>, &amp;elem_centers); <a class="code" href="group__ErrorHandling.html#gcc9949110ba62c7ec8fabf7b455f1c0b" title="If the return code is an error, print diagnostic and exit.">fc_exitIfError</a>(rc);
<a name="l00386"></a>00386 
<a name="l00387"></a>00387 
<a name="l00388"></a>00388   <span class="comment">//Next, get a starting point for the skeleton</span>
<a name="l00389"></a>00389   <span class="keywordflow">if</span>(starting_element_id&lt;0){
<a name="l00390"></a>00390     <span class="comment">//Unknown starting point. Find the centroid..</span>
<a name="l00391"></a>00391     rc = <a class="code" href="group__GeometricRelations.html#g0534cc7d9f5baa778499d7025a7bf4c9" title="Compute centroid of mesh.">fc_getMeshCentroid</a>(m, &amp;dim, &amp;centroid_coord); <a class="code" href="group__ErrorHandling.html#gcc9949110ba62c7ec8fabf7b455f1c0b" title="If the return code is an error, print diagnostic and exit.">fc_exitIfError</a>(rc);
<a name="l00392"></a>00392 
<a name="l00393"></a>00393     <span class="comment">//Then locate element that's closest.. BAD-Can be Wrong. TBD: find element that actually contains</span>
<a name="l00394"></a>00394     best_dist = DBL_MAX;
<a name="l00395"></a>00395     best_spot = 0;
<a name="l00396"></a>00396     <span class="keywordflow">for</span>(i=0; i&lt;numElement; i++){
<a name="l00397"></a>00397       rc = <a class="code" href="group__GeometricRelations.html#gf1520cdaf3f984812aae127263fcd864" title="Compute the squared distance between two vertices.">fc_calcSquaredEuclideanDistance</a>(centroid_coord, &amp;elem_centers[i*dim], dim, &amp;dist);
<a name="l00398"></a>00398       <a class="code" href="group__ErrorHandling.html#gcc9949110ba62c7ec8fabf7b455f1c0b" title="If the return code is an error, print diagnostic and exit.">fc_exitIfError</a>(rc);
<a name="l00399"></a>00399       <span class="keywordflow">if</span>(dist&lt;best_dist){
<a name="l00400"></a>00400      best_dist = dist;
<a name="l00401"></a>00401      best_spot = i;
<a name="l00402"></a>00402       }
<a name="l00403"></a>00403     }
<a name="l00404"></a>00404     starting_element_id = best_spot;
<a name="l00405"></a>00405     <a class="code" href="lib__skeleton_8h.html#15989531a38db782bfe33ebed139dad7">dbg</a>(<span class="stringliteral">"Starting point for tree generated by nearest element\n"</span>
<a name="l00406"></a>00406      <span class="stringliteral">"  Mesh centroid is (%.3f,%.3f,%.3f). Nearest element is %d, with center (%.3f,%.3f,%.3f)"</span>,
<a name="l00407"></a>00407         centroid_coord[0], centroid_coord[1], centroid_coord[2],
<a name="l00408"></a>00408         best_spot,
<a name="l00409"></a>00409         elem_centers[best_spot*dim + 0],
<a name="l00410"></a>00410         elem_centers[best_spot*dim + 1],
<a name="l00411"></a>00411         elem_centers[best_spot*dim + 2]);
<a name="l00412"></a>00412 
<a name="l00413"></a>00413   } <span class="keywordflow">else</span> {
<a name="l00414"></a>00414     assert(starting_element_id&lt;numElement);
<a name="l00415"></a>00415     <a class="code" href="lib__skeleton_8h.html#15989531a38db782bfe33ebed139dad7">dbg</a>(<span class="stringliteral">"Starting point for tree specified by user as element %d, which has center (%.3f, %.3f, %.3f)"</span>,
<a name="l00416"></a>00416      starting_element_id,
<a name="l00417"></a>00417      elem_centers[best_spot*dim + 0],
<a name="l00418"></a>00418      elem_centers[best_spot*dim + 1],
<a name="l00419"></a>00419      elem_centers[best_spot*dim + 2]);
<a name="l00420"></a>00420   }
<a name="l00421"></a>00421 
<a name="l00422"></a>00422 
<a name="l00423"></a>00423 
<a name="l00424"></a>00424   <span class="comment">//Create space for everything</span>
<a name="l00425"></a>00425   assembly = (<a class="code" href="structspanning__tree__node__t.html">spanning_tree_node_t</a> *)malloc((numElement-1)*<span class="keyword">sizeof</span>(<a class="code" href="structspanning__tree__node__t.html">spanning_tree_node_t</a>));
<a name="l00426"></a>00426   neighbor = (<a class="code" href="structspanning__tree__node__t.html">spanning_tree_node_t</a> *)malloc(numElement*<span class="keyword">sizeof</span>(<a class="code" href="structspanning__tree__node__t.html">spanning_tree_node_t</a>));
<a name="l00427"></a>00427   visited_mask = (<span class="keywordtype">char</span> *)calloc(numElement,<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));
<a name="l00428"></a>00428 
<a name="l00429"></a>00429   <span class="comment">//Start with no neighbors and the starting element in the assembly</span>
<a name="l00430"></a>00430   assembly_num  = 0;
<a name="l00431"></a>00431   neighbor_num  = 0;
<a name="l00432"></a>00432   prv_spot = starting_element_id;
<a name="l00433"></a>00433 
<a name="l00434"></a>00434   <span class="comment">//Main loop for building tree</span>
<a name="l00435"></a>00435   <span class="keywordflow">do</span>{
<a name="l00436"></a>00436 
<a name="l00437"></a>00437     <span class="comment">//printf("Assembly num: %d  Neighbor num: %d  prv_spot=%d spot=%d\n", </span>
<a name="l00438"></a>00438     <span class="comment">//        assembly_num, neighbor_num, prv_spot, spot);</span>
<a name="l00439"></a>00439 
<a name="l00440"></a>00440     <span class="comment">//Find the new guy's neighbors</span>
<a name="l00441"></a>00441     <span class="comment">//prv_spot = assembly[assembly_num-1].id_stop;</span>
<a name="l00442"></a>00442     rc = <a class="code" href="group__TopologyRelations.html#g6ee1028bf4343f79d907b41cc0d108c4" title="Get the neighbors of a mesh subentity.">fc_getMeshEntityNeighbors</a>(m, prv_spot, <a class="code" href="group__DataTypes.html#gg28b7cdba59395ddc988888d01dd19af690a2a90b49747de25e69b3bfdad27f4a">FC_AT_ELEMENT</a>, NEIGHBOR_SEARCH_DIM, &amp;new_neighbors_num, &amp;new_neighbors);
<a name="l00443"></a>00443     <a class="code" href="group__ErrorHandling.html#gcc9949110ba62c7ec8fabf7b455f1c0b" title="If the return code is an error, print diagnostic and exit.">fc_exitIfError</a>(rc);
<a name="l00444"></a>00444 
<a name="l00445"></a>00445     <span class="comment">//Insert all of the new neighbors into list, and update shorter paths</span>
<a name="l00446"></a>00446     <span class="keywordflow">for</span>(i=0; i&lt;new_neighbors_num; i++){
<a name="l00447"></a>00447       <span class="keywordtype">double</span> dist_center;
<a name="l00448"></a>00448 
<a name="l00449"></a>00449       spot = new_neighbors[i];
<a name="l00450"></a>00450       assert((spot&gt;=0)&amp;&amp;(spot&lt;numElement));
<a name="l00451"></a>00451 
<a name="l00452"></a>00452       <span class="comment">//See if we already part of the assembly (means it must already have a smaller distance)</span>
<a name="l00453"></a>00453       <span class="keywordflow">if</span>(spot==starting_element_id) <span class="keywordflow">continue</span>; <span class="comment">//Looped back to root</span>
<a name="l00454"></a>00454       
<a name="l00455"></a>00455 <span class="preprocessor">      #if 0 //previously a linear search </span>
<a name="l00456"></a>00456 <span class="preprocessor"></span>        <span class="keywordflow">for</span>(j=0;(j&lt;assembly_num) &amp;&amp; (assembly[j].id_stop != spot); j++); <span class="comment">//Scan all non-roots</span>
<a name="l00457"></a>00457         <span class="keywordflow">if</span>(j!=assembly_num) <span class="keywordflow">continue</span>; <span class="comment">//Already a member, skip</span>
<a name="l00458"></a>00458 <span class="preprocessor">      #else </span>
<a name="l00459"></a>00459 <span class="preprocessor"></span>     <span class="keywordflow">if</span>(visited_mask[spot]) <span class="keywordflow">continue</span>;
<a name="l00460"></a>00460 <span class="preprocessor">      #endif</span>
<a name="l00461"></a>00461 <span class="preprocessor"></span>
<a name="l00462"></a>00462 
<a name="l00463"></a>00463       <span class="comment">//Find the distance between the centers</span>
<a name="l00464"></a>00464       rc = <a class="code" href="group__GeometricRelations.html#gf1520cdaf3f984812aae127263fcd864" title="Compute the squared distance between two vertices.">fc_calcSquaredEuclideanDistance</a>(&amp;elem_centers[prv_spot*dim], 
<a name="l00465"></a>00465                             &amp;elem_centers[    spot*dim], dim, &amp;dist_center);
<a name="l00466"></a>00466       <a class="code" href="group__ErrorHandling.html#gcc9949110ba62c7ec8fabf7b455f1c0b" title="If the return code is an error, print diagnostic and exit.">fc_exitIfError</a>(rc);
<a name="l00467"></a>00467       dist_center = sqrt(dist_center); <span class="comment">//needs to be Euclidean distance in order to be valid</span>
<a name="l00468"></a>00468 
<a name="l00469"></a>00469       <span class="keywordflow">if</span>(assembly_num)
<a name="l00470"></a>00470      dist_center += assembly[assembly_num-1].<a class="code" href="structspanning__tree__node__t.html#5e905b8fea407e8c86606ffc956cd4ef">dist_center</a>; <span class="comment">//Add in previous distance</span>
<a name="l00471"></a>00471 
<a name="l00472"></a>00472 
<a name="l00473"></a>00473       <span class="comment">//See if we have this on the neighbor list</span>
<a name="l00474"></a>00474       <span class="keywordflow">for</span>(j=0; (j&lt;neighbor_num) &amp;&amp; (neighbor[j].id_stop != spot); j++);
<a name="l00475"></a>00475 
<a name="l00476"></a>00476 
<a name="l00477"></a>00477 
<a name="l00478"></a>00478 <span class="preprocessor">#if 1</span>
<a name="l00479"></a>00479 <span class="preprocessor"></span>      <span class="keywordflow">if</span>(j!=neighbor_num){
<a name="l00480"></a>00480      <span class="keywordtype">double</span> tmp_dist;
<a name="l00481"></a>00481 
<a name="l00482"></a>00482      tmp_dist = dist_center;
<a name="l00483"></a>00483 
<a name="l00484"></a>00484      <span class="keywordflow">if</span>(<a class="code" href="group__PublicFloatingPoint.html#g586cfa132ea1f36cba13311e8e994c03" title="Test if two doubles are equal, assuming double precision.">fc_eqd</a>(neighbor[j].dist_center, tmp_dist)){
<a name="l00485"></a>00485        <span class="comment">//Equals case requires special handling. Chose based on id</span>
<a name="l00486"></a>00486        <span class="keywordflow">if</span>(neighbor[j].id_stop &lt; spot) <span class="keywordflow">continue</span>; <span class="comment">//already have a lower id</span>
<a name="l00487"></a>00487        <span class="comment">//otherwise replace it</span>
<a name="l00488"></a>00488      } <span class="keywordflow">else</span> {
<a name="l00489"></a>00489        <span class="comment">//Not Equals case just needs a threshold</span>
<a name="l00490"></a>00490        <span class="keywordflow">if</span>(<a class="code" href="group__PublicFloatingPoint.html#g9b72da62722becc8bf11b5eea7854bf9" title="Test if the first double is less than the second double, assuming double precision...">fc_ltd</a>(neighbor[j].dist_center,tmp_dist)) <span class="keywordflow">continue</span>; 
<a name="l00491"></a>00491      }
<a name="l00492"></a>00492      
<a name="l00493"></a>00493       }
<a name="l00494"></a>00494 <span class="preprocessor">#else</span>
<a name="l00495"></a>00495 <span class="preprocessor"></span>      <span class="comment">//Bail out if we already know a closer distance to this node</span>
<a name="l00496"></a>00496       <span class="keywordflow">if</span>((j!=neighbor_num) &amp;&amp; 
<a name="l00497"></a>00497       (<a class="code" href="group__PublicFloatingPoint.html#g9b72da62722becc8bf11b5eea7854bf9" title="Test if the first double is less than the second double, assuming double precision...">fc_ltd</a>(neighbor[j].dist_center,dist_center))) <span class="keywordflow">continue</span>;
<a name="l00498"></a>00498 <span class="preprocessor">#endif</span>
<a name="l00499"></a>00499 <span class="preprocessor"></span>
<a name="l00500"></a>00500       neighbor[j].<a class="code" href="structspanning__tree__node__t.html#a7f8f7a44d9a169bf101223b7106d91a">id_stop</a>           = spot;
<a name="l00501"></a>00501       neighbor[j].<a class="code" href="structspanning__tree__node__t.html#e63a247a928451c07c9ee6b20a0f393b">id_start</a>          = prv_spot;
<a name="l00502"></a>00502       neighbor[j].<a class="code" href="structspanning__tree__node__t.html#5e905b8fea407e8c86606ffc956cd4ef">dist_center</a>       = dist_center;
<a name="l00503"></a>00503       
<a name="l00504"></a>00504       neighbor[j].<a class="code" href="structspanning__tree__node__t.html#48095c9cb31a1f850c5eb6e1a843de1e">num_descendants</a>   = 0;
<a name="l00505"></a>00505       neighbor[j].<a class="code" href="structspanning__tree__node__t.html#96be82e2c2d02cb47d9e71c2938a9ced">num_ancestors</a>     = 0;
<a name="l00506"></a>00506       
<a name="l00507"></a>00507       <span class="keywordflow">if</span>(j==neighbor_num) neighbor_num++; <span class="comment">//Only on appends</span>
<a name="l00508"></a>00508     }
<a name="l00509"></a>00509     <span class="keywordflow">if</span>(new_neighbors) <a class="code" href="lib__skeleton_8h.html#834f31033781e091a3dbdfe16f7e8285">FREE</a>(new_neighbors);
<a name="l00510"></a>00510 
<a name="l00511"></a>00511     <span class="comment">//Possible that starting node had no neighbors. In that case, terminate now</span>
<a name="l00512"></a>00512     <span class="keywordflow">if</span>(!neighbor_num) <span class="keywordflow">break</span>; 
<a name="l00513"></a>00513 
<a name="l00514"></a>00514     <span class="comment">//Find the shortest distance in the list</span>
<a name="l00515"></a>00515     dist = DBL_MAX;
<a name="l00516"></a>00516     best_spot = 0;
<a name="l00517"></a>00517     <span class="keywordflow">for</span>(i=0; i&lt;neighbor_num; i++) {
<a name="l00518"></a>00518 
<a name="l00519"></a>00519 <span class="preprocessor">#if 1</span>
<a name="l00520"></a>00520 <span class="preprocessor"></span>      <span class="keywordflow">if</span>(<a class="code" href="group__PublicFloatingPoint.html#g586cfa132ea1f36cba13311e8e994c03" title="Test if two doubles are equal, assuming double precision.">fc_eqd</a>(neighbor[i].dist_center,dist)){
<a name="l00521"></a>00521      <span class="keywordflow">if</span>(neighbor[i].id_stop &lt; best_spot){
<a name="l00522"></a>00522        dist = neighbor[i].<a class="code" href="structspanning__tree__node__t.html#5e905b8fea407e8c86606ffc956cd4ef">dist_center</a>;
<a name="l00523"></a>00523        best_spot = i;
<a name="l00524"></a>00524      }
<a name="l00525"></a>00525       }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(<a class="code" href="group__PublicFloatingPoint.html#g9b72da62722becc8bf11b5eea7854bf9" title="Test if the first double is less than the second double, assuming double precision...">fc_ltd</a>(neighbor[i].dist_center,dist)){
<a name="l00526"></a>00526      dist = neighbor[i].<a class="code" href="structspanning__tree__node__t.html#5e905b8fea407e8c86606ffc956cd4ef">dist_center</a>;
<a name="l00527"></a>00527      best_spot = i;
<a name="l00528"></a>00528       }
<a name="l00529"></a>00529 
<a name="l00530"></a>00530 <span class="preprocessor">#else</span>
<a name="l00531"></a>00531 <span class="preprocessor"></span>      <span class="keywordflow">if</span>(<a class="code" href="group__PublicFloatingPoint.html#g9b72da62722becc8bf11b5eea7854bf9" title="Test if the first double is less than the second double, assuming double precision...">fc_ltd</a>(neighbor[i].dist_center,dist)){
<a name="l00532"></a>00532      dist = neighbor[i].<a class="code" href="structspanning__tree__node__t.html#5e905b8fea407e8c86606ffc956cd4ef">dist_center</a>;
<a name="l00533"></a>00533      best_spot = i;
<a name="l00534"></a>00534       }
<a name="l00535"></a>00535       
<a name="l00536"></a>00536 <span class="preprocessor">#endif</span>
<a name="l00537"></a>00537 <span class="preprocessor"></span>
<a name="l00538"></a>00538     }
<a name="l00539"></a>00539 
<a name="l00540"></a>00540     <span class="comment">//Promote to the assembly</span>
<a name="l00541"></a>00541     assert(assembly_num&lt;numElement-1);
<a name="l00542"></a>00542 
<a name="l00543"></a>00543     assembly[assembly_num] = neighbor[best_spot];
<a name="l00544"></a>00544     visited_mask[assembly[assembly_num].<a class="code" href="structspanning__tree__node__t.html#a7f8f7a44d9a169bf101223b7106d91a">id_stop</a>]=1;
<a name="l00545"></a>00545     assembly_num++;
<a name="l00546"></a>00546     prv_spot = neighbor[best_spot].<a class="code" href="structspanning__tree__node__t.html#a7f8f7a44d9a169bf101223b7106d91a">id_stop</a>;
<a name="l00547"></a>00547 
<a name="l00548"></a>00548 
<a name="l00549"></a>00549     <span class="comment">//Remove from neighbor list</span>
<a name="l00550"></a>00550     <span class="keywordflow">for</span>(i=best_spot; i&lt;neighbor_num; i++)
<a name="l00551"></a>00551       neighbor[i] = neighbor[i+1];
<a name="l00552"></a>00552     neighbor_num--;
<a name="l00553"></a>00553 
<a name="l00554"></a>00554     <span class="comment">//if((neighbor_num%100)==0) printf("Spanning Neighbor num: %d\n", neighbor_num);</span>
<a name="l00555"></a>00555 
<a name="l00556"></a>00556   } <span class="keywordflow">while</span>(neighbor_num&gt;0);
<a name="l00557"></a>00557 
<a name="l00558"></a>00558   <a class="code" href="lib__skeleton_8h.html#15989531a38db782bfe33ebed139dad7">dbg</a>(<span class="stringliteral">"Finished generating neighbors"</span>);
<a name="l00559"></a>00559 
<a name="l00560"></a>00560   <a class="code" href="lib__skeleton_8h.html#834f31033781e091a3dbdfe16f7e8285">FREE</a>(visited_mask);
<a name="l00561"></a>00561 
<a name="l00562"></a>00562   <span class="comment">//Sort nodes that have the same distance. We do this to make sure we produce</span>
<a name="l00563"></a>00563   <span class="comment">//identical trees with no ambiguity</span>
<a name="l00564"></a>00564   <span class="comment">//for(i=0; i&lt;assembly_num; i+=j){</span>
<a name="l00565"></a>00565   <span class="comment">//  for(j=1; ((i+j)&lt;assembly_num) &amp;&amp; (assembly[i+j].dist_center == assembly[i].dist_center); j++);</span>
<a name="l00566"></a>00566   <span class="comment">//  if(j!=1){</span>
<a name="l00567"></a>00567   <span class="comment">//  }</span>
<a name="l00568"></a>00568   <span class="comment">//}</span>
<a name="l00569"></a>00569 
<a name="l00570"></a>00570 
<a name="l00571"></a>00571   <span class="keywordflow">if</span>(assembly_num&lt;=1){
<a name="l00572"></a>00572     <a class="code" href="group__Library.html#g160cfb8cb557ccf48fee07ae11e65482" title="Print a warning message to stdout.">fc_printfWarningMessage</a>(<span class="stringliteral">"Selected element does not have any neighbors\n"</span>);
<a name="l00573"></a>00573   }
<a name="l00574"></a>00574 
<a name="l00575"></a>00575 
<a name="l00576"></a>00576   <span class="keywordflow">if</span>(tree){
<a name="l00577"></a>00577     <a class="code" href="structspanning__tree__t.html">spanning_tree_t</a> *t;
<a name="l00578"></a>00578     t = (<a class="code" href="structspanning__tree__t.html">spanning_tree_t</a> *)malloc(<span class="keyword">sizeof</span>(<a class="code" href="structspanning__tree__t.html">spanning_tree_t</a>));
<a name="l00579"></a>00579     t-&gt;<a class="code" href="structspanning__tree__t.html#2f7ebb14ff208bc06e6a184175c8b8ff">root</a>                    = starting_element_id;
<a name="l00580"></a>00580     t-&gt;<a class="code" href="structspanning__tree__t.html#5ccb47c8e349067ee6017e091d02306e">numNodes</a>                = assembly_num;
<a name="l00581"></a>00581     t-&gt;<a class="code" href="structspanning__tree__t.html#31d1d9e54040f7634f16cdddd1c24760">nodes</a>                   = realloc(assembly, assembly_num*<span class="keyword">sizeof</span>(<a class="code" href="structspanning__tree__node__t.html">spanning_tree_node_t</a>)); 
<a name="l00582"></a>00582     t-&gt;<a class="code" href="structspanning__tree__t.html#8047cfbd3e20f76c779de639f2b0b04f">mesh</a>                    = m;
<a name="l00583"></a>00583     t-&gt;<a class="code" href="structspanning__tree__t.html#6aca20c85f139938862367cc664ef52f">dim</a>                     = dim;
<a name="l00584"></a>00584     t-&gt;<a class="code" href="structspanning__tree__t.html#602d7926e681ac4e1ca97843dabd2d4e">numElement</a>              = numElement;
<a name="l00585"></a>00585     t-&gt;<a class="code" href="structspanning__tree__t.html#f9002a43ce333db472d65c97f8f73d90">vertPerElement</a>          = vertPerElement;
<a name="l00586"></a>00586     t-&gt;<a class="code" href="structspanning__tree__t.html#4a6035ff3412486e6beff9f9a636401b">elementCenters</a>          = elem_centers;
<a name="l00587"></a>00587     t-&gt;<a class="code" href="structspanning__tree__t.html#e13fa21139ec7c4675d4703b48ab0898">mesh_is_centers</a>         = 0;
<a name="l00588"></a>00588     
<a name="l00589"></a>00589     rc = <a class="code" href="lib__skeleton_8c.html#dd3df4be2e7ca2ba3f19258cffb2e08a">fc_computeTreeDescendantsAncestors</a>(t);
<a name="l00590"></a>00590     *tree = t;
<a name="l00591"></a>00591 
<a name="l00592"></a>00592   } <span class="keywordflow">else</span> {
<a name="l00593"></a>00593     <a class="code" href="lib__skeleton_8h.html#834f31033781e091a3dbdfe16f7e8285">FREE</a>(elem_centers);
<a name="l00594"></a>00594     <a class="code" href="lib__skeleton_8h.html#834f31033781e091a3dbdfe16f7e8285">FREE</a>(assembly);
<a name="l00595"></a>00595     rc = <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce46687acb19dbc2e15e6e89cdc39e8e18e">FC_SUCCESS</a>;
<a name="l00596"></a>00596   }
<a name="l00597"></a>00597     
<a name="l00598"></a>00598   <a class="code" href="lib__skeleton_8h.html#0017ada9be12f3b512275e039cff6f26">info</a>(<span class="stringliteral">"Done generating tree"</span>);
<a name="l00599"></a>00599 
<a name="l00600"></a>00600   <span class="keywordflow">return</span> rc;
<a name="l00601"></a>00601  
<a name="l00602"></a>00602 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="eff58d67e5060be9f0f284711530c02b"></a><!-- doxytag: member="lib_skeleton.h::fc_saveSkeleton" ref="eff58d67e5060be9f0f284711530c02b" args="(spanning_tree_t tree, char *displacement_var_name, char *file_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DataTypes.html#g2a40aa471d085988d5b582669f766ce4">FC_ReturnCode</a> fc_saveSkeleton           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structspanning__tree__t.html">spanning_tree_t</a>&nbsp;</td>
          <td class="paramname"> <em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>displacement_var_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>file_name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="lib__skeleton_8c-source.html#l00651">651</a> of file <a class="el" href="lib__skeleton_8c-source.html">lib_skeleton.c</a>.</p>

<p>References <a class="el" href="lib__skeleton_8h-source.html#l00045">dbg</a>, <a class="el" href="lib__skeleton_8h-source.html#l00081">spanning_tree_t::dim</a>, <a class="el" href="lib__skeleton_8c-source.html#l00624">doesSeqVarExist()</a>, <a class="el" href="lib__skeleton_8h-source.html#l00084">spanning_tree_t::elementCenters</a>, <a class="el" href="lib__skeleton_8h-source.html#l00044">emsg</a>, <a class="el" href="base_8h-source.html#l00191">FC_AT_VERTEX</a>, <a class="el" href="sequence_8c-source.html#l00310">fc_copySequence()</a>, <a class="el" href="dataset_8c-source.html#l00116">fc_createDataset()</a>, <a class="el" href="mesh_8c-source.html#l00119">fc_createMesh()</a>, <a class="el" href="variable_8c-source.html#l00350">fc_createSeqVariable()</a>, <a class="el" href="mesh_8c-source.html#l01949">fc_createSphereMesh()</a>, <a class="el" href="variable_8c-source.html#l00286">fc_createVariable()</a>, <a class="el" href="base_8h-source.html#l00150">FC_DT_DOUBLE</a>, <a class="el" href="base_8h-source.html#l00143">FC_DT_INT</a>, <a class="el" href="base_8h-source.html#l00121">FC_ET_LINE</a>, <a class="el" href="error_8h-source.html#l00080">fc_exitIfError</a>, <a class="el" href="fileio_8h-source.html#l00081">FC_FT_EXODUS</a>, <a class="el" href="lib__skeleton_8c-source.html#l00107">fc_getElementCenters()</a>, <a class="el" href="mesh_8c-source.html#l03762">fc_getMeshElementConnsPtr()</a>, <a class="el" href="variable_8c-source.html#l04695">fc_getOrGenerateUniqueSeqVariableByName()</a>, <a class="el" href="variable_8c-source.html#l05317">fc_getSequenceFromSeqVariable()</a>, <a class="el" href="variable_8c-source.html#l05715">fc_getVariableDataPtr()</a>, <a class="el" href="base_8h-source.html#l00107">FC_INPUT_ERROR</a>, <a class="el" href="base_8h-source.html#l00170">FC_MT_SCALAR</a>, <a class="el" href="base_8h-source.html#l00171">FC_MT_VECTOR</a>, <a class="el" href="library_8h-source.html#l00120">fc_printfErrorMessage</a>, <a class="el" href="library_8h-source.html#l00154">fc_printfWarningMessage</a>, <a class="el" href="mesh_8c-source.html#l00193">fc_setMeshCoords()</a>, <a class="el" href="mesh_8c-source.html#l00321">fc_setMeshElementConns()</a>, <a class="el" href="mesh_8c-source.html#l02091">fc_setSphereDisplacementVariable()</a>, <a class="el" href="variable_8c-source.html#l00604">fc_setVariableDataPtr()</a>, <a class="el" href="base_8h-source.html#l00104">FC_SUCCESS</a>, <a class="el" href="fileio_8c-source.html#l01706">fc_writeDataset()</a>, <a class="el" href="lib__skeleton_8h-source.html#l00066">spanning_tree_node_t::id_start</a>, <a class="el" href="lib__skeleton_8h-source.html#l00067">spanning_tree_node_t::id_stop</a>, <a class="el" href="lib__skeleton_8h-source.html#l00080">spanning_tree_t::mesh</a>, <a class="el" href="lib__skeleton_8h-source.html#l00085">spanning_tree_t::mesh_is_centers</a>, <a class="el" href="lib__skeleton_8h-source.html#l00077">spanning_tree_t::nodes</a>, <a class="el" href="lib__skeleton_8h-source.html#l00070">spanning_tree_node_t::num_ancestors</a>, <a class="el" href="lib__skeleton_8h-source.html#l00069">spanning_tree_node_t::num_descendants</a>, <a class="el" href="lib__skeleton_8h-source.html#l00082">spanning_tree_t::numElement</a>, <a class="el" href="lib__skeleton_8h-source.html#l00076">spanning_tree_t::numNodes</a>, and <a class="el" href="lib__skeleton_8h-source.html#l00075">spanning_tree_t::root</a>.</p>

<p>Referenced by <a class="el" href="generate__tree_8c-source.html#l00197">main()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00654"></a>00654                                      {
<a name="l00655"></a>00655 
<a name="l00656"></a>00656   <a class="code" href="structFC__Mesh.html" title="Mesh Handle.">FC_Mesh</a> m_src;
<a name="l00657"></a>00657 
<a name="l00658"></a>00658   <a class="code" href="structFC__Dataset.html" title="Dataset Handle.">FC_Dataset</a> ds_skel;
<a name="l00659"></a>00659   <a class="code" href="structFC__Mesh.html" title="Mesh Handle.">FC_Mesh</a> m_skel, m_ball;
<a name="l00660"></a>00660   <a class="code" href="structFC__Variable.html" title="Variable Handle.">FC_Variable</a> v_ancestors, v_descendants;
<a name="l00661"></a>00661   <span class="keywordtype">int</span> *tmp_ancestors, *tmp_descendants;
<a name="l00662"></a>00662 
<a name="l00663"></a>00663   <a class="code" href="group__DataTypes.html#g2a40aa471d085988d5b582669f766ce4" title="Possible function return values.">FC_ReturnCode</a> rc;
<a name="l00664"></a>00664   <span class="keywordtype">int</span> *id_conns;
<a name="l00665"></a>00665   <span class="keywordtype">int</span> numElement;
<a name="l00666"></a>00666   <span class="keywordtype">int</span> i,j;
<a name="l00667"></a>00667 
<a name="l00668"></a>00668   <span class="keywordtype">int</span> dim;
<a name="l00669"></a>00669   <span class="keywordtype">double</span> *coords;
<a name="l00670"></a>00670   <span class="keywordtype">int</span> numCoords, numLinks;
<a name="l00671"></a>00671 
<a name="l00672"></a>00672   <span class="keyword">const</span> <span class="keywordtype">double</span> ball_radius = 2.0;
<a name="l00673"></a>00673   <span class="keyword">const</span> <span class="keywordtype">int</span>    ball_points = 256;
<a name="l00674"></a>00674 
<a name="l00675"></a>00675   <span class="comment">//if(tree.num_nodes&lt;1){</span>
<a name="l00676"></a>00676     <span class="comment">//tbd: more checking</span>
<a name="l00677"></a>00677   <span class="comment">//  return FC_INPUT_ERROR;</span>
<a name="l00678"></a>00678   <span class="comment">//}</span>
<a name="l00679"></a>00679 
<a name="l00680"></a>00680 
<a name="l00681"></a>00681 
<a name="l00682"></a>00682   <span class="keywordflow">if</span>(tree.<a class="code" href="structspanning__tree__t.html#5ccb47c8e349067ee6017e091d02306e">numNodes</a>&lt;1){
<a name="l00683"></a>00683     <a class="code" href="group__Library.html#g1473e77471cd1319f76eb9a32e4ad91f" title="Print an error message to stderr.">fc_printfErrorMessage</a>(<span class="stringliteral">"Skeleton did not have any links in it\n"</span>);
<a name="l00684"></a>00684     <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce464a3d55131c355cdf036f95d0d7e1a6e">FC_INPUT_ERROR</a>;
<a name="l00685"></a>00685   }
<a name="l00686"></a>00686 
<a name="l00687"></a>00687   
<a name="l00688"></a>00688   <span class="comment">//elem_centers = tree.element_centers;</span>
<a name="l00689"></a>00689   dim          = tree.<a class="code" href="structspanning__tree__t.html#6aca20c85f139938862367cc664ef52f">dim</a>;
<a name="l00690"></a>00690   numElement   = tree.<a class="code" href="structspanning__tree__t.html#602d7926e681ac4e1ca97843dabd2d4e">numElement</a>;
<a name="l00691"></a>00691   m_src        = tree.<a class="code" href="structspanning__tree__t.html#8047cfbd3e20f76c779de639f2b0b04f">mesh</a>;
<a name="l00692"></a>00692 
<a name="l00693"></a>00693 
<a name="l00694"></a>00694 
<a name="l00695"></a>00695   <span class="comment">//Simple case: just doing centers</span>
<a name="l00696"></a>00696   
<a name="l00697"></a>00697   numCoords = tree.<a class="code" href="structspanning__tree__t.html#602d7926e681ac4e1ca97843dabd2d4e">numElement</a>;
<a name="l00698"></a>00698   numLinks  = tree.<a class="code" href="structspanning__tree__t.html#5ccb47c8e349067ee6017e091d02306e">numNodes</a>; 
<a name="l00699"></a>00699   
<a name="l00700"></a>00700   <span class="comment">//Coords: made up of all element centers, nothing else</span>
<a name="l00701"></a>00701   coords = (<span class="keywordtype">double</span> *)malloc(numCoords*dim*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l00702"></a>00702   memcpy(coords, tree.<a class="code" href="structspanning__tree__t.html#4a6035ff3412486e6beff9f9a636401b">elementCenters</a>, numCoords*dim*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l00703"></a>00703   
<a name="l00704"></a>00704   <span class="comment">//Conns: every node gets one link</span>
<a name="l00705"></a>00705   id_conns = (<span class="keywordtype">int</span> *) malloc(numLinks*2*<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
<a name="l00706"></a>00706   <span class="keywordflow">for</span>(i=0; i&lt;numLinks; i++){    
<a name="l00707"></a>00707     <span class="comment">//printf("%d/%d start/stop = %d/%d  max=%d\n", i,num_links, links[i+1].id_start, links[i+1].id_stop, numElement);</span>
<a name="l00708"></a>00708     assert((tree.<a class="code" href="structspanning__tree__t.html#31d1d9e54040f7634f16cdddd1c24760">nodes</a>[i].<a class="code" href="structspanning__tree__node__t.html#e63a247a928451c07c9ee6b20a0f393b">id_start</a>&gt;=0) &amp;&amp; (tree.<a class="code" href="structspanning__tree__t.html#31d1d9e54040f7634f16cdddd1c24760">nodes</a>[i].<a class="code" href="structspanning__tree__node__t.html#e63a247a928451c07c9ee6b20a0f393b">id_start</a>&lt;numCoords));
<a name="l00709"></a>00709     assert((tree.<a class="code" href="structspanning__tree__t.html#31d1d9e54040f7634f16cdddd1c24760">nodes</a>[i].<a class="code" href="structspanning__tree__node__t.html#a7f8f7a44d9a169bf101223b7106d91a">id_stop</a> &gt;=0) &amp;&amp; (tree.<a class="code" href="structspanning__tree__t.html#31d1d9e54040f7634f16cdddd1c24760">nodes</a>[i].<a class="code" href="structspanning__tree__node__t.html#a7f8f7a44d9a169bf101223b7106d91a">id_stop</a> &lt;numCoords));
<a name="l00710"></a>00710     
<a name="l00711"></a>00711     id_conns[i*2+0] = tree.<a class="code" href="structspanning__tree__t.html#31d1d9e54040f7634f16cdddd1c24760">nodes</a>[i].<a class="code" href="structspanning__tree__node__t.html#e63a247a928451c07c9ee6b20a0f393b">id_start</a>; <span class="comment">//First entry is not a link, it's </span>
<a name="l00712"></a>00712     id_conns[i*2+1] = tree.<a class="code" href="structspanning__tree__t.html#31d1d9e54040f7634f16cdddd1c24760">nodes</a>[i].<a class="code" href="structspanning__tree__node__t.html#a7f8f7a44d9a169bf101223b7106d91a">id_stop</a>;  <span class="comment">//the origin</span>
<a name="l00713"></a>00713   }
<a name="l00714"></a>00714   
<a name="l00715"></a>00715 
<a name="l00716"></a>00716 
<a name="l00717"></a>00717   <span class="comment">//Create dataset and load it with (1) ball for origin and (2) mesh for skeleton</span>
<a name="l00718"></a>00718   rc=<a class="code" href="group__Dataset.html#g14025fd46757f6fd2943b3bcdcab39d0" title="Create a new dataset.">fc_createDataset</a>(<span class="stringliteral">"skel"</span>, &amp;ds_skel);                                                                         <a class="code" href="group__ErrorHandling.html#gcc9949110ba62c7ec8fabf7b455f1c0b" title="If the return code is an error, print diagnostic and exit.">fc_exitIfError</a>(rc);
<a name="l00719"></a>00719   rc=<a class="code" href="group__Mesh.html#gf1655114af25cd7cc43cd9549a16d0bd" title="Create a simple sphere mesh.">fc_createSphereMesh</a>(ds_skel, <span class="stringliteral">"Tree Origin"</span>, &amp;coords[tree.<a class="code" href="structspanning__tree__t.html#2f7ebb14ff208bc06e6a184175c8b8ff">root</a>*dim], ball_radius, ball_points, &amp;m_ball);       <a class="code" href="group__ErrorHandling.html#gcc9949110ba62c7ec8fabf7b455f1c0b" title="If the return code is an error, print diagnostic and exit.">fc_exitIfError</a>(rc);
<a name="l00720"></a>00720   rc=<a class="code" href="group__Mesh.html#g3928a328006617330e735ca1644e7cb3" title="Create a new mesh.">fc_createMesh</a>(ds_skel, <span class="stringliteral">"skel_mesh"</span>, &amp;m_skel);                                                               <a class="code" href="group__ErrorHandling.html#gcc9949110ba62c7ec8fabf7b455f1c0b" title="If the return code is an error, print diagnostic and exit.">fc_exitIfError</a>(rc);
<a name="l00721"></a>00721   rc=<a class="code" href="group__Mesh.html#gbe7f568d5b8fe72693ad308d15194e01" title="Set the mesh coordinates by copy.">fc_setMeshCoords</a>(m_skel, dim, numCoords, coords);                                                           <a class="code" href="group__ErrorHandling.html#gcc9949110ba62c7ec8fabf7b455f1c0b" title="If the return code is an error, print diagnostic and exit.">fc_exitIfError</a>(rc);
<a name="l00722"></a>00722   rc=<a class="code" href="group__Mesh.html#gd7bb8a0f67d6c0b44edbfe864a53b218" title="Set the mesh element to vertex connectivities by copy.">fc_setMeshElementConns</a>(m_skel, <a class="code" href="group__DataTypes.html#gg57a0abe7a63cc2c6c9fb0a3db339884a80b8143aeefa54756df4ea881fb21fea">FC_ET_LINE</a>, numLinks, id_conns);                                             <a class="code" href="group__ErrorHandling.html#gcc9949110ba62c7ec8fabf7b455f1c0b" title="If the return code is an error, print diagnostic and exit.">fc_exitIfError</a>(rc);
<a name="l00723"></a>00723 
<a name="l00724"></a>00724   <span class="comment">//Create variables for giving the number of ancestors and descendants </span>
<a name="l00725"></a>00725   rc=<a class="code" href="group__Variable.html#ga2ffd025a786dbe93fc7f8defb969631" title="Create a new variable.">fc_createVariable</a>(m_skel, <span class="stringliteral">"num_ancestors"</span>,   &amp;v_ancestors);                                                 <a class="code" href="group__ErrorHandling.html#gcc9949110ba62c7ec8fabf7b455f1c0b" title="If the return code is an error, print diagnostic and exit.">fc_exitIfError</a>(rc);
<a name="l00726"></a>00726   rc=<a class="code" href="group__Variable.html#ga2ffd025a786dbe93fc7f8defb969631" title="Create a new variable.">fc_createVariable</a>(m_skel, <span class="stringliteral">"num_descendants"</span>, &amp;v_descendants);                                               <a class="code" href="group__ErrorHandling.html#gcc9949110ba62c7ec8fabf7b455f1c0b" title="If the return code is an error, print diagnostic and exit.">fc_exitIfError</a>(rc);
<a name="l00727"></a>00727 
<a name="l00728"></a>00728   tmp_ancestors   = (<span class="keywordtype">int</span> *)calloc(numCoords,<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
<a name="l00729"></a>00729   tmp_descendants = (<span class="keywordtype">int</span> *)calloc(numCoords,<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
<a name="l00730"></a>00730   tmp_ancestors[   tree.<a class="code" href="structspanning__tree__t.html#2f7ebb14ff208bc06e6a184175c8b8ff">root</a> ] = 0;
<a name="l00731"></a>00731   tmp_descendants[ tree.<a class="code" href="structspanning__tree__t.html#2f7ebb14ff208bc06e6a184175c8b8ff">root</a> ] = tree.<a class="code" href="structspanning__tree__t.html#5ccb47c8e349067ee6017e091d02306e">numNodes</a>;
<a name="l00732"></a>00732   <span class="keywordflow">for</span>(i=0;i&lt;tree.<a class="code" href="structspanning__tree__t.html#5ccb47c8e349067ee6017e091d02306e">numNodes</a>; i++){
<a name="l00733"></a>00733     tmp_ancestors[   tree.<a class="code" href="structspanning__tree__t.html#31d1d9e54040f7634f16cdddd1c24760">nodes</a>[i].<a class="code" href="structspanning__tree__node__t.html#a7f8f7a44d9a169bf101223b7106d91a">id_stop</a> ] = tree.<a class="code" href="structspanning__tree__t.html#31d1d9e54040f7634f16cdddd1c24760">nodes</a>[i].<a class="code" href="structspanning__tree__node__t.html#96be82e2c2d02cb47d9e71c2938a9ced">num_ancestors</a>;
<a name="l00734"></a>00734     tmp_descendants[ tree.<a class="code" href="structspanning__tree__t.html#31d1d9e54040f7634f16cdddd1c24760">nodes</a>[i].<a class="code" href="structspanning__tree__node__t.html#a7f8f7a44d9a169bf101223b7106d91a">id_stop</a> ] = tree.<a class="code" href="structspanning__tree__t.html#31d1d9e54040f7634f16cdddd1c24760">nodes</a>[i].<a class="code" href="structspanning__tree__node__t.html#48095c9cb31a1f850c5eb6e1a843de1e">num_descendants</a>;
<a name="l00735"></a>00735   }
<a name="l00736"></a>00736 
<a name="l00737"></a>00737   { <span class="comment">//error Check</span>
<a name="l00738"></a>00738     <a class="code" href="lib__skeleton_8h.html#15989531a38db782bfe33ebed139dad7">dbg</a>(<span class="stringliteral">"Root is %d\n"</span>, tree.<a class="code" href="structspanning__tree__t.html#2f7ebb14ff208bc06e6a184175c8b8ff">root</a>);
<a name="l00739"></a>00739     <span class="keywordflow">for</span>(i=0; i&lt;tree.<a class="code" href="structspanning__tree__t.html#5ccb47c8e349067ee6017e091d02306e">numNodes</a>; i++){
<a name="l00740"></a>00740       <span class="keywordflow">if</span>(tree.<a class="code" href="structspanning__tree__t.html#31d1d9e54040f7634f16cdddd1c24760">nodes</a>[i].<a class="code" href="structspanning__tree__node__t.html#96be82e2c2d02cb47d9e71c2938a9ced">num_ancestors</a>&lt;=0)
<a name="l00741"></a>00741      <a class="code" href="lib__skeleton_8h.html#86d286aba1a39e49e5acb2d860e0fe84">emsg</a>(<span class="stringliteral">"spot %d (node %d) had %d ancestors\n"</span>, i, tree.<a class="code" href="structspanning__tree__t.html#31d1d9e54040f7634f16cdddd1c24760">nodes</a>[i].<a class="code" href="structspanning__tree__node__t.html#a7f8f7a44d9a169bf101223b7106d91a">id_stop</a>,tree.<a class="code" href="structspanning__tree__t.html#31d1d9e54040f7634f16cdddd1c24760">nodes</a>[i].<a class="code" href="structspanning__tree__node__t.html#96be82e2c2d02cb47d9e71c2938a9ced">num_ancestors</a> );
<a name="l00742"></a>00742       <a class="code" href="lib__skeleton_8h.html#15989531a38db782bfe33ebed139dad7">dbg</a>(<span class="stringliteral">"spot %d : id %d  anc/dec= %d/%d\n"</span>, i, tree.<a class="code" href="structspanning__tree__t.html#31d1d9e54040f7634f16cdddd1c24760">nodes</a>[i].<a class="code" href="structspanning__tree__node__t.html#a7f8f7a44d9a169bf101223b7106d91a">id_stop</a>,tree.<a class="code" href="structspanning__tree__t.html#31d1d9e54040f7634f16cdddd1c24760">nodes</a>[i].<a class="code" href="structspanning__tree__node__t.html#96be82e2c2d02cb47d9e71c2938a9ced">num_ancestors</a>, tree.<a class="code" href="structspanning__tree__t.html#31d1d9e54040f7634f16cdddd1c24760">nodes</a>[i].<a class="code" href="structspanning__tree__node__t.html#48095c9cb31a1f850c5eb6e1a843de1e">num_descendants</a> );
<a name="l00743"></a>00743     }
<a name="l00744"></a>00744   }
<a name="l00745"></a>00745 
<a name="l00746"></a>00746 
<a name="l00747"></a>00747 
<a name="l00748"></a>00748   rc=<a class="code" href="group__Variable.html#g87015cda75e038cc73c1d584537d81fc" title="Set the pointer to the variable data.">fc_setVariableDataPtr</a>(v_ancestors,   numCoords, 1, <a class="code" href="group__DataTypes.html#gg28b7cdba59395ddc988888d01dd19af644ec6296999025f1ac12940f0c8e36d3">FC_AT_VERTEX</a>, <a class="code" href="group__DataTypes.html#gg60d16c50c365cd12f1f61ce8f4cebb206d3b58fc952172de6c4a1b3f75b8b5b2">FC_MT_SCALAR</a>, <a class="code" href="group__DataTypes.html#ggcca24e957488bb76e40a84ea651975d963896eb450c264fe236185788362b270">FC_DT_INT</a>, tmp_ancestors);   <a class="code" href="group__ErrorHandling.html#gcc9949110ba62c7ec8fabf7b455f1c0b" title="If the return code is an error, print diagnostic and exit.">fc_exitIfError</a>(rc);
<a name="l00749"></a>00749   rc=<a class="code" href="group__Variable.html#g87015cda75e038cc73c1d584537d81fc" title="Set the pointer to the variable data.">fc_setVariableDataPtr</a>(v_descendants, numCoords, 1, <a class="code" href="group__DataTypes.html#gg28b7cdba59395ddc988888d01dd19af644ec6296999025f1ac12940f0c8e36d3">FC_AT_VERTEX</a>, <a class="code" href="group__DataTypes.html#gg60d16c50c365cd12f1f61ce8f4cebb206d3b58fc952172de6c4a1b3f75b8b5b2">FC_MT_SCALAR</a>, <a class="code" href="group__DataTypes.html#ggcca24e957488bb76e40a84ea651975d963896eb450c264fe236185788362b270">FC_DT_INT</a>, tmp_descendants); <a class="code" href="group__ErrorHandling.html#gcc9949110ba62c7ec8fabf7b455f1c0b" title="If the return code is an error, print diagnostic and exit.">fc_exitIfError</a>(rc);
<a name="l00750"></a>00750 
<a name="l00751"></a>00751 
<a name="l00752"></a>00752   <span class="comment">//Check to see if displacement is available</span>
<a name="l00753"></a>00753   <span class="keywordflow">if</span>((displacement_var_name)&amp;&amp;(!<a class="code" href="lib__skeleton_8c.html#01a08f714eaaf8313f3b0d4191deed40">doesSeqVarExist</a>(m_src, displacement_var_name))){
<a name="l00754"></a>00754     <a class="code" href="group__Library.html#g160cfb8cb557ccf48fee07ae11e65482" title="Print a warning message to stdout.">fc_printfWarningMessage</a>(<span class="stringliteral">"Displacement var '%s' does not exist. Skipping displacement."</span>, displacement_var_name);
<a name="l00755"></a>00755     displacement_var_name = NULL;
<a name="l00756"></a>00756   }
<a name="l00757"></a>00757 
<a name="l00758"></a>00758 
<a name="l00759"></a>00759   <span class="keywordflow">if</span>(displacement_var_name){
<a name="l00760"></a>00760     <a class="code" href="structFC__Sequence.html" title="Sequence Handle.">FC_Sequence</a> src_seq, dst_seq;
<a name="l00761"></a>00761     <a class="code" href="structFC__Variable.html" title="Variable Handle.">FC_Variable</a> *src_dispSV, *dst_dispSV_skel, *dst_dispSV_ball;
<a name="l00762"></a>00762     <span class="keywordtype">int</span> src_dispSV_steps, dst_dispSV_steps;
<a name="l00763"></a>00763     
<a name="l00764"></a>00764     <span class="keywordtype">int</span> *orig_conns; <span class="comment">//read only</span>
<a name="l00765"></a>00765 
<a name="l00766"></a>00766     <span class="comment">//Create displacement vars for the ball and skeleton</span>
<a name="l00767"></a>00767     rc = <a class="code" href="group__Variable.html#g9022a4933230e252076467a05f101a68" title="Gets a unique seq var if it exists, otherwise generate it from components if possible...">fc_getOrGenerateUniqueSeqVariableByName</a>(m_src, displacement_var_name, &amp;src_dispSV_steps, &amp;src_dispSV);  <a class="code" href="group__ErrorHandling.html#gcc9949110ba62c7ec8fabf7b455f1c0b" title="If the return code is an error, print diagnostic and exit.">fc_exitIfError</a>(rc);
<a name="l00768"></a>00768     rc = <a class="code" href="group__Variable.html#g314a992ec5ba07d7075f1172b13ef166" title="Get the parent sequence of a sequence variable.">fc_getSequenceFromSeqVariable</a>(src_dispSV_steps, src_dispSV, &amp;src_seq);                                  <a class="code" href="group__ErrorHandling.html#gcc9949110ba62c7ec8fabf7b455f1c0b" title="If the return code is an error, print diagnostic and exit.">fc_exitIfError</a>(rc);
<a name="l00769"></a>00769     rc = <a class="code" href="group__Sequence.html#g75c324c79f7f053ef9e7c568dcb7bc5b" title="Copy a sequence.">fc_copySequence</a>(src_seq, ds_skel, <span class="stringliteral">"new_sequence"</span>, &amp;dst_seq);                                            <a class="code" href="group__ErrorHandling.html#gcc9949110ba62c7ec8fabf7b455f1c0b" title="If the return code is an error, print diagnostic and exit.">fc_exitIfError</a>(rc);
<a name="l00770"></a>00770     rc = <a class="code" href="group__Variable.html#g05d5098e68c1761ac851b2509dfbea70" title="Create a new sequence variable.">fc_createSeqVariable</a>(m_skel, dst_seq, <span class="stringliteral">"displacement"</span>, &amp;dst_dispSV_steps, &amp;dst_dispSV_skel);             <a class="code" href="group__ErrorHandling.html#gcc9949110ba62c7ec8fabf7b455f1c0b" title="If the return code is an error, print diagnostic and exit.">fc_exitIfError</a>(rc);
<a name="l00771"></a>00771     rc = <a class="code" href="group__Variable.html#g05d5098e68c1761ac851b2509dfbea70" title="Create a new sequence variable.">fc_createSeqVariable</a>(m_ball, dst_seq, <span class="stringliteral">"displacement"</span>, &amp;dst_dispSV_steps, &amp;dst_dispSV_ball);             <a class="code" href="group__ErrorHandling.html#gcc9949110ba62c7ec8fabf7b455f1c0b" title="If the return code is an error, print diagnostic and exit.">fc_exitIfError</a>(rc);
<a name="l00772"></a>00772     
<a name="l00773"></a>00773     <span class="comment">//Need connections for original mesh if generating new intersection points</span>
<a name="l00774"></a>00774     rc = <a class="code" href="group__Mesh.html#g19906bcae562d226991740da142000c0" title="Return element to vertex connectivities for the mesh.">fc_getMeshElementConnsPtr</a>(tree.<a class="code" href="structspanning__tree__t.html#8047cfbd3e20f76c779de639f2b0b04f">mesh</a>, &amp;orig_conns);                                                      <a class="code" href="group__ErrorHandling.html#gcc9949110ba62c7ec8fabf7b455f1c0b" title="If the return code is an error, print diagnostic and exit.">fc_exitIfError</a>(rc);
<a name="l00775"></a>00775 
<a name="l00776"></a>00776     <span class="keywordflow">for</span>(i=0; i&lt;dst_dispSV_steps; i++){
<a name="l00777"></a>00777       <span class="keywordtype">double</span> *dst_centers_disp;
<a name="l00778"></a>00778 
<a name="l00779"></a>00779       <span class="keywordflow">if</span>(!tree.<a class="code" href="structspanning__tree__t.html#e13fa21139ec7c4675d4703b48ab0898">mesh_is_centers</a>){
<a name="l00780"></a>00780      <span class="comment">//Need to calculate the centers and figure out the displacements</span>
<a name="l00781"></a>00781 
<a name="l00782"></a>00782      rc = <a class="code" href="lib__skeleton_8c.html#3764a93ca0b255a7955d588ff5f2c2b6">fc_getElementCenters</a>(m_src, src_dispSV[i], &amp;dst_centers_disp);                                        <a class="code" href="group__ErrorHandling.html#gcc9949110ba62c7ec8fabf7b455f1c0b" title="If the return code is an error, print diagnostic and exit.">fc_exitIfError</a>(rc);
<a name="l00783"></a>00783      rc = <a class="code" href="group__Mesh.html#g57c475cb784b009f4ed3518e15b96768" title="Update a displacement variable for a sphere to have a new center and radius.">fc_setSphereDisplacementVariable</a>(dst_dispSV_ball[i], &amp;dst_centers_disp[tree.<a class="code" href="structspanning__tree__t.html#2f7ebb14ff208bc06e6a184175c8b8ff">root</a>*dim], ball_radius);  <a class="code" href="group__ErrorHandling.html#gcc9949110ba62c7ec8fabf7b455f1c0b" title="If the return code is an error, print diagnostic and exit.">fc_exitIfError</a>(rc); 
<a name="l00784"></a>00784  
<a name="l00785"></a>00785      <span class="comment">//Change to a displacement</span>
<a name="l00786"></a>00786      <span class="keywordflow">for</span>(j=0;j&lt;numCoords*dim;j++)
<a name="l00787"></a>00787        dst_centers_disp[j] -= coords[j];
<a name="l00788"></a>00788 
<a name="l00789"></a>00789       } <span class="keywordflow">else</span> {
<a name="l00790"></a>00790      <span class="keywordtype">double</span> *tmp_disp;
<a name="l00791"></a>00791      <span class="keywordtype">double</span>  tmp_center[dim];
<a name="l00792"></a>00792 
<a name="l00793"></a>00793      dst_centers_disp = (<span class="keywordtype">double</span> *)malloc(numCoords*dim*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l00794"></a>00794      rc = <a class="code" href="group__Variable.html#g40a4d68cafd7134b908b78d053d3c47d" title="Get the data in a variable.">fc_getVariableDataPtr</a>(src_dispSV[i], (<span class="keywordtype">void</span> *) &amp;tmp_disp);                                             <a class="code" href="group__ErrorHandling.html#gcc9949110ba62c7ec8fabf7b455f1c0b" title="If the return code is an error, print diagnostic and exit.">fc_exitIfError</a>(rc);
<a name="l00795"></a>00795      memcpy(dst_centers_disp, tmp_disp, numCoords*dim*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l00796"></a>00796      
<a name="l00797"></a>00797      <span class="keywordflow">for</span>(j=0;j&lt;dim;j++)
<a name="l00798"></a>00798        tmp_center[j] = coords[tree.<a class="code" href="structspanning__tree__t.html#2f7ebb14ff208bc06e6a184175c8b8ff">root</a>*dim+j] + dst_centers_disp[tree.<a class="code" href="structspanning__tree__t.html#2f7ebb14ff208bc06e6a184175c8b8ff">root</a>*dim + j];
<a name="l00799"></a>00799 
<a name="l00800"></a>00800      rc = <a class="code" href="group__Mesh.html#g57c475cb784b009f4ed3518e15b96768" title="Update a displacement variable for a sphere to have a new center and radius.">fc_setSphereDisplacementVariable</a>(dst_dispSV_ball[i], &amp;tmp_center[0], ball_radius);  <a class="code" href="group__ErrorHandling.html#gcc9949110ba62c7ec8fabf7b455f1c0b" title="If the return code is an error, print diagnostic and exit.">fc_exitIfError</a>(rc); 
<a name="l00801"></a>00801  
<a name="l00802"></a>00802       }
<a name="l00803"></a>00803 
<a name="l00804"></a>00804       rc = <a class="code" href="group__Variable.html#g87015cda75e038cc73c1d584537d81fc" title="Set the pointer to the variable data.">fc_setVariableDataPtr</a>(dst_dispSV_skel[i], numCoords, dim, <a class="code" href="group__DataTypes.html#gg28b7cdba59395ddc988888d01dd19af644ec6296999025f1ac12940f0c8e36d3">FC_AT_VERTEX</a>, <a class="code" href="group__DataTypes.html#gg60d16c50c365cd12f1f61ce8f4cebb207f48fe9fd9efb7bc772bbb41106e217f">FC_MT_VECTOR</a>, <a class="code" href="group__DataTypes.html#ggcca24e957488bb76e40a84ea651975d9250e83e5dab9b5c1872f0f82665ff905">FC_DT_DOUBLE</a>, dst_centers_disp);
<a name="l00805"></a>00805       <a class="code" href="group__ErrorHandling.html#gcc9949110ba62c7ec8fabf7b455f1c0b" title="If the return code is an error, print diagnostic and exit.">fc_exitIfError</a>(rc); <span class="comment">//note: above absorbs the dst_centers pointer</span>
<a name="l00806"></a>00806  
<a name="l00807"></a>00807     }
<a name="l00808"></a>00808   }
<a name="l00809"></a>00809 
<a name="l00810"></a>00810   rc=<a class="code" href="group__FileIO.html#gd9ebe76a3f236b62d2065721158bdf50" title="Write a dataset.">fc_writeDataset</a>(ds_skel, <a class="code" href="subsetter_8c.html#8505c513bc640d1f69e5f76fb32b24a8">file_name</a>, <a class="code" href="group__FileIO.html#gge2c4eb60578842e0dfb050ffe07be10f99ecebdb6b57140d8fd211b1f9f62c4b">FC_FT_EXODUS</a>); <a class="code" href="group__ErrorHandling.html#gcc9949110ba62c7ec8fabf7b455f1c0b" title="If the return code is an error, print diagnostic and exit.">fc_exitIfError</a>(rc);
<a name="l00811"></a>00811 
<a name="l00812"></a>00812 
<a name="l00813"></a>00813   <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce46687acb19dbc2e15e6e89cdc39e8e18e">FC_SUCCESS</a>;
<a name="l00814"></a>00814 
<a name="l00815"></a>00815 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="e469928ca4475c0849c9f604db071a85"></a><!-- doxytag: member="lib_skeleton.h::fc_unpackSkeletonFromMesh" ref="e469928ca4475c0849c9f604db071a85" args="(FC_Mesh m, spanning_tree_t **tptr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fc_unpackSkeletonFromMesh           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFC__Mesh.html">FC_Mesh</a>&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structspanning__tree__t.html">spanning_tree_t</a> **&nbsp;</td>
          <td class="paramname"> <em>tptr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="lib__skeleton_8c-source.html#l01519">1519</a> of file <a class="el" href="lib__skeleton_8c-source.html">lib_skeleton.c</a>.</p>

<p>References <a class="el" href="lib__skeleton_8h-source.html#l00081">spanning_tree_t::dim</a>, <a class="el" href="lib__skeleton_8h-source.html#l00068">spanning_tree_node_t::dist_center</a>, <a class="el" href="lib__skeleton_8h-source.html#l00084">spanning_tree_t::elementCenters</a>, <a class="el" href="lib__skeleton_8c-source.html#l00267">fc_computeTreeDescendantsAncestors()</a>, <a class="el" href="lib__skeleton_8c-source.html#l00237">fc_computeTreeDistances()</a>, <a class="el" href="error_8h-source.html#l00080">fc_exitIfError</a>, <a class="el" href="mesh_8c-source.html#l03436">fc_getMeshCoordsPtr()</a>, <a class="el" href="mesh_8c-source.html#l03762">fc_getMeshElementConnsPtr()</a>, <a class="el" href="mesh_8c-source.html#l02848">fc_getMeshInfo()</a>, <a class="el" href="lib__skeleton_8h-source.html#l00066">spanning_tree_node_t::id_start</a>, <a class="el" href="lib__skeleton_8h-source.html#l00067">spanning_tree_node_t::id_stop</a>, <a class="el" href="lib__skeleton_8h-source.html#l00046">info</a>, <a class="el" href="lib__skeleton_8h-source.html#l00080">spanning_tree_t::mesh</a>, <a class="el" href="lib__skeleton_8h-source.html#l00085">spanning_tree_t::mesh_is_centers</a>, <a class="el" href="lib__skeleton_8h-source.html#l00077">spanning_tree_t::nodes</a>, <a class="el" href="lib__skeleton_8h-source.html#l00070">spanning_tree_node_t::num_ancestors</a>, <a class="el" href="lib__skeleton_8h-source.html#l00069">spanning_tree_node_t::num_descendants</a>, <a class="el" href="lib__skeleton_8h-source.html#l00082">spanning_tree_t::numElement</a>, <a class="el" href="lib__skeleton_8h-source.html#l00076">spanning_tree_t::numNodes</a>, <a class="el" href="lib__skeleton_8h-source.html#l00075">spanning_tree_t::root</a>, and <a class="el" href="lib__skeleton_8h-source.html#l00083">spanning_tree_t::vertPerElement</a>.</p>

<p>Referenced by <a class="el" href="whittle__tree_8c-source.html#l00103">main()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l01519"></a>01519                                                                   {
<a name="l01520"></a>01520 
<a name="l01521"></a>01521   <a class="code" href="structspanning__tree__t.html">spanning_tree_t</a> *t;
<a name="l01522"></a>01522   <a class="code" href="group__DataTypes.html#g2a40aa471d085988d5b582669f766ce4" title="Possible function return values.">FC_ReturnCode</a> rc;
<a name="l01523"></a>01523 
<a name="l01524"></a>01524   <span class="keywordtype">int</span> topodim, dim, numVertex, numElement;
<a name="l01525"></a>01525   <a class="code" href="group__DataTypes.html#g57a0abe7a63cc2c6c9fb0a3db339884a" title="Possible element types.">FC_ElementType</a> elemType;
<a name="l01526"></a>01526   <span class="keywordtype">int</span> *conns;
<a name="l01527"></a>01527   <span class="keywordtype">int</span>  i;
<a name="l01528"></a>01528 
<a name="l01529"></a>01529   t=(<a class="code" href="structspanning__tree__t.html">spanning_tree_t</a> *)malloc(<span class="keyword">sizeof</span>(<a class="code" href="structspanning__tree__t.html">spanning_tree_t</a>));
<a name="l01530"></a>01530   
<a name="l01531"></a>01531 
<a name="l01532"></a>01532   rc = <a class="code" href="group__Mesh.html#ged61b1f684fc2a6ac489c10841cdb591" title="Get information about a mesh.">fc_getMeshInfo</a>(m, &amp;topodim, &amp;dim, &amp;numVertex, &amp;numElement, &amp;elemType);  <a class="code" href="group__ErrorHandling.html#gcc9949110ba62c7ec8fabf7b455f1c0b" title="If the return code is an error, print diagnostic and exit.">fc_exitIfError</a>(rc);
<a name="l01533"></a>01533   rc = <a class="code" href="group__Mesh.html#gff8561557c19ae03be9ff18cc73a6823" title="Return the vertex coordinates of the mesh.">fc_getMeshCoordsPtr</a>(m, &amp;t-&gt;<a class="code" href="structspanning__tree__t.html#4a6035ff3412486e6beff9f9a636401b">elementCenters</a>); <a class="code" href="group__ErrorHandling.html#gcc9949110ba62c7ec8fabf7b455f1c0b" title="If the return code is an error, print diagnostic and exit.">fc_exitIfError</a>(rc); <span class="comment">//Read only  </span>
<a name="l01534"></a>01534   rc = <a class="code" href="group__Mesh.html#g19906bcae562d226991740da142000c0" title="Return element to vertex connectivities for the mesh.">fc_getMeshElementConnsPtr</a>(m, &amp;conns);       <a class="code" href="group__ErrorHandling.html#gcc9949110ba62c7ec8fabf7b455f1c0b" title="If the return code is an error, print diagnostic and exit.">fc_exitIfError</a>(rc); <span class="comment">//Read-only</span>
<a name="l01535"></a>01535 
<a name="l01536"></a>01536   <a class="code" href="lib__skeleton_8h.html#0017ada9be12f3b512275e039cff6f26">info</a>(<span class="stringliteral">"Unpack Skeleton from Mesh: numVertex=%d numElement=%d root=%d"</span>, numVertex, numElement, conns[0]);
<a name="l01537"></a>01537 
<a name="l01538"></a>01538  
<a name="l01539"></a>01539   t-&gt;<a class="code" href="structspanning__tree__t.html#2f7ebb14ff208bc06e6a184175c8b8ff">root</a>            = conns[0]; <span class="comment">//Root is first node in list</span>
<a name="l01540"></a>01540   t-&gt;<a class="code" href="structspanning__tree__t.html#5ccb47c8e349067ee6017e091d02306e">numNodes</a>        = numElement;
<a name="l01541"></a>01541   t-&gt;<a class="code" href="structspanning__tree__t.html#31d1d9e54040f7634f16cdddd1c24760">nodes</a>           = (<a class="code" href="structspanning__tree__node__t.html">spanning_tree_node_t</a> *)calloc(numElement, <span class="keyword">sizeof</span>(<a class="code" href="structspanning__tree__node__t.html">spanning_tree_node_t</a>));
<a name="l01542"></a>01542   t-&gt;<a class="code" href="structspanning__tree__t.html#6aca20c85f139938862367cc664ef52f">dim</a>             = dim;
<a name="l01543"></a>01543   t-&gt;<a class="code" href="structspanning__tree__t.html#602d7926e681ac4e1ca97843dabd2d4e">numElement</a>      = numVertex; <span class="comment">//Each vertex was at center of an element</span>
<a name="l01544"></a>01544   t-&gt;<a class="code" href="structspanning__tree__t.html#f9002a43ce333db472d65c97f8f73d90">vertPerElement</a>  = 1;
<a name="l01545"></a>01545   t-&gt;<a class="code" href="structspanning__tree__t.html#8047cfbd3e20f76c779de639f2b0b04f">mesh</a>            = m;
<a name="l01546"></a>01546   t-&gt;<a class="code" href="structspanning__tree__t.html#e13fa21139ec7c4675d4703b48ab0898">mesh_is_centers</a> = 1;
<a name="l01547"></a>01547 
<a name="l01548"></a>01548   <span class="keywordflow">for</span>(i=0; i&lt;t-&gt;<a class="code" href="structspanning__tree__t.html#5ccb47c8e349067ee6017e091d02306e">numNodes</a>; i++){
<a name="l01549"></a>01549     t-&gt;<a class="code" href="structspanning__tree__t.html#31d1d9e54040f7634f16cdddd1c24760">nodes</a>[i].<a class="code" href="structspanning__tree__node__t.html#e63a247a928451c07c9ee6b20a0f393b">id_start</a> = conns[i*2+0];
<a name="l01550"></a>01550     t-&gt;<a class="code" href="structspanning__tree__t.html#31d1d9e54040f7634f16cdddd1c24760">nodes</a>[i].<a class="code" href="structspanning__tree__node__t.html#a7f8f7a44d9a169bf101223b7106d91a">id_stop</a>  = conns[i*2+1];
<a name="l01551"></a>01551     t-&gt;<a class="code" href="structspanning__tree__t.html#31d1d9e54040f7634f16cdddd1c24760">nodes</a>[i].<a class="code" href="structspanning__tree__node__t.html#5e905b8fea407e8c86606ffc956cd4ef">dist_center</a> = 0.0;
<a name="l01552"></a>01552     t-&gt;<a class="code" href="structspanning__tree__t.html#31d1d9e54040f7634f16cdddd1c24760">nodes</a>[i].<a class="code" href="structspanning__tree__node__t.html#48095c9cb31a1f850c5eb6e1a843de1e">num_descendants</a> = 0;
<a name="l01553"></a>01553     t-&gt;<a class="code" href="structspanning__tree__t.html#31d1d9e54040f7634f16cdddd1c24760">nodes</a>[i].<a class="code" href="structspanning__tree__node__t.html#96be82e2c2d02cb47d9e71c2938a9ced">num_ancestors</a>   = 0;
<a name="l01554"></a>01554     <span class="comment">//printf("[%d] %d-&gt;%d\n", i, conns[i*2+0], conns[i*2+1]);</span>
<a name="l01555"></a>01555     assert(conns[i*2+0]&lt;numVertex);
<a name="l01556"></a>01556     assert(conns[i*2+1]&lt;numVertex);
<a name="l01557"></a>01557 
<a name="l01558"></a>01558   }
<a name="l01559"></a>01559   rc = <a class="code" href="lib__skeleton_8c.html#1bbd7a44f7bed3ef955121c22434dca3">fc_computeTreeDistances</a>(t);            <a class="code" href="group__ErrorHandling.html#gcc9949110ba62c7ec8fabf7b455f1c0b" title="If the return code is an error, print diagnostic and exit.">fc_exitIfError</a>(rc);
<a name="l01560"></a>01560   rc = <a class="code" href="lib__skeleton_8c.html#dd3df4be2e7ca2ba3f19258cffb2e08a">fc_computeTreeDescendantsAncestors</a>(t); <a class="code" href="group__ErrorHandling.html#gcc9949110ba62c7ec8fabf7b455f1c0b" title="If the return code is an error, print diagnostic and exit.">fc_exitIfError</a>(rc);
<a name="l01561"></a>01561 
<a name="l01562"></a>01562   *tptr = t;
<a name="l01563"></a>01563 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="ac78e2814a6fc9f0fd29535537a2dad7"></a><!-- doxytag: member="lib_skeleton.h::getNextWhittleAlgorithmDescription" ref="ac78e2814a6fc9f0fd29535537a2dad7" args="(int count, char **name, char **sname, whittleAlgorithm_t *id, char **description)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getNextWhittleAlgorithmDescription           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>sname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lib__skeleton_8h.html#e8816f1d3f4ad9da003a2123bda65c0e">whittleAlgorithm_t</a> *&nbsp;</td>
          <td class="paramname"> <em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>description</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="lib__skeleton_8c-source.html#l00090">90</a> of file <a class="el" href="lib__skeleton_8c-source.html">lib_skeleton.c</a>.</p>

<p>References <a class="el" href="lib__skeleton_8c-source.html#l00057">whittleAlgorithmDescription_t::alg_id</a>, <a class="el" href="lib__skeleton_8c-source.html#l00060">whittleAlgorithmDescription_t::description</a>, <a class="el" href="lib__skeleton_8c-source.html#l00058">whittleAlgorithmDescription_t::name</a>, and <a class="el" href="lib__skeleton_8c-source.html#l00059">whittleAlgorithmDescription_t::shortname</a>.</p>

<p>Referenced by <a class="el" href="build__ensemble_8c-source.html#l00078">dumpHelp()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00090"></a>00090                                                                                                                         {
<a name="l00091"></a>00091   <span class="keywordtype">int</span> i;
<a name="l00092"></a>00092   *name=*sname=*description=NULL;
<a name="l00093"></a>00093   *<span class="keywordtype">id</span>=0;
<a name="l00094"></a>00094   <span class="keywordflow">for</span>(i=0; (i&lt;count) &amp;&amp; (<a class="code" href="lib__skeleton_8c.html#2afaabe4f594132496b9ace1419583e6">whittleAlgorithmDescription</a>[i].name); i++);
<a name="l00095"></a>00095   <span class="keywordflow">if</span>(!<a class="code" href="lib__skeleton_8c.html#2afaabe4f594132496b9ace1419583e6">whittleAlgorithmDescription</a>[i].name) <span class="keywordflow">return</span> 0;
<a name="l00096"></a>00096   <span class="comment">//Found something</span>
<a name="l00097"></a>00097   *<span class="keywordtype">id</span>          = <a class="code" href="lib__skeleton_8c.html#2afaabe4f594132496b9ace1419583e6">whittleAlgorithmDescription</a>[i].<a class="code" href="structwhittleAlgorithmDescription__t.html#b37fefa58a0a8da047b1ff16023a9b6c">alg_id</a>;
<a name="l00098"></a>00098   *name        = <a class="code" href="lib__skeleton_8c.html#2afaabe4f594132496b9ace1419583e6">whittleAlgorithmDescription</a>[i].<a class="code" href="structwhittleAlgorithmDescription__t.html#5ba8795146e81aa44d9d6ed8955b42f4">name</a>;
<a name="l00099"></a>00099   *sname       = <a class="code" href="lib__skeleton_8c.html#2afaabe4f594132496b9ace1419583e6">whittleAlgorithmDescription</a>[i].<a class="code" href="structwhittleAlgorithmDescription__t.html#4bb8776dc96d6754f40e73a34778eff9">shortname</a>;
<a name="l00100"></a>00100   *description = <a class="code" href="lib__skeleton_8c.html#2afaabe4f594132496b9ace1419583e6">whittleAlgorithmDescription</a>[i].<a class="code" href="structwhittleAlgorithmDescription__t.html#e89d4163538444af81769162ae21a71e">description</a>;
<a name="l00101"></a>00101   <span class="keywordflow">return</span> 1;
<a name="l00102"></a>00102 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="4bfc93887121689d8263fbf6a950dc9e"></a><!-- doxytag: member="lib_skeleton.h::getWhittleAlgorithmName" ref="4bfc93887121689d8263fbf6a950dc9e" args="(whittleAlgorithm_t alg_id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* getWhittleAlgorithmName           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lib__skeleton_8h.html#e8816f1d3f4ad9da003a2123bda65c0e">whittleAlgorithm_t</a>&nbsp;</td>
          <td class="paramname"> <em>alg_id</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="lib__skeleton_8c-source.html#l00081">81</a> of file <a class="el" href="lib__skeleton_8c-source.html">lib_skeleton.c</a>.</p>

<p>References <a class="el" href="lib__skeleton_8c-source.html#l00057">whittleAlgorithmDescription_t::alg_id</a>, and <a class="el" href="lib__skeleton_8c-source.html#l00058">whittleAlgorithmDescription_t::name</a>.</p>

<p>Referenced by <a class="el" href="build__ensemble_8c-source.html#l00236">main()</a>, and <a class="el" href="lib__skeleton_8c-source.html#l01567">whittleSkeleton()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00081"></a>00081                                                         {
<a name="l00082"></a>00082   <a class="code" href="structwhittleAlgorithmDescription__t.html">whittleAlgorithmDescription_t</a> *w;
<a name="l00083"></a>00083 
<a name="l00084"></a>00084   <span class="keywordflow">for</span>(w=<a class="code" href="lib__skeleton_8c.html#2afaabe4f594132496b9ace1419583e6">whittleAlgorithmDescription</a>; (w-&gt;<a class="code" href="structwhittleAlgorithmDescription__t.html#5ba8795146e81aa44d9d6ed8955b42f4">name</a>)&amp;&amp;(w-&gt;<a class="code" href="structwhittleAlgorithmDescription__t.html#b37fefa58a0a8da047b1ff16023a9b6c">alg_id</a>!=alg_id); w++);
<a name="l00085"></a>00085   <span class="keywordflow">if</span>(w-&gt;<a class="code" href="structwhittleAlgorithmDescription__t.html#5ba8795146e81aa44d9d6ed8955b42f4">name</a>) <span class="keywordflow">return</span> w-&gt;<a class="code" href="structwhittleAlgorithmDescription__t.html#5ba8795146e81aa44d9d6ed8955b42f4">name</a>;
<a name="l00086"></a>00086   <span class="keywordflow">return</span> <span class="stringliteral">"Unknown"</span>;
<a name="l00087"></a>00087 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="248d921501f4739e2562082945e4e9de"></a><!-- doxytag: member="lib_skeleton.h::printTree" ref="248d921501f4739e2562082945e4e9de" args="(spanning_tree_t *t, int include_nodes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void printTree           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structspanning__tree__t.html">spanning_tree_t</a> *&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>include_nodes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="lib__skeleton_8c-source.html#l00605">605</a> of file <a class="el" href="lib__skeleton_8c-source.html">lib_skeleton.c</a>.</p>

<p>References <a class="el" href="lib__skeleton_8h-source.html#l00068">spanning_tree_node_t::dist_center</a>, <a class="el" href="lib__skeleton_8h-source.html#l00066">spanning_tree_node_t::id_start</a>, <a class="el" href="lib__skeleton_8h-source.html#l00067">spanning_tree_node_t::id_stop</a>, <a class="el" href="lib__skeleton_8h-source.html#l00077">spanning_tree_t::nodes</a>, <a class="el" href="lib__skeleton_8h-source.html#l00070">spanning_tree_node_t::num_ancestors</a>, <a class="el" href="lib__skeleton_8h-source.html#l00069">spanning_tree_node_t::num_descendants</a>, <a class="el" href="lib__skeleton_8h-source.html#l00082">spanning_tree_t::numElement</a>, <a class="el" href="lib__skeleton_8h-source.html#l00076">spanning_tree_t::numNodes</a>, <a class="el" href="lib__skeleton_8h-source.html#l00075">spanning_tree_t::root</a>, and <a class="el" href="lib__skeleton_8h-source.html#l00083">spanning_tree_t::vertPerElement</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00605"></a>00605                                                      {
<a name="l00606"></a>00606 
<a name="l00607"></a>00607   <span class="keywordtype">int</span> i;
<a name="l00608"></a>00608   printf(<span class="stringliteral">"tree root=%d numNodes=%d MeshElements=%d VertsPerElement=%d\n"</span>,
<a name="l00609"></a>00609       t-&gt;<a class="code" href="structspanning__tree__t.html#2f7ebb14ff208bc06e6a184175c8b8ff">root</a>, t-&gt;<a class="code" href="structspanning__tree__t.html#5ccb47c8e349067ee6017e091d02306e">numNodes</a>, t-&gt;<a class="code" href="structspanning__tree__t.html#602d7926e681ac4e1ca97843dabd2d4e">numElement</a>, t-&gt;<a class="code" href="structspanning__tree__t.html#f9002a43ce333db472d65c97f8f73d90">vertPerElement</a>);
<a name="l00610"></a>00610   <span class="keywordflow">if</span>(include_nodes){
<a name="l00611"></a>00611     <span class="keywordflow">for</span>(i=0;i&lt;t-&gt;<a class="code" href="structspanning__tree__t.html#5ccb47c8e349067ee6017e091d02306e">numNodes</a>;i++)
<a name="l00612"></a>00612       printf(<span class="stringliteral">"[%.4d] %4d-&gt;%4d \tDistance: %.8lf [c/i] Relatives:\t%d/%d [ancestors/descendants]\n"</span>,
<a name="l00613"></a>00613           i,
<a name="l00614"></a>00614           t-&gt;<a class="code" href="structspanning__tree__t.html#31d1d9e54040f7634f16cdddd1c24760">nodes</a>[i].<a class="code" href="structspanning__tree__node__t.html#e63a247a928451c07c9ee6b20a0f393b">id_start</a>,
<a name="l00615"></a>00615           t-&gt;<a class="code" href="structspanning__tree__t.html#31d1d9e54040f7634f16cdddd1c24760">nodes</a>[i].<a class="code" href="structspanning__tree__node__t.html#a7f8f7a44d9a169bf101223b7106d91a">id_stop</a>,
<a name="l00616"></a>00616           t-&gt;<a class="code" href="structspanning__tree__t.html#31d1d9e54040f7634f16cdddd1c24760">nodes</a>[i].<a class="code" href="structspanning__tree__node__t.html#5e905b8fea407e8c86606ffc956cd4ef">dist_center</a>,
<a name="l00617"></a>00617           t-&gt;<a class="code" href="structspanning__tree__t.html#31d1d9e54040f7634f16cdddd1c24760">nodes</a>[i].<a class="code" href="structspanning__tree__node__t.html#96be82e2c2d02cb47d9e71c2938a9ced">num_ancestors</a>,
<a name="l00618"></a>00618           t-&gt;<a class="code" href="structspanning__tree__t.html#31d1d9e54040f7634f16cdddd1c24760">nodes</a>[i].<a class="code" href="structspanning__tree__node__t.html#48095c9cb31a1f850c5eb6e1a843de1e">num_descendants</a>);
<a name="l00619"></a>00619   }
<a name="l00620"></a>00620 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="3a87b0160af49f652c2d68f1a89f4fda"></a><!-- doxytag: member="lib_skeleton.h::replicateSpanningTree" ref="3a87b0160af49f652c2d68f1a89f4fda" args="(spanning_tree_t *ti, spanning_tree_t **to)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DataTypes.html#g2a40aa471d085988d5b582669f766ce4">FC_ReturnCode</a> replicateSpanningTree           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structspanning__tree__t.html">spanning_tree_t</a> *&nbsp;</td>
          <td class="paramname"> <em>ti</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structspanning__tree__t.html">spanning_tree_t</a> **&nbsp;</td>
          <td class="paramname"> <em>to</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="lib__skeleton_8c-source.html#l01066">1066</a> of file <a class="el" href="lib__skeleton_8c-source.html">lib_skeleton.c</a>.</p>

<p>References <a class="el" href="lib__skeleton_8c-source.html#l00988">replicateSpanningTreeWithMask()</a>.</p>

<p>Referenced by <a class="el" href="lib__skeleton_8c-source.html#l01567">whittleSkeleton()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l01066"></a>01066                                                                               {
<a name="l01067"></a>01067   <span class="keywordflow">return</span> <a class="code" href="lib__skeleton_8c.html#1f8a114a3c3842487b9de9aa9a9fd1ae">replicateSpanningTreeWithMask</a>(ti,NULL,to); 
<a name="l01068"></a>01068 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="1f8a114a3c3842487b9de9aa9a9fd1ae"></a><!-- doxytag: member="lib_skeleton.h::replicateSpanningTreeWithMask" ref="1f8a114a3c3842487b9de9aa9a9fd1ae" args="(spanning_tree_t *ti, char *mask, spanning_tree_t **to)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DataTypes.html#g2a40aa471d085988d5b582669f766ce4">FC_ReturnCode</a> replicateSpanningTreeWithMask           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structspanning__tree__t.html">spanning_tree_t</a> *&nbsp;</td>
          <td class="paramname"> <em>ti</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structspanning__tree__t.html">spanning_tree_t</a> **&nbsp;</td>
          <td class="paramname"> <em>to</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="lib__skeleton_8c-source.html#l00988">988</a> of file <a class="el" href="lib__skeleton_8c-source.html">lib_skeleton.c</a>.</p>

<p>References <a class="el" href="lib__skeleton_8c-source.html#l00208">_getParentIndexForIndex()</a>, <a class="el" href="lib__skeleton_8h-source.html#l00081">spanning_tree_t::dim</a>, <a class="el" href="lib__skeleton_8h-source.html#l00084">spanning_tree_t::elementCenters</a>, <a class="el" href="lib__skeleton_8c-source.html#l00267">fc_computeTreeDescendantsAncestors()</a>, <a class="el" href="lib__skeleton_8c-source.html#l00237">fc_computeTreeDistances()</a>, <a class="el" href="base_8h-source.html#l00104">FC_SUCCESS</a>, <a class="el" href="lib__skeleton_8h-source.html#l00066">spanning_tree_node_t::id_start</a>, <a class="el" href="lib__skeleton_8h-source.html#l00067">spanning_tree_node_t::id_stop</a>, <a class="el" href="lib__skeleton_8h-source.html#l00077">spanning_tree_t::nodes</a>, <a class="el" href="lib__skeleton_8h-source.html#l00082">spanning_tree_t::numElement</a>, <a class="el" href="lib__skeleton_8h-source.html#l00076">spanning_tree_t::numNodes</a>, and <a class="el" href="lib__skeleton_8h-source.html#l00075">spanning_tree_t::root</a>.</p>

<p>Referenced by <a class="el" href="lib__skeleton_8c-source.html#l01066">replicateSpanningTree()</a>, <a class="el" href="lib__skeleton_8c-source.html#l01338">whittleSkeletonByDullestAngles()</a>, <a class="el" href="lib__skeleton_8c-source.html#l01198">whittleSkeletonBySegmentLengths()</a>, and <a class="el" href="lib__skeleton_8c-source.html#l01427">whittleSkeletonOctants()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00989"></a>00989                                                   {
<a name="l00990"></a>00990 
<a name="l00991"></a>00991   <span class="keywordtype">int</span> mask_count;
<a name="l00992"></a>00992   <span class="keywordtype">int</span> elemCenter_num;
<a name="l00993"></a>00993   <span class="keywordtype">int</span> i,j;
<a name="l00994"></a>00994   <span class="keywordtype">int</span> parent_spot;
<a name="l00995"></a>00995   <a class="code" href="structspanning__tree__t.html">spanning_tree_t</a> *t2;
<a name="l00996"></a>00996   <a class="code" href="group__DataTypes.html#g2a40aa471d085988d5b582669f766ce4" title="Possible function return values.">FC_ReturnCode</a> rc;
<a name="l00997"></a>00997 
<a name="l00998"></a>00998   <span class="keywordflow">if</span>(mask){
<a name="l00999"></a>00999     <span class="keywordflow">for</span>(mask_count=0, i=0; i&lt; ti-&gt;<a class="code" href="structspanning__tree__t.html#5ccb47c8e349067ee6017e091d02306e">numNodes</a>; i++)
<a name="l01000"></a>01000       <span class="keywordflow">if</span>(mask[i]) mask_count++;
<a name="l01001"></a>01001   } <span class="keywordflow">else</span> {
<a name="l01002"></a>01002     mask_count = ti-&gt;<a class="code" href="structspanning__tree__t.html#5ccb47c8e349067ee6017e091d02306e">numNodes</a>;
<a name="l01003"></a>01003   }
<a name="l01004"></a>01004 
<a name="l01005"></a>01005   <span class="comment">//Allocate space for new element centers. Vector is either [numElement] or [numElement+nodes]</span>
<a name="l01006"></a>01006   elemCenter_num = ti-&gt;<a class="code" href="structspanning__tree__t.html#602d7926e681ac4e1ca97843dabd2d4e">numElement</a>;
<a name="l01007"></a>01007   
<a name="l01008"></a>01008 
<a name="l01009"></a>01009   <span class="comment">//Create a new tree and populate it</span>
<a name="l01010"></a>01010   t2 = (<a class="code" href="structspanning__tree__t.html">spanning_tree_t</a> *)malloc(<span class="keyword">sizeof</span>(<a class="code" href="structspanning__tree__t.html">spanning_tree_t</a>));
<a name="l01011"></a>01011   memcpy(t2, ti, <span class="keyword">sizeof</span>(<a class="code" href="structspanning__tree__t.html">spanning_tree_t</a>)); <span class="comment">//Copy original values</span>
<a name="l01012"></a>01012 
<a name="l01013"></a>01013   t2-&gt;<a class="code" href="structspanning__tree__t.html#5ccb47c8e349067ee6017e091d02306e">numNodes</a> = mask_count;
<a name="l01014"></a>01014   t2-&gt;<a class="code" href="structspanning__tree__t.html#31d1d9e54040f7634f16cdddd1c24760">nodes</a>    = (<a class="code" href="structspanning__tree__node__t.html">spanning_tree_node_t</a> *) calloc(mask_count, <span class="keyword">sizeof</span>(<a class="code" href="structspanning__tree__node__t.html">spanning_tree_node_t</a>));
<a name="l01015"></a>01015   
<a name="l01016"></a>01016   t2-&gt;<a class="code" href="structspanning__tree__t.html#4a6035ff3412486e6beff9f9a636401b">elementCenters</a> = (<span class="keywordtype">double</span> *)calloc( elemCenter_num, ti-&gt;<a class="code" href="structspanning__tree__t.html#6aca20c85f139938862367cc664ef52f">dim</a>*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l01017"></a>01017 
<a name="l01018"></a>01018   
<a name="l01019"></a>01019   <span class="keywordflow">if</span>(!mask){
<a name="l01020"></a>01020     <span class="comment">//Just replicate the arrays</span>
<a name="l01021"></a>01021     memcpy(t2-&gt;<a class="code" href="structspanning__tree__t.html#31d1d9e54040f7634f16cdddd1c24760">nodes</a>, ti-&gt;<a class="code" href="structspanning__tree__t.html#31d1d9e54040f7634f16cdddd1c24760">nodes</a>, ti-&gt;<a class="code" href="structspanning__tree__t.html#5ccb47c8e349067ee6017e091d02306e">numNodes</a> * <span class="keyword">sizeof</span>(<a class="code" href="structspanning__tree__node__t.html">spanning_tree_node_t</a>));
<a name="l01022"></a>01022     memcpy(t2-&gt;<a class="code" href="structspanning__tree__t.html#4a6035ff3412486e6beff9f9a636401b">elementCenters</a>,   ti-&gt;<a class="code" href="structspanning__tree__t.html#4a6035ff3412486e6beff9f9a636401b">elementCenters</a>, elemCenter_num * ti-&gt;<a class="code" href="structspanning__tree__t.html#6aca20c85f139938862367cc664ef52f">dim</a> * <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l01023"></a>01023     rc = <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce46687acb19dbc2e15e6e89cdc39e8e18e">FC_SUCCESS</a>;
<a name="l01024"></a>01024   } <span class="keywordflow">else</span> {
<a name="l01025"></a>01025 
<a name="l01026"></a>01026     <span class="comment">//Copy in the first chunk of elementcenters, we may need to fill in the back half</span>
<a name="l01027"></a>01027     memcpy(t2-&gt;<a class="code" href="structspanning__tree__t.html#4a6035ff3412486e6beff9f9a636401b">elementCenters</a>, ti-&gt;<a class="code" href="structspanning__tree__t.html#4a6035ff3412486e6beff9f9a636401b">elementCenters</a>, ti-&gt;<a class="code" href="structspanning__tree__t.html#602d7926e681ac4e1ca97843dabd2d4e">numElement</a> * ti-&gt;<a class="code" href="structspanning__tree__t.html#6aca20c85f139938862367cc664ef52f">dim</a> * <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l01028"></a>01028 
<a name="l01029"></a>01029     <span class="keywordflow">for</span>(i=0,j=0; i&lt;ti-&gt;<a class="code" href="structspanning__tree__t.html#5ccb47c8e349067ee6017e091d02306e">numNodes</a>; i++){
<a name="l01030"></a>01030       <span class="keywordflow">if</span>(!mask[i]) <span class="keywordflow">continue</span>; <span class="comment">//Skip if not used</span>
<a name="l01031"></a>01031 
<a name="l01032"></a>01032       <span class="comment">//Copy the node data</span>
<a name="l01033"></a>01033       memcpy(&amp;t2-&gt;<a class="code" href="structspanning__tree__t.html#31d1d9e54040f7634f16cdddd1c24760">nodes</a>[j], &amp;ti-&gt;<a class="code" href="structspanning__tree__t.html#31d1d9e54040f7634f16cdddd1c24760">nodes</a>[i], <span class="keyword">sizeof</span>(<a class="code" href="structspanning__tree__node__t.html">spanning_tree_node_t</a>));
<a name="l01034"></a>01034       
<a name="l01035"></a>01035       <span class="comment">//Assign a new parent if mask says it's no longer good</span>
<a name="l01036"></a>01036       <span class="comment">//Loop through all ancestors until we find something that's in mask or is root</span>
<a name="l01037"></a>01037       parent_spot = <a class="code" href="lib__skeleton_8c.html#11b44926cb30faa29be3bb384933025d">_getParentIndexForIndex</a>(ti,i);
<a name="l01038"></a>01038       <span class="keywordflow">while</span>( (parent_spot&gt;=0) &amp;&amp; (!mask[parent_spot])){
<a name="l01039"></a>01039      parent_spot = <a class="code" href="lib__skeleton_8c.html#11b44926cb30faa29be3bb384933025d">_getParentIndexForIndex</a>(ti, parent_spot);
<a name="l01040"></a>01040       }
<a name="l01041"></a>01041 
<a name="l01042"></a>01042       <span class="comment">//Update this node's parent</span>
<a name="l01043"></a>01043       t2-&gt;<a class="code" href="structspanning__tree__t.html#31d1d9e54040f7634f16cdddd1c24760">nodes</a>[j].<a class="code" href="structspanning__tree__node__t.html#e63a247a928451c07c9ee6b20a0f393b">id_start</a> = (parent_spot&lt;0) ? ti-&gt;<a class="code" href="structspanning__tree__t.html#2f7ebb14ff208bc06e6a184175c8b8ff">root</a> 
<a name="l01044"></a>01044                                            : ti-&gt;<a class="code" href="structspanning__tree__t.html#31d1d9e54040f7634f16cdddd1c24760">nodes</a>[parent_spot].<a class="code" href="structspanning__tree__node__t.html#a7f8f7a44d9a169bf101223b7106d91a">id_stop</a>;
<a name="l01045"></a>01045 
<a name="l01046"></a>01046 
<a name="l01047"></a>01047       j++;
<a name="l01048"></a>01048     }
<a name="l01049"></a>01049     
<a name="l01050"></a>01050     <span class="comment">//Need to recompute distances for new tree</span>
<a name="l01051"></a>01051     rc = <a class="code" href="lib__skeleton_8c.html#1bbd7a44f7bed3ef955121c22434dca3">fc_computeTreeDistances</a>(t2);
<a name="l01052"></a>01052 
<a name="l01053"></a>01053     <span class="comment">//Need to recompute ancestors/descendants</span>
<a name="l01054"></a>01054     rc = <a class="code" href="lib__skeleton_8c.html#dd3df4be2e7ca2ba3f19258cffb2e08a">fc_computeTreeDescendantsAncestors</a>(t2);
<a name="l01055"></a>01055    
<a name="l01056"></a>01056   }
<a name="l01057"></a>01057   
<a name="l01058"></a>01058   *to = t2;
<a name="l01059"></a>01059 
<a name="l01060"></a>01060   <span class="keywordflow">return</span> rc;
<a name="l01061"></a>01061 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="b5c9306837e2cd641fe31648e1a3d8cd"></a><!-- doxytag: member="lib_skeleton.h::treeTagNodesAncestorsMask" ref="b5c9306837e2cd641fe31648e1a3d8cd" args="(spanning_tree_t *ti, int node_id, char *mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DataTypes.html#g2a40aa471d085988d5b582669f766ce4">FC_ReturnCode</a> treeTagNodesAncestorsMask           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structspanning__tree__t.html">spanning_tree_t</a> *&nbsp;</td>
          <td class="paramname"> <em>ti</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>node_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>mask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="lib__skeleton_8c-source.html#l01073">1073</a> of file <a class="el" href="lib__skeleton_8c-source.html">lib_skeleton.c</a>.</p>

<p>References <a class="el" href="base_8h-source.html#l00107">FC_INPUT_ERROR</a>, <a class="el" href="library_8h-source.html#l00120">fc_printfErrorMessage</a>, <a class="el" href="base_8h-source.html#l00104">FC_SUCCESS</a>, <a class="el" href="lib__skeleton_8h-source.html#l00066">spanning_tree_node_t::id_start</a>, <a class="el" href="lib__skeleton_8h-source.html#l00067">spanning_tree_node_t::id_stop</a>, <a class="el" href="lib__skeleton_8h-source.html#l00077">spanning_tree_t::nodes</a>, <a class="el" href="lib__skeleton_8h-source.html#l00076">spanning_tree_t::numNodes</a>, and <a class="el" href="lib__skeleton_8h-source.html#l00075">spanning_tree_t::root</a>.</p>

<p>Referenced by <a class="el" href="lib__skeleton_8c-source.html#l01427">whittleSkeletonOctants()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l01073"></a>01073                                                                                      {
<a name="l01074"></a>01074 
<a name="l01075"></a>01075   <span class="keywordtype">int</span> i;
<a name="l01076"></a>01076   <span class="keywordtype">int</span> search_node;
<a name="l01077"></a>01077 
<a name="l01078"></a>01078   <span class="keywordflow">if</span>(!mask){
<a name="l01079"></a>01079     <a class="code" href="group__Library.html#g1473e77471cd1319f76eb9a32e4ad91f" title="Print an error message to stderr.">fc_printfErrorMessage</a>(<span class="stringliteral">"Tag ancestors wasn't given a mask\n"</span>);
<a name="l01080"></a>01080     <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce464a3d55131c355cdf036f95d0d7e1a6e">FC_INPUT_ERROR</a>;
<a name="l01081"></a>01081   }
<a name="l01082"></a>01082 
<a name="l01083"></a>01083   <span class="comment">//Find where this node's index is in the array</span>
<a name="l01084"></a>01084   <span class="keywordflow">for</span>(i=0; (i&lt;ti-&gt;<a class="code" href="structspanning__tree__t.html#5ccb47c8e349067ee6017e091d02306e">numNodes</a>) &amp;&amp; (ti-&gt;<a class="code" href="structspanning__tree__t.html#31d1d9e54040f7634f16cdddd1c24760">nodes</a>[i].<a class="code" href="structspanning__tree__node__t.html#a7f8f7a44d9a169bf101223b7106d91a">id_stop</a>!=node_id); i++);
<a name="l01085"></a>01085   <span class="keywordflow">if</span>(i==ti-&gt;<a class="code" href="structspanning__tree__t.html#5ccb47c8e349067ee6017e091d02306e">numNodes</a>){
<a name="l01086"></a>01086     <a class="code" href="group__Library.html#g1473e77471cd1319f76eb9a32e4ad91f" title="Print an error message to stderr.">fc_printfErrorMessage</a>(<span class="stringliteral">"Node not found in tree\n"</span>);
<a name="l01087"></a>01087     <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce464a3d55131c355cdf036f95d0d7e1a6e">FC_INPUT_ERROR</a>;
<a name="l01088"></a>01088   } 
<a name="l01089"></a>01089 
<a name="l01090"></a>01090   search_node = node_id; <span class="comment">//Fake the first one</span>
<a name="l01091"></a>01091   <span class="keywordflow">do</span>{
<a name="l01092"></a>01092     <span class="keywordflow">while</span>(ti-&gt;<a class="code" href="structspanning__tree__t.html#31d1d9e54040f7634f16cdddd1c24760">nodes</a>[i].<a class="code" href="structspanning__tree__node__t.html#a7f8f7a44d9a169bf101223b7106d91a">id_stop</a> != search_node) i--;
<a name="l01093"></a>01093     mask[i]=1;
<a name="l01094"></a>01094     search_node = ti-&gt;<a class="code" href="structspanning__tree__t.html#31d1d9e54040f7634f16cdddd1c24760">nodes</a>[i].<a class="code" href="structspanning__tree__node__t.html#e63a247a928451c07c9ee6b20a0f393b">id_start</a>;
<a name="l01095"></a>01095   } <span class="keywordflow">while</span>(search_node!=ti-&gt;<a class="code" href="structspanning__tree__t.html#2f7ebb14ff208bc06e6a184175c8b8ff">root</a>);
<a name="l01096"></a>01096 
<a name="l01097"></a>01097   <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce46687acb19dbc2e15e6e89cdc39e8e18e">FC_SUCCESS</a>;
<a name="l01098"></a>01098 
<a name="l01099"></a>01099 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="c60a857709aa48fcb4a3675296525afb"></a><!-- doxytag: member="lib_skeleton.h::whittleSkeleton" ref="c60a857709aa48fcb4a3675296525afb" args="(spanning_tree_t *ti, whittleAlgorithm_t wtype, double desired_remaining_fraction, spanning_tree_t **to)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DataTypes.html#g2a40aa471d085988d5b582669f766ce4">FC_ReturnCode</a> whittleSkeleton           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structspanning__tree__t.html">spanning_tree_t</a> *&nbsp;</td>
          <td class="paramname"> <em>ti</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lib__skeleton_8h.html#e8816f1d3f4ad9da003a2123bda65c0e">whittleAlgorithm_t</a>&nbsp;</td>
          <td class="paramname"> <em>wtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>desired_remaining_fraction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structspanning__tree__t.html">spanning_tree_t</a> **&nbsp;</td>
          <td class="paramname"> <em>to</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="lib__skeleton_8c-source.html#l01567">1567</a> of file <a class="el" href="lib__skeleton_8c-source.html">lib_skeleton.c</a>.</p>

<p>References <a class="el" href="error_8h-source.html#l00080">fc_exitIfError</a>, <a class="el" href="base_8h-source.html#l00107">FC_INPUT_ERROR</a>, <a class="el" href="library_8h-source.html#l00120">fc_printfErrorMessage</a>, <a class="el" href="base_8h-source.html#l00104">FC_SUCCESS</a>, <a class="el" href="lib__skeleton_8h-source.html#l00057">FC_WA_MIN_ANGLE_CHANGE</a>, <a class="el" href="lib__skeleton_8h-source.html#l00055">FC_WA_MIN_DESCENDANTS</a>, <a class="el" href="lib__skeleton_8h-source.html#l00056">FC_WA_MIN_SEGMENT_LENGTHS</a>, <a class="el" href="lib__skeleton_8h-source.html#l00054">FC_WA_OCTANTS</a>, <a class="el" href="lib__skeleton_8h-source.html#l00047">FREE</a>, <a class="el" href="lib__skeleton_8c-source.html#l00081">getWhittleAlgorithmName()</a>, <a class="el" href="lib__skeleton_8h-source.html#l00046">info</a>, <a class="el" href="lib__skeleton_8h-source.html#l00077">spanning_tree_t::nodes</a>, <a class="el" href="lib__skeleton_8h-source.html#l00076">spanning_tree_t::numNodes</a>, <a class="el" href="lib__skeleton_8c-source.html#l01066">replicateSpanningTree()</a>, <a class="el" href="lib__skeleton_8c-source.html#l01338">whittleSkeletonByDullestAngles()</a>, <a class="el" href="lib__skeleton_8c-source.html#l01103">whittleSkeletonByNumDescendents()</a>, <a class="el" href="lib__skeleton_8c-source.html#l01198">whittleSkeletonBySegmentLengths()</a>, and <a class="el" href="lib__skeleton_8c-source.html#l01427">whittleSkeletonOctants()</a>.</p>

<p>Referenced by <a class="el" href="build__ensemble_8c-source.html#l00236">main()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l01570"></a>01570                                           {
<a name="l01571"></a>01571 
<a name="l01572"></a>01572   <span class="keywordtype">int</span> target_num;
<a name="l01573"></a>01573   <span class="keywordtype">int</span> original_num;
<a name="l01574"></a>01574 
<a name="l01575"></a>01575   <a class="code" href="structspanning__tree__t.html">spanning_tree_t</a> *t1,*t2;
<a name="l01576"></a>01576   <a class="code" href="group__DataTypes.html#g2a40aa471d085988d5b582669f766ce4" title="Possible function return values.">FC_ReturnCode</a> rc;
<a name="l01577"></a>01577   
<a name="l01578"></a>01578   
<a name="l01579"></a>01579   original_num = ti-&gt;<a class="code" href="structspanning__tree__t.html#5ccb47c8e349067ee6017e091d02306e">numNodes</a>;
<a name="l01580"></a>01580   target_num = (int) (desired_remaining_fraction * (<span class="keywordtype">double</span>) original_num);
<a name="l01581"></a>01581 
<a name="l01582"></a>01582   <a class="code" href="lib__skeleton_8h.html#0017ada9be12f3b512275e039cff6f26">info</a>(<span class="stringliteral">"whittleSkeleton: Using %s to reduce %d nodes to approximately %d"</span>, 
<a name="l01583"></a>01583        <a class="code" href="lib__skeleton_8c.html#4bfc93887121689d8263fbf6a950dc9e">getWhittleAlgorithmName</a>(wtype), original_num, target_num);
<a name="l01584"></a>01584 
<a name="l01585"></a>01585 
<a name="l01586"></a>01586   <span class="keywordflow">if</span>( (!((desired_remaining_fraction&gt;0.0) &amp;&amp; (desired_remaining_fraction&lt;1.0))) ||
<a name="l01587"></a>01587       (target_num&lt;2) || (target_num==original_num)){
<a name="l01588"></a>01588     printf(<span class="stringliteral">"Whittle fraction: %.3lf. TBD code to handle this specifically\n"</span>, desired_remaining_fraction);
<a name="l01589"></a>01589     <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce464a3d55131c355cdf036f95d0d7e1a6e">FC_INPUT_ERROR</a>;
<a name="l01590"></a>01590   }
<a name="l01591"></a>01591 
<a name="l01592"></a>01592 
<a name="l01593"></a>01593   rc = <a class="code" href="lib__skeleton_8c.html#3a87b0160af49f652c2d68f1a89f4fda">replicateSpanningTree</a>(ti, &amp;t1); <a class="code" href="group__ErrorHandling.html#gcc9949110ba62c7ec8fabf7b455f1c0b" title="If the return code is an error, print diagnostic and exit.">fc_exitIfError</a>(rc);
<a name="l01594"></a>01594   t2 = NULL;  
<a name="l01595"></a>01595   <span class="keywordflow">while</span>(target_num &lt; t1-&gt;numNodes){
<a name="l01596"></a>01596 
<a name="l01597"></a>01597     <span class="keywordflow">switch</span>(wtype){
<a name="l01598"></a>01598     <span class="keywordflow">case</span> <a class="code" href="lib__skeleton_8h.html#e8816f1d3f4ad9da003a2123bda65c0e13314f2f047ef7babc50d4783fed7308">FC_WA_OCTANTS</a>:
<a name="l01599"></a>01599       <a class="code" href="lib__skeleton_8c.html#52797a8bfd7f87a6b7885e7d7d899164">whittleSkeletonOctants</a>(t1, 2, &amp;t2);  <span class="comment">//Arg: per_octant</span>
<a name="l01600"></a>01600       <span class="keywordflow">break</span>;
<a name="l01601"></a>01601 
<a name="l01602"></a>01602     <span class="keywordflow">case</span> <a class="code" href="lib__skeleton_8h.html#e8816f1d3f4ad9da003a2123bda65c0e74d840c1a76d5638ed42259ac2d11db8">FC_WA_MIN_DESCENDANTS</a>:
<a name="l01603"></a>01603       <a class="code" href="lib__skeleton_8c.html#86855ab9e0052da9fc707bdab89f654c">whittleSkeletonByNumDescendents</a>(t1, 1, &amp;t2);  <span class="comment">//Arg: per_octant</span>
<a name="l01604"></a>01604       <span class="keywordflow">break</span>;
<a name="l01605"></a>01605 
<a name="l01606"></a>01606     <span class="keywordflow">case</span> <a class="code" href="lib__skeleton_8h.html#e8816f1d3f4ad9da003a2123bda65c0e9bc01b48a2e49f9743e4f9a423ac7ee9">FC_WA_MIN_SEGMENT_LENGTHS</a>:
<a name="l01607"></a>01607       <a class="code" href="lib__skeleton_8c.html#eee1feae7f79973980a4240ba7927336">whittleSkeletonBySegmentLengths</a>(t1, &amp;t2);  
<a name="l01608"></a>01608       <span class="keywordflow">break</span>;
<a name="l01609"></a>01609 
<a name="l01610"></a>01610     <span class="keywordflow">case</span> <a class="code" href="lib__skeleton_8h.html#e8816f1d3f4ad9da003a2123bda65c0e9fa17d3a07983a98e01afdd865792d42">FC_WA_MIN_ANGLE_CHANGE</a>:
<a name="l01611"></a>01611       <a class="code" href="lib__skeleton_8c.html#c37ad820c3b0940495acdd8a8fba3381">whittleSkeletonByDullestAngles</a>(t1, &amp;t2); 
<a name="l01612"></a>01612       <span class="keywordflow">break</span>;
<a name="l01613"></a>01613 
<a name="l01614"></a>01614     <span class="keywordflow">default</span>:
<a name="l01615"></a>01615       <a class="code" href="group__Library.html#g1473e77471cd1319f76eb9a32e4ad91f" title="Print an error message to stderr.">fc_printfErrorMessage</a>(<span class="stringliteral">"Unknown whittle type\n"</span>);
<a name="l01616"></a>01616       <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce464a3d55131c355cdf036f95d0d7e1a6e">FC_INPUT_ERROR</a>;
<a name="l01617"></a>01617     }
<a name="l01618"></a>01618     printf(<span class="stringliteral">"Whittle num nodes: %d goal: %d\n"</span>, t2-&gt;<a class="code" href="structspanning__tree__t.html#5ccb47c8e349067ee6017e091d02306e">numNodes</a>, target_num);
<a name="l01619"></a>01619 
<a name="l01620"></a>01620     <span class="comment">//Get rid of previous tree</span>
<a name="l01621"></a>01621     <a class="code" href="lib__skeleton_8h.html#834f31033781e091a3dbdfe16f7e8285">FREE</a>(t1-&gt;<a class="code" href="structspanning__tree__t.html#31d1d9e54040f7634f16cdddd1c24760">nodes</a>);
<a name="l01622"></a>01622     <a class="code" href="lib__skeleton_8h.html#834f31033781e091a3dbdfe16f7e8285">FREE</a>(t1);
<a name="l01623"></a>01623     
<a name="l01624"></a>01624     t1 = t2;
<a name="l01625"></a>01625 
<a name="l01626"></a>01626   }
<a name="l01627"></a>01627   
<a name="l01628"></a>01628   *to = t2;
<a name="l01629"></a>01629 
<a name="l01630"></a>01630   <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a40aa471d085988d5b582669f766ce46687acb19dbc2e15e6e89cdc39e8e18e">FC_SUCCESS</a>;
<a name="l01631"></a>01631 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="c37ad820c3b0940495acdd8a8fba3381"></a><!-- doxytag: member="lib_skeleton.h::whittleSkeletonByDullestAngles" ref="c37ad820c3b0940495acdd8a8fba3381" args="(spanning_tree_t *ti, spanning_tree_t **to)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void whittleSkeletonByDullestAngles           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structspanning__tree__t.html">spanning_tree_t</a> *&nbsp;</td>
          <td class="paramname"> <em>ti</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structspanning__tree__t.html">spanning_tree_t</a> **&nbsp;</td>
          <td class="paramname"> <em>to</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="lib__skeleton_8c-source.html#l01338">1338</a> of file <a class="el" href="lib__skeleton_8c-source.html">lib_skeleton.c</a>.</p>

<p>References <a class="el" href="lib__skeleton_8c-source.html#l01291">findSharpestAngleForNodeIndex()</a>, <a class="el" href="lib__skeleton_8h-source.html#l00076">spanning_tree_t::numNodes</a>, and <a class="el" href="lib__skeleton_8c-source.html#l00988">replicateSpanningTreeWithMask()</a>.</p>

<p>Referenced by <a class="el" href="lib__skeleton_8c-source.html#l01567">whittleSkeleton()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l01338"></a>01338                                                                                {
<a name="l01339"></a>01339 
<a name="l01340"></a>01340   <span class="keywordtype">int</span> i;
<a name="l01341"></a>01341   <span class="keywordtype">int</span> dullest_idx;
<a name="l01342"></a>01342   <span class="keywordtype">double</span> dullest_angle;
<a name="l01343"></a>01343   <span class="keywordtype">double</span> tmp;
<a name="l01344"></a>01344   <span class="keywordtype">char</span> *mask;
<a name="l01345"></a>01345 
<a name="l01346"></a>01346 
<a name="l01347"></a>01347 <span class="preprocessor">#if (!ENABLE_OPENMP)</span>
<a name="l01348"></a>01348 <span class="preprocessor"></span>  dullest_idx = -1;
<a name="l01349"></a>01349   dullest_angle = 0.0;
<a name="l01350"></a>01350 
<a name="l01351"></a>01351   <span class="keywordflow">for</span>(i=0; i&lt;ti-&gt;<a class="code" href="structspanning__tree__t.html#5ccb47c8e349067ee6017e091d02306e">numNodes</a>; i++){
<a name="l01352"></a>01352     <span class="comment">//Look at the angle's for a node to see how critical it is</span>
<a name="l01353"></a>01353     tmp = <a class="code" href="lib__skeleton_8c.html#94b4444df04af53a4a3b5153af66034a">findSharpestAngleForNodeIndex</a>(ti, i);
<a name="l01354"></a>01354     <span class="keywordflow">if</span>(tmp&gt;dullest_angle){
<a name="l01355"></a>01355       dullest_angle = tmp;
<a name="l01356"></a>01356       dullest_idx   = i;
<a name="l01357"></a>01357     }
<a name="l01358"></a>01358   }
<a name="l01359"></a>01359 <span class="preprocessor">#else</span>
<a name="l01360"></a>01360 <span class="preprocessor"></span>
<a name="l01361"></a>01361   {
<a name="l01362"></a>01362     <span class="keywordtype">double</span> *tmp_dullest_angles;
<a name="l01363"></a>01363     <span class="keywordtype">int</span>    *tmp_dullest_idxs;
<a name="l01364"></a>01364 
<a name="l01365"></a>01365     <span class="keywordtype">int</span> id,nthreads;
<a name="l01366"></a>01366     <span class="keyword">const</span> <span class="keywordtype">int</span> chunk = 32;
<a name="l01367"></a>01367 
<a name="l01368"></a>01368 
<a name="l01369"></a>01369 <span class="preprocessor">    #pragma omp parallel private(i,id, tmp)</span>
<a name="l01370"></a>01370 <span class="preprocessor"></span>    {
<a name="l01371"></a>01371       <span class="keywordtype">id</span> = omp_get_thread_num();
<a name="l01372"></a>01372       
<a name="l01373"></a>01373       <span class="comment">//Root: allocate space and initialize it</span>
<a name="l01374"></a>01374       <span class="keywordflow">if</span> ( <span class="keywordtype">id</span> == 0 ) {
<a name="l01375"></a>01375      nthreads = omp_get_num_threads();
<a name="l01376"></a>01376      tmp_dullest_angles = (<span class="keywordtype">double</span> *)malloc(nthreads * <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l01377"></a>01377      tmp_dullest_idxs   =    (<span class="keywordtype">int</span> *)malloc(nthreads * <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
<a name="l01378"></a>01378      <span class="keywordflow">for</span>(i=0; i&lt;nthreads; i++)
<a name="l01379"></a>01379        tmp_dullest_angles[i] = 0.0;
<a name="l01380"></a>01380       }
<a name="l01381"></a>01381 
<a name="l01382"></a>01382 <span class="preprocessor">      #pragma omp barrier</span>
<a name="l01383"></a>01383 <span class="preprocessor"></span>
<a name="l01384"></a>01384 <span class="preprocessor">      #pragma omp for schedule(dynamic, chunk)</span>
<a name="l01385"></a>01385 <span class="preprocessor"></span>      <span class="keywordflow">for</span>(i=0; i&lt;ti-&gt;<a class="code" href="structspanning__tree__t.html#5ccb47c8e349067ee6017e091d02306e">numNodes</a>; i++){
<a name="l01386"></a>01386      <span class="comment">//Look at the angle's for a node to see how critical it is</span>
<a name="l01387"></a>01387      tmp = <a class="code" href="lib__skeleton_8c.html#94b4444df04af53a4a3b5153af66034a">findSharpestAngleForNodeIndex</a>(ti, i);
<a name="l01388"></a>01388      <span class="keywordflow">if</span>(tmp&gt;tmp_dullest_angles[<span class="keywordtype">id</span>]){
<a name="l01389"></a>01389        tmp_dullest_angles[id] = tmp;
<a name="l01390"></a>01390        tmp_dullest_idxs[id]   = i;
<a name="l01391"></a>01391      }
<a name="l01392"></a>01392       }
<a name="l01393"></a>01393 
<a name="l01394"></a>01394 <span class="preprocessor">      #pragma omp barrier</span>
<a name="l01395"></a>01395 <span class="preprocessor"></span>       
<a name="l01396"></a>01396       <span class="comment">//Combine all the results</span>
<a name="l01397"></a>01397       <span class="keywordflow">if</span>(<span class="keywordtype">id</span>==0){
<a name="l01398"></a>01398      <span class="keywordflow">for</span>(i=0, dullest_angle = 0.0; i&lt;nthreads; i++)
<a name="l01399"></a>01399        <span class="keywordflow">if</span>(tmp_dullest_angles[i]&gt;dullest_angle){
<a name="l01400"></a>01400          dullest_angle  = tmp_dullest_angles[i];
<a name="l01401"></a>01401          dullest_idx    = tmp_dullest_idxs[i];
<a name="l01402"></a>01402        }
<a name="l01403"></a>01403      free(tmp_dullest_angles);
<a name="l01404"></a>01404      free(tmp_dullest_idxs);
<a name="l01405"></a>01405       }
<a name="l01406"></a>01406     }
<a name="l01407"></a>01407 
<a name="l01408"></a>01408   }
<a name="l01409"></a>01409 
<a name="l01410"></a>01410 
<a name="l01411"></a>01411 
<a name="l01412"></a>01412 <span class="preprocessor">#endif</span>
<a name="l01413"></a>01413 <span class="preprocessor"></span>
<a name="l01414"></a>01414 
<a name="l01415"></a>01415   <span class="comment">//Create a mask with all values tagged except delete point</span>
<a name="l01416"></a>01416   mask = (<span class="keywordtype">char</span> *)malloc(ti-&gt;<a class="code" href="structspanning__tree__t.html#5ccb47c8e349067ee6017e091d02306e">numNodes</a>*<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));
<a name="l01417"></a>01417   memset(mask, 1, ti-&gt;<a class="code" href="structspanning__tree__t.html#5ccb47c8e349067ee6017e091d02306e">numNodes</a>*<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));
<a name="l01418"></a>01418   mask[dullest_idx] = 0;
<a name="l01419"></a>01419   
<a name="l01420"></a>01420   <a class="code" href="lib__skeleton_8c.html#1f8a114a3c3842487b9de9aa9a9fd1ae">replicateSpanningTreeWithMask</a>(ti, mask, to);
<a name="l01421"></a>01421 
<a name="l01422"></a>01422   free(mask);
<a name="l01423"></a>01423 
<a name="l01424"></a>01424 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="86855ab9e0052da9fc707bdab89f654c"></a><!-- doxytag: member="lib_skeleton.h::whittleSkeletonByNumDescendents" ref="86855ab9e0052da9fc707bdab89f654c" args="(spanning_tree_t *ti, int min, spanning_tree_t **to)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void whittleSkeletonByNumDescendents           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structspanning__tree__t.html">spanning_tree_t</a> *&nbsp;</td>
          <td class="paramname"> <em>ti</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structspanning__tree__t.html">spanning_tree_t</a> **&nbsp;</td>
          <td class="paramname"> <em>to</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="lib__skeleton_8c-source.html#l01103">1103</a> of file <a class="el" href="lib__skeleton_8c-source.html">lib_skeleton.c</a>.</p>

<p>References <a class="el" href="lib__skeleton_8c-source.html#l00267">fc_computeTreeDescendantsAncestors()</a>, <a class="el" href="error_8h-source.html#l00080">fc_exitIfError</a>, <a class="el" href="lib__skeleton_8h-source.html#l00077">spanning_tree_t::nodes</a>, <a class="el" href="lib__skeleton_8h-source.html#l00069">spanning_tree_node_t::num_descendants</a>, and <a class="el" href="lib__skeleton_8h-source.html#l00076">spanning_tree_t::numNodes</a>.</p>

<p>Referenced by <a class="el" href="lib__skeleton_8c-source.html#l01567">whittleSkeleton()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l01103"></a>01103                                                                                          {
<a name="l01104"></a>01104 
<a name="l01105"></a>01105   <span class="keywordtype">int</span> i,j;
<a name="l01106"></a>01106   <span class="keywordtype">int</span> new_nodes;
<a name="l01107"></a>01107   <a class="code" href="group__DataTypes.html#g2a40aa471d085988d5b582669f766ce4" title="Possible function return values.">FC_ReturnCode</a> rc;
<a name="l01108"></a>01108   <a class="code" href="structspanning__tree__t.html">spanning_tree_t</a> *t;
<a name="l01109"></a>01109 
<a name="l01110"></a>01110   
<a name="l01111"></a>01111 
<a name="l01112"></a>01112   <span class="comment">//Figure out how many nodes fit in here</span>
<a name="l01113"></a>01113   <span class="keywordflow">for</span>(i=0, new_nodes=0; i&lt;ti-&gt;<a class="code" href="structspanning__tree__t.html#5ccb47c8e349067ee6017e091d02306e">numNodes</a>; i++)
<a name="l01114"></a>01114     <span class="keywordflow">if</span>(ti-&gt;<a class="code" href="structspanning__tree__t.html#31d1d9e54040f7634f16cdddd1c24760">nodes</a>[i].<a class="code" href="structspanning__tree__node__t.html#48095c9cb31a1f850c5eb6e1a843de1e">num_descendants</a> &gt;= min) new_nodes++;
<a name="l01115"></a>01115 
<a name="l01116"></a>01116   
<a name="l01117"></a>01117   t = malloc(<span class="keyword">sizeof</span>(<a class="code" href="structspanning__tree__t.html">spanning_tree_t</a>));
<a name="l01118"></a>01118   memcpy(t, ti, <span class="keyword">sizeof</span>(<a class="code" href="structspanning__tree__t.html">spanning_tree_t</a>));
<a name="l01119"></a>01119   t-&gt;<a class="code" href="structspanning__tree__t.html#5ccb47c8e349067ee6017e091d02306e">numNodes</a> = new_nodes;
<a name="l01120"></a>01120   t-&gt;<a class="code" href="structspanning__tree__t.html#31d1d9e54040f7634f16cdddd1c24760">nodes</a> = malloc(new_nodes * <span class="keyword">sizeof</span>(<a class="code" href="structspanning__tree__node__t.html">spanning_tree_node_t</a>));
<a name="l01121"></a>01121 
<a name="l01122"></a>01122   <span class="comment">//Copy the nodes that match</span>
<a name="l01123"></a>01123   <span class="keywordflow">for</span>(i=0,j=0; i&lt;ti-&gt;<a class="code" href="structspanning__tree__t.html#5ccb47c8e349067ee6017e091d02306e">numNodes</a>; i++){
<a name="l01124"></a>01124     <span class="keywordflow">if</span>(ti-&gt;<a class="code" href="structspanning__tree__t.html#31d1d9e54040f7634f16cdddd1c24760">nodes</a>[i].<a class="code" href="structspanning__tree__node__t.html#48095c9cb31a1f850c5eb6e1a843de1e">num_descendants</a> &gt;= min){
<a name="l01125"></a>01125       memcpy(&amp;t-&gt;<a class="code" href="structspanning__tree__t.html#31d1d9e54040f7634f16cdddd1c24760">nodes</a>[j], &amp;ti-&gt;<a class="code" href="structspanning__tree__t.html#31d1d9e54040f7634f16cdddd1c24760">nodes</a>[i], <span class="keyword">sizeof</span>(<a class="code" href="structspanning__tree__node__t.html">spanning_tree_node_t</a>));
<a name="l01126"></a>01126       j++;
<a name="l01127"></a>01127     }
<a name="l01128"></a>01128   }
<a name="l01129"></a>01129 
<a name="l01130"></a>01130   <span class="comment">//Recompute the relatives</span>
<a name="l01131"></a>01131   rc = <a class="code" href="lib__skeleton_8c.html#dd3df4be2e7ca2ba3f19258cffb2e08a">fc_computeTreeDescendantsAncestors</a>(t);
<a name="l01132"></a>01132   <a class="code" href="group__ErrorHandling.html#gcc9949110ba62c7ec8fabf7b455f1c0b" title="If the return code is an error, print diagnostic and exit.">fc_exitIfError</a>(rc);
<a name="l01133"></a>01133 
<a name="l01134"></a>01134   *to = t;
<a name="l01135"></a>01135 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="eee1feae7f79973980a4240ba7927336"></a><!-- doxytag: member="lib_skeleton.h::whittleSkeletonBySegmentLengths" ref="eee1feae7f79973980a4240ba7927336" args="(spanning_tree_t *ti, spanning_tree_t **to)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void whittleSkeletonBySegmentLengths           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structspanning__tree__t.html">spanning_tree_t</a> *&nbsp;</td>
          <td class="paramname"> <em>ti</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structspanning__tree__t.html">spanning_tree_t</a> **&nbsp;</td>
          <td class="paramname"> <em>to</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="lib__skeleton_8c-source.html#l01198">1198</a> of file <a class="el" href="lib__skeleton_8c-source.html">lib_skeleton.c</a>.</p>

<p>References <a class="el" href="lib__skeleton_8c-source.html#l01146">findNetDistanceChangeWhenRemovingNode()</a>, <a class="el" href="lib__skeleton_8h-source.html#l00067">spanning_tree_node_t::id_stop</a>, <a class="el" href="lib__skeleton_8h-source.html#l00077">spanning_tree_t::nodes</a>, <a class="el" href="lib__skeleton_8h-source.html#l00076">spanning_tree_t::numNodes</a>, and <a class="el" href="lib__skeleton_8c-source.html#l00988">replicateSpanningTreeWithMask()</a>.</p>

<p>Referenced by <a class="el" href="lib__skeleton_8c-source.html#l01567">whittleSkeleton()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l01198"></a>01198                                                                                 {
<a name="l01199"></a>01199 
<a name="l01200"></a>01200   <span class="keywordtype">int</span> i;
<a name="l01201"></a>01201   <span class="keywordtype">int</span>    smallest_idx;
<a name="l01202"></a>01202   <span class="keywordtype">double</span> smallest_change;
<a name="l01203"></a>01203   <span class="keywordtype">double</span> tmp;
<a name="l01204"></a>01204   <span class="keywordtype">char</span> *mask;
<a name="l01205"></a>01205 
<a name="l01206"></a>01206 
<a name="l01207"></a>01207 <span class="preprocessor">#if (!ENABLE_OPENMP) //Serial code</span>
<a name="l01208"></a>01208 <span class="preprocessor"></span>
<a name="l01209"></a>01209   smallest_idx    = -1;
<a name="l01210"></a>01210   smallest_change = DBL_MAX;
<a name="l01211"></a>01211 
<a name="l01212"></a>01212   <span class="keywordflow">for</span>(i=0; i&lt;ti-&gt;<a class="code" href="structspanning__tree__t.html#5ccb47c8e349067ee6017e091d02306e">numNodes</a>; i++){
<a name="l01213"></a>01213     <span class="comment">//printf("Trying to remove node %d of %d\n", i, ti-&gt;numNodes);</span>
<a name="l01214"></a>01214     <span class="comment">//tmp1 = findNetDistanceChangeWhenRemovingNode(ti,ti-&gt;nodes[i].id_stop,1);</span>
<a name="l01215"></a>01215     tmp = <a class="code" href="lib__skeleton_8c.html#b4ef61362f16224cf043de8358e6e6f5">findNetDistanceChangeWhenRemovingNode</a>(ti,ti-&gt;<a class="code" href="structspanning__tree__t.html#31d1d9e54040f7634f16cdddd1c24760">nodes</a>[i].<a class="code" href="structspanning__tree__node__t.html#a7f8f7a44d9a169bf101223b7106d91a">id_stop</a>,0);
<a name="l01216"></a>01216 
<a name="l01217"></a>01217     <span class="keywordflow">if</span>(tmp&lt;smallest_change) {
<a name="l01218"></a>01218       smallest_change = tmp;
<a name="l01219"></a>01219       smallest_idx    = i;
<a name="l01220"></a>01220     }
<a name="l01221"></a>01221   }
<a name="l01222"></a>01222 
<a name="l01223"></a>01223 <span class="preprocessor">#else //OpenMP code</span>
<a name="l01224"></a>01224 <span class="preprocessor"></span>
<a name="l01225"></a>01225   {
<a name="l01226"></a>01226     <span class="keywordtype">double</span> *tmp_smallest_change;
<a name="l01227"></a>01227     <span class="keywordtype">int</span>    *tmp_smallest_idx;
<a name="l01228"></a>01228 
<a name="l01229"></a>01229     <span class="keywordtype">int</span> id,nthreads;
<a name="l01230"></a>01230     <span class="keyword">const</span> <span class="keywordtype">int</span> chunk = 32;
<a name="l01231"></a>01231 
<a name="l01232"></a>01232 <span class="preprocessor">    #pragma omp parallel  private(i,id, tmp)</span>
<a name="l01233"></a>01233 <span class="preprocessor"></span>    {
<a name="l01234"></a>01234       
<a name="l01235"></a>01235       <span class="keywordtype">id</span> = omp_get_thread_num();
<a name="l01236"></a>01236       
<a name="l01237"></a>01237       <span class="comment">//Root: allocate space and initialize it</span>
<a name="l01238"></a>01238       <span class="keywordflow">if</span> ( <span class="keywordtype">id</span> == 0 ) {
<a name="l01239"></a>01239      nthreads = omp_get_num_threads();
<a name="l01240"></a>01240      tmp_smallest_change = (<span class="keywordtype">double</span> *)malloc(nthreads * <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l01241"></a>01241      tmp_smallest_idx    =    (<span class="keywordtype">int</span> *)malloc(nthreads * <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
<a name="l01242"></a>01242      <span class="keywordflow">for</span>(i=0; i&lt;nthreads; i++)
<a name="l01243"></a>01243        tmp_smallest_change[i] = DBL_MAX;
<a name="l01244"></a>01244       }
<a name="l01245"></a>01245 
<a name="l01246"></a>01246 <span class="preprocessor">      #pragma omp barrier</span>
<a name="l01247"></a>01247 <span class="preprocessor"></span>
<a name="l01248"></a>01248 <span class="preprocessor">      #pragma omp for schedule(dynamic, chunk)</span>
<a name="l01249"></a>01249 <span class="preprocessor"></span>      <span class="keywordflow">for</span>(i=0; i&lt;ti-&gt;<a class="code" href="structspanning__tree__t.html#5ccb47c8e349067ee6017e091d02306e">numNodes</a>; i++){
<a name="l01250"></a>01250 
<a name="l01251"></a>01251      tmp = <a class="code" href="lib__skeleton_8c.html#b4ef61362f16224cf043de8358e6e6f5">findNetDistanceChangeWhenRemovingNode</a>(ti,ti-&gt;<a class="code" href="structspanning__tree__t.html#31d1d9e54040f7634f16cdddd1c24760">nodes</a>[i].<a class="code" href="structspanning__tree__node__t.html#a7f8f7a44d9a169bf101223b7106d91a">id_stop</a>,0);
<a name="l01252"></a>01252 
<a name="l01253"></a>01253      <span class="keywordflow">if</span>(tmp &lt; tmp_smallest_change[<span class="keywordtype">id</span>]){
<a name="l01254"></a>01254        tmp_smallest_change[id] = tmp;
<a name="l01255"></a>01255        tmp_smallest_idx[id]    = i;
<a name="l01256"></a>01256      }
<a name="l01257"></a>01257       }
<a name="l01258"></a>01258 
<a name="l01259"></a>01259 <span class="preprocessor">      #pragma omp barrier</span>
<a name="l01260"></a>01260 <span class="preprocessor"></span>
<a name="l01261"></a>01261       <span class="comment">//Combine all the results</span>
<a name="l01262"></a>01262       <span class="keywordflow">if</span>(<span class="keywordtype">id</span>==0){
<a name="l01263"></a>01263      <span class="keywordflow">for</span>(i=0, smallest_change = DBL_MAX; i&lt;nthreads; i++)
<a name="l01264"></a>01264        <span class="keywordflow">if</span>(tmp_smallest_change[i]&lt;smallest_change){
<a name="l01265"></a>01265          smallest_change = tmp_smallest_change[i];
<a name="l01266"></a>01266          smallest_idx    = tmp_smallest_idx[i];
<a name="l01267"></a>01267        }
<a name="l01268"></a>01268      free(tmp_smallest_change);
<a name="l01269"></a>01269      free(tmp_smallest_idx);
<a name="l01270"></a>01270       }
<a name="l01271"></a>01271 
<a name="l01272"></a>01272     }<span class="comment">//Done with threads</span>
<a name="l01273"></a>01273 
<a name="l01274"></a>01274   }
<a name="l01275"></a>01275 
<a name="l01276"></a>01276 <span class="preprocessor">#endif</span>
<a name="l01277"></a>01277 <span class="preprocessor"></span>
<a name="l01278"></a>01278 
<a name="l01279"></a>01279 
<a name="l01280"></a>01280   <span class="comment">//Create a mask with all values tagged except delete point</span>
<a name="l01281"></a>01281   mask = (<span class="keywordtype">char</span> *)malloc(ti-&gt;<a class="code" href="structspanning__tree__t.html#5ccb47c8e349067ee6017e091d02306e">numNodes</a>*<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));
<a name="l01282"></a>01282   memset(mask, 1, ti-&gt;<a class="code" href="structspanning__tree__t.html#5ccb47c8e349067ee6017e091d02306e">numNodes</a>*<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));
<a name="l01283"></a>01283   mask[smallest_idx] = 0;
<a name="l01284"></a>01284   
<a name="l01285"></a>01285   <a class="code" href="lib__skeleton_8c.html#1f8a114a3c3842487b9de9aa9a9fd1ae">replicateSpanningTreeWithMask</a>(ti, mask, to);
<a name="l01286"></a>01286 
<a name="l01287"></a>01287   free(mask);
<a name="l01288"></a>01288 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="52797a8bfd7f87a6b7885e7d7d899164"></a><!-- doxytag: member="lib_skeleton.h::whittleSkeletonOctants" ref="52797a8bfd7f87a6b7885e7d7d899164" args="(spanning_tree_t *ti, int per_oct, spanning_tree_t **to)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void whittleSkeletonOctants           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structspanning__tree__t.html">spanning_tree_t</a> *&nbsp;</td>
          <td class="paramname"> <em>ti</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>per_oct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structspanning__tree__t.html">spanning_tree_t</a> **&nbsp;</td>
          <td class="paramname"> <em>to</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="lib__skeleton_8c-source.html#l01427">1427</a> of file <a class="el" href="lib__skeleton_8c-source.html">lib_skeleton.c</a>.</p>

<p>References <a class="el" href="lib__skeleton_8h-source.html#l00081">spanning_tree_t::dim</a>, <a class="el" href="lib__skeleton_8h-source.html#l00084">spanning_tree_t::elementCenters</a>, <a class="el" href="error_8h-source.html#l00080">fc_exitIfError</a>, <a class="el" href="lib__skeleton_8h-source.html#l00077">spanning_tree_t::nodes</a>, <a class="el" href="lib__skeleton_8h-source.html#l00076">spanning_tree_t::numNodes</a>, <a class="el" href="lib__skeleton_8c-source.html#l00988">replicateSpanningTreeWithMask()</a>, <a class="el" href="lib__skeleton_8h-source.html#l00075">spanning_tree_t::root</a>, and <a class="el" href="lib__skeleton_8c-source.html#l01073">treeTagNodesAncestorsMask()</a>.</p>

<p>Referenced by <a class="el" href="lib__skeleton_8c-source.html#l01567">whittleSkeleton()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l01427"></a>01427                                                                                     {
<a name="l01428"></a>01428 
<a name="l01429"></a>01429   <span class="keywordtype">int</span> i,j,k;
<a name="l01430"></a>01430   
<a name="l01431"></a>01431   <span class="keywordtype">int</span>    *best_ids;
<a name="l01432"></a>01432   <span class="keywordtype">double</span> *best_dist;
<a name="l01433"></a>01433   <span class="keywordtype">int</span>     oid;
<a name="l01434"></a>01434   <span class="keywordtype">int</span>     dim;
<a name="l01435"></a>01435   <a class="code" href="structspanning__tree__node__t.html">spanning_tree_node_t</a> *nodes;
<a name="l01436"></a>01436   <a class="code" href="group__SimpleDataObjects.html#gf0a2bdabac4a21b42f4b480baf9128d7" title="Coordinates data structure.">FC_Coords</a> cntr;
<a name="l01437"></a>01437   <span class="keywordtype">double</span> *cntrs;
<a name="l01438"></a>01438   <span class="keywordtype">char</span>   *hits;
<a name="l01439"></a>01439   <a class="code" href="structspanning__tree__t.html">spanning_tree_t</a> *t2;
<a name="l01440"></a>01440   <a class="code" href="group__DataTypes.html#g2a40aa471d085988d5b582669f766ce4" title="Possible function return values.">FC_ReturnCode</a> rc;
<a name="l01441"></a>01441 
<a name="l01442"></a>01442   <span class="comment">//shorthand</span>
<a name="l01443"></a>01443 
<a name="l01444"></a>01444   nodes = ti-&gt;<a class="code" href="structspanning__tree__t.html#31d1d9e54040f7634f16cdddd1c24760">nodes</a>;
<a name="l01445"></a>01445   cntrs = ti-&gt;<a class="code" href="structspanning__tree__t.html#4a6035ff3412486e6beff9f9a636401b">elementCenters</a>;
<a name="l01446"></a>01446   dim   = ti-&gt;<a class="code" href="structspanning__tree__t.html#6aca20c85f139938862367cc664ef52f">dim</a>;
<a name="l01447"></a>01447   memcpy(&amp;cntr, &amp;cntrs[ti-&gt;<a class="code" href="structspanning__tree__t.html#2f7ebb14ff208bc06e6a184175c8b8ff">root</a>*dim], dim*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l01448"></a>01448 
<a name="l01449"></a>01449 
<a name="l01450"></a>01450   best_ids  = (<span class="keywordtype">int</span> *)    malloc(per_oct*8*<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
<a name="l01451"></a>01451   best_dist = (<span class="keywordtype">double</span> *) malloc(per_oct*8*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l01452"></a>01452   <span class="keywordflow">for</span>(i=0;i&lt;per_oct*8; i++){
<a name="l01453"></a>01453     best_ids[i]=-1;
<a name="l01454"></a>01454     best_dist[i]=DBL_MAX;
<a name="l01455"></a>01455   }
<a name="l01456"></a>01456 
<a name="l01457"></a>01457   <span class="comment">//Take a look at everyone and find the best matches in each quadrant</span>
<a name="l01458"></a>01458   <span class="keywordflow">for</span>(i=0;i&lt;ti-&gt;<a class="code" href="structspanning__tree__t.html#5ccb47c8e349067ee6017e091d02306e">numNodes</a>;i++){
<a name="l01459"></a>01459     
<a name="l01460"></a>01460     <span class="comment">//Uncomment if you only want endpoints </span>
<a name="l01461"></a>01461     <span class="comment">//if(!ti-&gt;nodes[i].num_descendants) continue;</span>
<a name="l01462"></a>01462 
<a name="l01463"></a>01463     <span class="comment">//Figure out what quadrant this is in</span>
<a name="l01464"></a>01464     <span class="keywordflow">for</span>(oid=0, j=0; j&lt;dim; j++){
<a name="l01465"></a>01465       <span class="keywordflow">if</span>(cntr[j] &lt; cntrs[ (nodes[i].id_stop*dim) + j ]) 
<a name="l01466"></a>01466      oid |= (1&lt;&lt;j);
<a name="l01467"></a>01467     }
<a name="l01468"></a>01468 
<a name="l01469"></a>01469     assert((oid&gt;=0) &amp;&amp; (oid&lt;8));
<a name="l01470"></a>01470 
<a name="l01471"></a>01471     <span class="comment">//See if the distance is better than best known</span>
<a name="l01472"></a>01472     <span class="keywordflow">for</span>(j=0;j&lt;per_oct;j++){
<a name="l01473"></a>01473       <span class="keywordflow">if</span>( (best_ids[  (oid*per_oct) + j] &lt; 0)                    ||
<a name="l01474"></a>01474        (best_dist[ (oid*per_oct) + j] &lt; nodes[i].dist_center)   ){
<a name="l01475"></a>01475 
<a name="l01476"></a>01476      <span class="comment">//Shift worse answers right</span>
<a name="l01477"></a>01477      <span class="keywordflow">for</span>(k=per_oct-1; k&gt;j; k--){
<a name="l01478"></a>01478        best_ids[ (oid*per_oct) + k] = best_ids[ (oid*per_oct) + k-1];
<a name="l01479"></a>01479        best_dist[(oid*per_oct) + k] = best_dist[(oid*per_oct) + k-1];
<a name="l01480"></a>01480      }
<a name="l01481"></a>01481 
<a name="l01482"></a>01482      <span class="comment">//Insert in spot</span>
<a name="l01483"></a>01483      best_ids[ (oid*per_oct) + j] = i;
<a name="l01484"></a>01484      best_dist[(oid*per_oct) + j] = nodes[i].dist_center;
<a name="l01485"></a>01485       }
<a name="l01486"></a>01486     }
<a name="l01487"></a>01487   }
<a name="l01488"></a>01488 
<a name="l01489"></a>01489   <span class="comment">//Tag all the winners, and all the winners' ancestors</span>
<a name="l01490"></a>01490   hits = (<span class="keywordtype">char</span> *)calloc(ti-&gt;<a class="code" href="structspanning__tree__t.html#5ccb47c8e349067ee6017e091d02306e">numNodes</a>, <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));
<a name="l01491"></a>01491   <span class="keywordflow">for</span>(i=0; i&lt;8*per_oct; i++){
<a name="l01492"></a>01492     <span class="keywordflow">if</span>(best_ids[i]&lt;0) <span class="keywordflow">continue</span>; <span class="comment">//ran out of hits in this quadrant</span>
<a name="l01493"></a>01493     rc = <a class="code" href="lib__skeleton_8c.html#b5c9306837e2cd641fe31648e1a3d8cd">treeTagNodesAncestorsMask</a>(ti, nodes[best_ids[i]].id_stop, hits);
<a name="l01494"></a>01494     <a class="code" href="group__ErrorHandling.html#gcc9949110ba62c7ec8fabf7b455f1c0b" title="If the return code is an error, print diagnostic and exit.">fc_exitIfError</a>(rc);
<a name="l01495"></a>01495   }
<a name="l01496"></a>01496   <span class="comment">//Use the mask to create a new tree</span>
<a name="l01497"></a>01497   rc = <a class="code" href="lib__skeleton_8c.html#1f8a114a3c3842487b9de9aa9a9fd1ae">replicateSpanningTreeWithMask</a>(ti, hits, &amp;t2);
<a name="l01498"></a>01498   <a class="code" href="group__ErrorHandling.html#gcc9949110ba62c7ec8fabf7b455f1c0b" title="If the return code is an error, print diagnostic and exit.">fc_exitIfError</a>(rc);
<a name="l01499"></a>01499 
<a name="l01500"></a>01500   free(hits);
<a name="l01501"></a>01501 
<a name="l01502"></a>01502   <span class="comment">//Copy out</span>
<a name="l01503"></a>01503   *to = t2;
<a name="l01504"></a>01504 
<a name="l01505"></a>01505 <span class="comment"></span>
<a name="l01506"></a>01506 <span class="comment">  ////Tag each ancestor that belongs to this guy</span>
<a name="l01507"></a>01507 <span class="comment"></span>  <span class="comment">//k=best_ids[i];</span>
<a name="l01508"></a>01508   <span class="comment">//search_node = nodes[k].id_stop; //First time we fake</span>
<a name="l01509"></a>01509   <span class="comment">//do{</span>
<a name="l01510"></a>01510   <span class="comment">//  while(nodes[k].id_stop != search_node) k--; //look for next ancestor</span>
<a name="l01511"></a>01511   <span class="comment">//  hits[k]=1;</span>
<a name="l01512"></a>01512   <span class="comment">//  search_node = nodes[k].id_start; //get parent </span>
<a name="l01513"></a>01513   <span class="comment">//}while(search_node!=ti-&gt;root);</span>
<a name="l01514"></a>01514   
<a name="l01515"></a>01515 
<a name="l01516"></a>01516 
<a name="l01517"></a>01517 }
</pre></div>
<p>

</div>
</div><p>
<hr><h2>Variable Documentation</h2>
<a class="anchor" name="733f286889c9c15dcbfddcf65b28290d"></a><!-- doxytag: member="lib_skeleton.h::_skeleton_dbg" ref="733f286889c9c15dcbfddcf65b28290d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="lib__skeleton_8h.html#733f286889c9c15dcbfddcf65b28290d">_skeleton_dbg</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="lib__skeleton_8c-source.html#l00053">53</a> of file <a class="el" href="lib__skeleton_8c-source.html">lib_skeleton.c</a>.</p>

<p>Referenced by <a class="el" href="generate__tree_8c-source.html#l00109">checkArgs()</a>, and <a class="el" href="whittle__tree_8c-source.html#l00103">main()</a>.</p>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Mon Oct 27 13:26:13 2008 for FCLib by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
