<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>FCLib: tools/tears.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="classes.html"><span>Data&nbsp;Structures</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>Globals</span></a></li>
  </ul></div>
<h1>tools/tears.c</h1><a href="tears_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> * Copyright (2000) Sandia Corporation. Under the terms of Contract</span>
<a name="l00003"></a>00003 <span class="comment"> * DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains</span>
<a name="l00004"></a>00004 <span class="comment"> * certain rights in this software.</span>
<a name="l00005"></a>00005 <span class="comment"> *</span>
<a name="l00006"></a>00006 <span class="comment"> * Redistribution and use in source and binary forms, with or without</span>
<a name="l00007"></a>00007 <span class="comment"> * modification, are permitted provided that the following conditions are met:</span>
<a name="l00008"></a>00008 <span class="comment"> *</span>
<a name="l00009"></a>00009 <span class="comment"> *   * Redistributions of source code must retain the above copyright</span>
<a name="l00010"></a>00010 <span class="comment"> *     notice, this list of conditions and the following disclaimer.</span>
<a name="l00011"></a>00011 <span class="comment"> *</span>
<a name="l00012"></a>00012 <span class="comment"> *   * Redistributions in binary form must reproduce the above copyright</span>
<a name="l00013"></a>00013 <span class="comment"> *     notice, this list of conditions and the following disclaimer in the</span>
<a name="l00014"></a>00014 <span class="comment"> *     documentation and/or other materials provided with the</span>
<a name="l00015"></a>00015 <span class="comment"> *     distribution.</span>
<a name="l00016"></a>00016 <span class="comment"> *</span>
<a name="l00017"></a>00017 <span class="comment"> *   * Neither the name of Sandia nor the names of any contributors may</span>
<a name="l00018"></a>00018 <span class="comment"> *     be used to endorse or promote products derived from this software</span>
<a name="l00019"></a>00019 <span class="comment"> *     without specific prior written permission.</span>
<a name="l00020"></a>00020 <span class="comment"> *</span>
<a name="l00021"></a>00021 <span class="comment"> *   * Modified source versions must be plainly marked as such, and must</span>
<a name="l00022"></a>00022 <span class="comment"> *     not be misrepresented as being the original software.</span>
<a name="l00023"></a>00023 <span class="comment"> *</span>
<a name="l00024"></a>00024 <span class="comment"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"</span>
<a name="l00025"></a>00025 <span class="comment"> * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</span>
<a name="l00026"></a>00026 <span class="comment"> * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</span>
<a name="l00027"></a>00027 <span class="comment"> * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE LIABLE FOR</span>
<a name="l00028"></a>00028 <span class="comment"> * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</span>
<a name="l00029"></a>00029 <span class="comment"> * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR</span>
<a name="l00030"></a>00030 <span class="comment"> * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER</span>
<a name="l00031"></a>00031 <span class="comment"> * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</span>
<a name="l00032"></a>00032 <span class="comment"> * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY</span>
<a name="l00033"></a>00033 <span class="comment"> * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH</span>
<a name="l00034"></a>00034 <span class="comment"> * DAMAGE.</span>
<a name="l00035"></a>00035 <span class="comment"> */</span>
<a name="l00036"></a>00036 <span class="comment"></span>
<a name="l00037"></a>00037 <span class="comment">/**</span>
<a name="l00038"></a>00038 <span class="comment"> * \file tears.c</span>
<a name="l00039"></a>00039 <span class="comment"> * \brief Report tear characterizations on given dataset.</span>
<a name="l00040"></a>00040 <span class="comment"> *</span>
<a name="l00041"></a>00041 <span class="comment"> * $Source: /usr/local/Repositories/fcdmf/fclib/tools/tears.c,v $</span>
<a name="l00042"></a>00042 <span class="comment"> * $Revision: 1.31 $</span>
<a name="l00043"></a>00043 <span class="comment"> * $Date: 2006/11/10 19:38:18 $</span>
<a name="l00044"></a>00044 <span class="comment"> *</span>
<a name="l00045"></a>00045 <span class="comment"> * \description</span>
<a name="l00046"></a>00046 <span class="comment"> *    Usage: tears [options] dataset [var_name]</span>
<a name="l00047"></a>00047 <span class="comment"> *</span>
<a name="l00048"></a>00048 <span class="comment"> *    A tear is a region of dead elements. This routine reports for the last</span>
<a name="l00049"></a>00049 <span class="comment"> *    time step:</span>
<a name="l00050"></a>00050 <span class="comment"> *</span>
<a name="l00051"></a>00051 <span class="comment"> *      - The number of cells in a tear.</span>
<a name="l00052"></a>00052 <span class="comment"> *</span>
<a name="l00053"></a>00053 <span class="comment"> *      - The volume of the tear on the original mesh (dead elements may not</span>
<a name="l00054"></a>00054 <span class="comment"> *        behave proproperly so dead element volume cannot be calculated).</span>
<a name="l00055"></a>00055 <span class="comment"> *</span>
<a name="l00056"></a>00056 <span class="comment"> *      - A characteristic tear length which is the largest distance between</span>
<a name="l00057"></a>00057 <span class="comment"> *        any two vertices that define the surface of the dead region. If a</span>
<a name="l00058"></a>00058 <span class="comment"> *        displacement variable is provided, it will report the tear length of </span>
<a name="l00059"></a>00059 <span class="comment"> *        the displaced geometry in addition to the tear length in the time </span>
<a name="l00060"></a>00060 <span class="comment"> *        zero geometry.</span>
<a name="l00061"></a>00061 <span class="comment"> *</span>
<a name="l00062"></a>00062 <span class="comment"> *      - (Optional) Damage-weighted volumes. The user has to supply two</span>
<a name="l00063"></a>00063 <span class="comment"> *        "death" criteria, the first one for dead elements and the second</span>
<a name="l00064"></a>00064 <span class="comment"> *        for damaged elements. The tears are the unions of these two criteria.</span>
<a name="l00065"></a>00065 <span class="comment"> *        If the two sets overlap, the overlap elements are considered to</span>
<a name="l00066"></a>00066 <span class="comment"> *        be in the dead set.</span>
<a name="l00067"></a>00067 <span class="comment"> *</span>
<a name="l00068"></a>00068 <span class="comment"> *</span>
<a name="l00069"></a>00069 <span class="comment"> *   SHAPE INFORMATION</span>
<a name="l00070"></a>00070 <span class="comment"> *</span>
<a name="l00071"></a>00071 <span class="comment"> *     &lt;DL&gt;</span>
<a name="l00072"></a>00072 <span class="comment"> *     &lt;DT&gt; Shape Information: &lt;/DT&gt;      </span>
<a name="l00073"></a>00073 <span class="comment"> *          &lt;DD&gt;</span>
<a name="l00074"></a>00074 <span class="comment"> *          &lt;DL&gt;</span>
<a name="l00075"></a>00075 <span class="comment"> *          &lt;DT&gt;For each mesh with a tear, shape information is printed.</span>
<a name="l00076"></a>00076 <span class="comment"> *          Example:&lt;/DT&gt;</span>
<a name="l00077"></a>00077 <span class="comment"> *           &lt;DD&gt;</span>
<a name="l00078"></a>00078 <span class="comment"> *</span>
<a name="l00079"></a>00079 <span class="comment"> *           Shape (0:0) (5 sides):                         \n</span>
<a name="l00080"></a>00080 <span class="comment"> *           Thin shape approx 1: (0 4)                     \n</span>
<a name="l00081"></a>00081 <span class="comment"> *           Thin shape approx 2: (0 4)                     \n</span>
<a name="l00082"></a>00082 <span class="comment"> *           Screw shape: NA                                \n</span>
<a name="l00083"></a>00083 <span class="comment"> *           Ends: NA                                       \n</span>
<a name="l00084"></a>00084 <span class="comment"> *           Sides in area order (descending) ( 0 4 1 3 2)  \n</span>
<a name="l00085"></a>00085 <span class="comment"> *                                                          \n</span>
<a name="l00086"></a>00086 <span class="comment"> *           where Shape is labeled by (meshid:shapeid)     \n   </span>
<a name="l00087"></a>00087 <span class="comment"> *          &lt;/DD&gt;</span>
<a name="l00088"></a>00088 <span class="comment"> *          &lt;/DL&gt;</span>
<a name="l00089"></a>00089 <span class="comment"> *          &lt;/DD&gt;</span>
<a name="l00090"></a>00090 <span class="comment"> *</span>
<a name="l00091"></a>00091 <span class="comment"> *    &lt;DT&gt; Shape-tear information: &lt;/DT&gt;</span>
<a name="l00092"></a>00092 <span class="comment"> *         &lt;DD&gt;</span>
<a name="l00093"></a>00093 <span class="comment"> *         &lt;DL&gt; </span>
<a name="l00094"></a>00094 <span class="comment"> *         &lt;DT&gt; For each tear, shape information is printed.</span>
<a name="l00095"></a>00095 <span class="comment"> *         Example:&lt;/DT&gt;</span>
<a name="l00096"></a>00096 <span class="comment"> *            &lt;DD&gt;</span>
<a name="l00097"></a>00097 <span class="comment"> *</span>
<a name="l00098"></a>00098 <span class="comment"> *            Subtear 14 Intersections with Shape (0:0) (TUNNEL,NONADJSIDES,MAJOR): ( 17) ( 5)</span>
<a name="l00099"></a>00099 <span class="comment"> *            &lt;/DD&gt;</span>
<a name="l00100"></a>00100 <span class="comment"> *         &lt;DT&gt; Summary info on a per shape basis is also provided, with the</span>
<a name="l00101"></a>00101 <span class="comment"> *           types of tears and (major/overall) ratio of each.</span>
<a name="l00102"></a>00102 <span class="comment"> *           Example:&lt;/DT&gt;</span>
<a name="l00103"></a>00103 <span class="comment"> *           &lt;DD&gt;</span>
<a name="l00104"></a>00104 <span class="comment"> *</span>
<a name="l00105"></a>00105 <span class="comment"> *           Tears 18: BREAKS (0/0) TUNNELS (10/0) PITS (8/13)</span>
<a name="l00106"></a>00106 <span class="comment"> *           &lt;/DD&gt;</span>
<a name="l00107"></a>00107 <span class="comment"> *         &lt;/DL&gt;</span>
<a name="l00108"></a>00108 <span class="comment"> *         &lt;/DD&gt;</span>
<a name="l00109"></a>00109 <span class="comment"> *     &lt;/DL&gt;</span>
<a name="l00110"></a>00110 <span class="comment"> *   </span>
<a name="l00111"></a>00111 <span class="comment"> *</span>
<a name="l00112"></a>00112 <span class="comment"> *</span>
<a name="l00113"></a>00113 <span class="comment"> *    SHAPE DETAILS</span>
<a name="l00114"></a>00114 <span class="comment"> *</span>
<a name="l00115"></a>00115 <span class="comment"> *    A shape is a contiguous, distinct starting live region in a mesh.</span>
<a name="l00116"></a>00116 <span class="comment"> *    For instance, a mesh made of N separate screws will have N</span>
<a name="l00117"></a>00117 <span class="comment"> *    shapes. A shape is distinguished by its sides and the adjacency</span>
<a name="l00118"></a>00118 <span class="comment"> *    information of those sides. Only skin information is kept for</span>
<a name="l00119"></a>00119 <span class="comment"> *    each shape (no info on innards).</span>
<a name="l00120"></a>00120 <span class="comment"> *</span>
<a name="l00121"></a>00121 <span class="comment"> *    The number of sides is very dependent on the angle chosen (optional</span>
<a name="l00122"></a>00122 <span class="comment"> *    input argument) to distinguish which faces get merged into which side.</span>
<a name="l00123"></a>00123 <span class="comment"> *    If it is set too large, shapes with gradually curved</span>
<a name="l00124"></a>00124 <span class="comment"> *    edges (like a block wiht curved edges) may come out with too few sides.</span>
<a name="l00125"></a>00125 <span class="comment"> *    On the other hand, if the angle is set too low, a curved side in a</span>
<a name="l00126"></a>00126 <span class="comment"> *    shape (like a screw) may come out a large number of very small sides.</span>
<a name="l00127"></a>00127 <span class="comment"> *    There is currently no writeout to see what constitutes a side,</span>
<a name="l00128"></a>00128 <span class="comment"> *    though some meaningful information is given as described below.</span>
<a name="l00129"></a>00129 <span class="comment"> *</span>
<a name="l00130"></a>00130 <span class="comment"> *    Some approximations are made which attempt to distinguish sides</span>
<a name="l00131"></a>00131 <span class="comment"> *    of interest:</span>
<a name="l00132"></a>00132 <span class="comment"> *      - thin shape: tries to find sides of interest in a shape that</span>
<a name="l00133"></a>00133 <span class="comment"> *         is thin in some dimension</span>
<a name="l00134"></a>00134 <span class="comment"> *             &lt;ul&gt;</span>
<a name="l00135"></a>00135 <span class="comment"> *             &lt;li&gt;approx 1 returns the largest side and its largest</span>
<a name="l00136"></a>00136 <span class="comment"> *               non-adj side. this is fairly good for finding</span>
<a name="l00137"></a>00137 <span class="comment"> *               the two largest surfaces of something like a can</span>
<a name="l00138"></a>00138 <span class="comment"> *               with a curved inner and outer shell</span>
<a name="l00139"></a>00139 <span class="comment"> *             &lt;li&gt; approx 2 returns the largest side that has an</span>
<a name="l00140"></a>00140 <span class="comment"> *                  opposing side. An opposing side is defined as</span>
<a name="l00141"></a>00141 <span class="comment"> *                  one that is non-adj to the original side with</span>
<a name="l00142"></a>00142 <span class="comment"> *                  an average normal that points in a roughly opposing</span>
<a name="l00143"></a>00143 <span class="comment"> *                  direction  -- within OPPOSINGSIDEANGLE degrees of</span>
<a name="l00144"></a>00144 <span class="comment"> *                  180 (currently a constant 10 degrees) -- to that of</span>
<a name="l00145"></a>00145 <span class="comment"> *                  the original side.</span>
<a name="l00146"></a>00146 <span class="comment"> *             &lt;/ul&gt;</span>
<a name="l00147"></a>00147 <span class="comment"> *      - screw: traditional 5 sided screw, listed in order from</span>
<a name="l00148"></a>00148 <span class="comment"> *               the top of the head down to the small base</span>
<a name="l00149"></a>00149 <span class="comment"> *      - ends: any side only adjacent to one other side</span>
<a name="l00150"></a>00150 <span class="comment"> *      - descending area order: sides listed in decreasing area</span>
<a name="l00151"></a>00151 <span class="comment"> *    NA is used to mark any case where the approx is not valid.</span>
<a name="l00152"></a>00152 <span class="comment"> *</span>
<a name="l00153"></a>00153 <span class="comment"> *    Information is given on each tear as to the number of intersections it</span>
<a name="l00154"></a>00154 <span class="comment"> *    has with a shape and which sides are intersected. It is further catagoried</span>
<a name="l00155"></a>00155 <span class="comment"> *    by:</span>
<a name="l00156"></a>00156 <span class="comment"> *     types: (these catagories are shape independent)</span>
<a name="l00157"></a>00157 <span class="comment"> *     - BREAK - breaks the shape into more than one piece</span>
<a name="l00158"></a>00158 <span class="comment"> *     - TUNNEL - intersects the shape (skin) in more than 1 place </span>
<a name="l00159"></a>00159 <span class="comment"> *     - PIT - intersects in a single place</span>
<a name="l00160"></a>00160 <span class="comment"> *     subtypes: (these catagories are shape dependent)</span>
<a name="l00161"></a>00161 <span class="comment"> *     - SINGLESIDE - intersects only a single side (but may be multiple times)</span>
<a name="l00162"></a>00162 <span class="comment"> *     - NONADJSIDE - intersects at least two non adj sides</span>
<a name="l00163"></a>00163 <span class="comment"> *     - ADJSIDES - intersects only adj sides (but may be in multiple places)</span>
<a name="l00164"></a>00164 <span class="comment"> *     class: (these catagories are shape and thinshape assumption dependent)</span>
<a name="l00165"></a>00165 <span class="comment"> *     - MAJOR - intersects at least one major side fulfilling either thin shape assumption</span>
<a name="l00166"></a>00166 <span class="comment"> *     - MINOR - intersects no majors sides</span>
<a name="l00167"></a>00167 <span class="comment"> *</span>
<a name="l00168"></a>00168 <span class="comment"> *     Note that:</span>
<a name="l00169"></a>00169 <span class="comment"> *     - The shape dependent catagories can change depending</span>
<a name="l00170"></a>00170 <span class="comment"> *       on the shape angle - that is, the number and adj of sides may change</span>
<a name="l00171"></a>00171 <span class="comment"> *       if the angle change, so a SINGLESIDE PIT under one angle may become</span>
<a name="l00172"></a>00172 <span class="comment"> *       a NON-ADJSIDE PIT.</span>
<a name="l00173"></a>00173 <span class="comment"> *     - A BREAK segments the shape into more than one piece, so a dead chunk </span>
<a name="l00174"></a>00174 <span class="comment"> *       taken out of a shape will be classified as a PIT, not a BREAK. This</span>
<a name="l00175"></a>00175 <span class="comment"> *       means:</span>
<a name="l00176"></a>00176 <span class="comment"> *       &lt;ul&gt;</span>
<a name="l00177"></a>00177 <span class="comment"> *       &lt;li&gt; A ring shape with a chunk taken clear out of it will be classified </span>
<a name="l00178"></a>00178 <span class="comment"> *            by the algorithm as a PIT, even though a human might consider</span>
<a name="l00179"></a>00179 <span class="comment"> *            that as a BREAK.</span>
<a name="l00180"></a>00180 <span class="comment"> *       &lt;li&gt; Similarly a chunk taken out of a mesh may effectively act like</span>
<a name="l00181"></a>00181 <span class="comment"> *            a TUNNEL to a human if that dead region of the mesh bumps up</span>
<a name="l00182"></a>00182 <span class="comment"> *            against another mesh. That is, there now is a hole in the overall</span>
<a name="l00183"></a>00183 <span class="comment"> *            object. Again these are only classified by the algorithm as PITs.</span>
<a name="l00184"></a>00184 <span class="comment"> *     - I only consider cases where the tear intersects the shape - </span>
<a name="l00185"></a>00185 <span class="comment"> *       totally internal pits or breaks will not be discovered (although</span>
<a name="l00186"></a>00186 <span class="comment"> *       I do use the innards for the break calculation, that calc is never done</span>
<a name="l00187"></a>00187 <span class="comment"> *       unless the tear intersects the shape (skin).</span>
<a name="l00188"></a>00188 <span class="comment"> *</span>
<a name="l00189"></a>00189 <span class="comment"> *</span>
<a name="l00190"></a>00190 <span class="comment"> * \todo </span>
<a name="l00191"></a>00191 <span class="comment"> *   - ?Do feature tracking ?</span>
<a name="l00192"></a>00192 <span class="comment"> *   - shape stuff not unittested</span>
<a name="l00193"></a>00193 <span class="comment"> *   - shape stuff not valground</span>
<a name="l00194"></a>00194 <span class="comment"> *   - See ACG notes in the code about some thoughts on if should move some things around based on</span>
<a name="l00195"></a>00195 <span class="comment"> *             storage implcations. Think about if this should also affect the FCLib interfaces</span>
<a name="l00196"></a>00196 <span class="comment"> *             (how unweildly is it to do some of this stuff?)   </span>
<a name="l00197"></a>00197 <span class="comment"> *</span>
<a name="l00198"></a>00198 <span class="comment"> * \modifications</span>
<a name="l00199"></a>00199 <span class="comment"> *   - 07/06/2005 WSD, created.</span>
<a name="l00200"></a>00200 <span class="comment"> *   - 05/25/2006 Changed to support multiple simulataneous definitions of</span>
<a name="l00201"></a>00201 <span class="comment"> *       dead elements.</span>
<a name="l00202"></a>00202 <span class="comment"> *   - 06/07/2006 WSD, add capability to specify specific meshes on command</span>
<a name="l00203"></a>00203 <span class="comment"> *     line. </span>
<a name="l00204"></a>00204 <span class="comment"> *   - 06/08/2006 WSD added damage weighted volume calcs.</span>
<a name="l00205"></a>00205 <span class="comment"> *   - 07/19/2006 WSD added flag to do a specific time step.</span>
<a name="l00206"></a>00206 <span class="comment"> *   - 08/26-27/2006 ACG added optional shape information</span>
<a name="l00207"></a>00207 <span class="comment"> *   - 09/08/2006 ACG fixed break logic - actually need the innards to</span>
<a name="l00208"></a>00208 <span class="comment"> *                determine a break. </span>
<a name="l00209"></a>00209 <span class="comment"> */</span>
<a name="l00210"></a>00210 
<a name="l00211"></a>00211 <span class="comment">// misc notes - going to combine tears  based on undisplaced geometry</span>
<a name="l00212"></a>00212 
<a name="l00213"></a>00213 <span class="preprocessor">#include &lt;string.h&gt;</span>
<a name="l00214"></a>00214 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
<a name="l00215"></a>00215 <span class="preprocessor">#include "<a class="code" href="fc_8h.html">fc.h</a>"</span>
<a name="l00216"></a>00216 <span class="preprocessor">#include "<a class="code" href="fcP_8h.html">fcP.h</a>"</span> <span class="comment">// temporary until writeBB stuff gets made public</span>
<a name="l00217"></a>00217 
<a name="l00218"></a>00218 <span class="keyword">enum</span>{ <span class="comment">//defualt paramters for shape, now current params till i</span>
<a name="l00219"></a>00219   <span class="comment">//make them aruments</span>
<a name="l00220"></a>00220   <a class="code" href="tears_8c.html#c903c6d6dff43627c254c7f1f2f3516efd34c30fdef835923240803d8b6330b5">SHAPE_ANGLE</a> = 40,
<a name="l00221"></a>00221   <a class="code" href="tears_8c.html#c903c6d6dff43627c254c7f1f2f3516ecb8d10204cdbc7dbf138c8c480bdf4c4">OPPOSINGSIDES_ANGLE</a> = 10,
<a name="l00222"></a>00222   <a class="code" href="tears_8c.html#c903c6d6dff43627c254c7f1f2f3516ea72439ec90bc8177728bc3447a4ea50c">SHARED_DIM</a> = 0,   
<a name="l00223"></a>00223 };
<a name="l00224"></a>00224 
<a name="l00225"></a>00225 <span class="keyword">enum</span>{ <span class="comment">//these have to do with the intersection with the skin and</span>
<a name="l00226"></a>00226   <span class="comment">//are not dependent on the definition of the shape sides</span>
<a name="l00227"></a>00227   <a class="code" href="tears_8c.html#88ffdc39a0c1a9f09f1ff65fb830c2f83d75915a5bc9a648f5dea2b351576ac7">BREAK</a>,<a class="code" href="tears_8c.html#88ffdc39a0c1a9f09f1ff65fb830c2f87cb10bbf443f66bd8a054f6fc7e0e867">TUNNEL</a>,<a class="code" href="tears_8c.html#88ffdc39a0c1a9f09f1ff65fb830c2f84b0a94b59b12dbb374bdd372593b5f2e">PIT</a>,
<a name="l00228"></a>00228 };
<a name="l00229"></a>00229 
<a name="l00230"></a>00230 <span class="keyword">enum</span>{ <span class="comment">// these are shape dependent</span>
<a name="l00231"></a>00231   <a class="code" href="tears_8c.html#1af138ee919beeb88a50aa27b42124b7a1c631757d2518799fde56a309d3ce9b">SINGLESIDE</a>, <a class="code" href="tears_8c.html#1af138ee919beeb88a50aa27b42124b7aa3bdeb8d317fc5f1b2a6b112ee85561">NONADJSIDES</a>, <a class="code" href="tears_8c.html#1af138ee919beeb88a50aa27b42124b72d96bfc5260f059743090cca38252366">ADJSIDES</a>,
<a name="l00232"></a>00232 };
<a name="l00233"></a>00233 
<a name="l00234"></a>00234 <span class="keyword">typedef</span> <span class="keyword">struct</span>{
<a name="l00235"></a><a class="code" href="structdeathvarinfo.html#1ebd5a95b4c6e28486008caed06d2728">00235</a>   <span class="keywordtype">char</span>* name;
<a name="l00236"></a><a class="code" href="structdeathvarinfo.html#b70b406afadea0a12dda1670415c1249">00236</a>   <span class="keywordtype">char</span>* op;
<a name="l00237"></a>00237   <span class="keywordtype">double</span> val;
<a name="l00238"></a>00238 } <a class="code" href="structdeathvarinfo.html">deathvarinfo</a>;
<a name="l00239"></a>00239 
<a name="l00240"></a><a class="code" href="structShapeIntersection.html">00240</a> <span class="keyword">typedef</span> <span class="keyword">struct</span>{
<a name="l00241"></a><a class="code" href="structShapeIntersection.html#6783d99727efb8c02e1cb3ea96992ef6">00241</a>   <span class="keywordtype">int</span> meshID;
<a name="l00242"></a><a class="code" href="structShapeIntersection.html#89571c13fae90ef1f7f2bfe90b8840ac">00242</a>   <span class="keywordtype">int</span> shapeID;
<a name="l00243"></a><a class="code" href="structShapeIntersection.html#cd58e99cfabdba80839a3eab4640d623">00243</a>   <span class="keywordtype">int</span> type; <span class="comment">//tunnel, broken, pit</span>
<a name="l00244"></a><a class="code" href="structShapeIntersection.html#9e6652e42b54aaff0e0972a9b9952e62">00244</a>   <span class="keywordtype">int</span> subtype; <span class="comment">//single, nonadj, adj</span>
<a name="l00245"></a><a class="code" href="structShapeIntersection.html#6084984af08cc599f18ccc421b63446e">00245</a>   <span class="keywordtype">int</span> major; <span class="comment">// if it involves major thinshape sides</span>
<a name="l00246"></a><a class="code" href="structShapeIntersection.html#39ef65e4e345091bbf3300c40f19410d">00246</a>   <span class="keywordtype">int</span> numIntersections;
<a name="l00247"></a><a class="code" href="structShapeIntersection.html#23f04c6f2dcf82c2f9f88796c1dcf113">00247</a>   <a class="code" href="structFC__SortedIntArray.html">FC_SortedIntArray</a>* intersectedSides;
<a name="l00248"></a>00248 } <a class="code" href="structShapeIntersection.html">ShapeIntersection</a>;
<a name="l00249"></a>00249 
<a name="l00250"></a><a class="code" href="structTear__Characterization.html">00250</a> <span class="keyword">typedef</span> <span class="keyword">struct </span>{
<a name="l00251"></a><a class="code" href="structTear__Characterization.html#55ed0d0a7177ddd23d5ae714e21273ac">00251</a>   <span class="keywordtype">int</span> numDim;
<a name="l00252"></a><a class="code" href="structTear__Characterization.html#ca099f62147f9a82c9919f327fd67aea">00252</a>   <span class="keywordtype">int</span> numCell;
<a name="l00253"></a><a class="code" href="structTear__Characterization.html#e650cc5f4698f94372ac1a91585d9208">00253</a>   <span class="keywordtype">double</span> volume;              <span class="comment">// region area/volume (can't do displaced)</span>
<a name="l00254"></a><a class="code" href="structTear__Characterization.html#3dcac12facf10a63033ab58e2bf0ad96">00254</a>   <span class="keywordtype">double</span> diameter;            <span class="comment">// region diameter (can't do displaced)</span>
<a name="l00255"></a><a class="code" href="structTear__Characterization.html#84bb66d1980070f669ea5fa967cc0377">00255</a>   <span class="keywordtype">double</span> exp_diameter;        <span class="comment">// exposed diameter</span>
<a name="l00256"></a><a class="code" href="structTear__Characterization.html#64cf4f755985a2ccd6db4a733eae4a2f">00256</a>   <span class="keywordtype">double</span> displ_exp_diameter;  <span class="comment">// displaced exposed diameter</span>
<a name="l00257"></a><a class="code" href="structTear__Characterization.html#4aaf52496fb7f20a928001c4ef11ffbe">00257</a>   <a class="code" href="group__SimpleDataObjects.html#g9687c6aad22d56c60f87659f533869c2">FC_Coords</a> lowers;           <span class="comment">// region bounding box</span>
<a name="l00258"></a><a class="code" href="structTear__Characterization.html#ed364768596f80ba2720b96718c7b3df">00258</a>   <a class="code" href="group__SimpleDataObjects.html#g9687c6aad22d56c60f87659f533869c2">FC_Coords</a> uppers;
<a name="l00259"></a><a class="code" href="structTear__Characterization.html#52a54c240fe78aa458908951ecd411cb">00259</a>   <a class="code" href="group__SimpleDataObjects.html#g9687c6aad22d56c60f87659f533869c2">FC_Coords</a> exp_lowers;       <span class="comment">// exposed bounding box</span>
<a name="l00260"></a><a class="code" href="structTear__Characterization.html#64d8ff371e05aba29882a34bbd8860d7">00260</a>   <a class="code" href="group__SimpleDataObjects.html#g9687c6aad22d56c60f87659f533869c2">FC_Coords</a> exp_uppers;
<a name="l00261"></a><a class="code" href="structTear__Characterization.html#ccd5973d5d3b4e6e092fe1afcccb662a">00261</a>   <a class="code" href="group__SimpleDataObjects.html#g9687c6aad22d56c60f87659f533869c2">FC_Coords</a> displ_exp_lowers; <span class="comment">// displaced exposed bounding box</span>
<a name="l00262"></a><a class="code" href="structTear__Characterization.html#8b5ec177f7b36b84dfeec4637f2a10f4">00262</a>   <a class="code" href="group__SimpleDataObjects.html#g9687c6aad22d56c60f87659f533869c2">FC_Coords</a> displ_exp_uppers;
<a name="l00263"></a>00263   <span class="comment">// damage stuff - this is the minimum set needed to calculate everything</span>
<a name="l00264"></a>00264   <span class="comment">// (calculation is done during print_tear_characterization())</span>
<a name="l00265"></a><a class="code" href="structTear__Characterization.html#81d5650d0b8647e489d34391c5908ea1">00265</a>   <span class="keywordtype">int</span> dead_numCell;
<a name="l00266"></a><a class="code" href="structTear__Characterization.html#d7ba9673f47f5b64e26f9069feea2164">00266</a>   <span class="keywordtype">int</span> damaged_numCell;
<a name="l00267"></a><a class="code" href="structTear__Characterization.html#ddb6062312d4738e29a7703f6266f103">00267</a>   <span class="keywordtype">double</span> dead_vol;
<a name="l00268"></a><a class="code" href="structTear__Characterization.html#83052feab2c05ff60265124170c6da42">00268</a>   <span class="keywordtype">double</span> dead_logvol;
<a name="l00269"></a><a class="code" href="structTear__Characterization.html#45526cd884223a0323c79cec9b4a55b1">00269</a>   <span class="keywordtype">double</span> damaged_vol;
<a name="l00270"></a><a class="code" href="structTear__Characterization.html#b8f85a6d397843bcab7a3abd8f8249bf">00270</a>   <span class="keywordtype">double</span> damaged_vol_x_damage;
<a name="l00271"></a><a class="code" href="structTear__Characterization.html#f9a5382459e892efdcbaac28ebae1acc">00271</a>   <span class="keywordtype">double</span> damaged_vol_x_logdamage;
<a name="l00272"></a><a class="code" href="structTear__Characterization.html#8a2dd6b40b03853643fe3f8483b5407c">00272</a>   <span class="keywordtype">double</span> damaged_log_vol_x_damage;
<a name="l00273"></a>00273 } <a class="code" href="structTear__Characterization.html">Tear_Characterization</a>;
<a name="l00274"></a>00274 
<a name="l00275"></a><a class="code" href="structTear.html">00275</a> <span class="keyword">typedef</span> <span class="keyword">struct </span>{
<a name="l00276"></a><a class="code" href="structTear.html#33a32b356f06ba65c782f33807d473d9">00276</a>   <span class="keywordtype">int</span> tearID;
<a name="l00277"></a><a class="code" href="structTear.html#b0b90312db96465819df33a2dfaa2c9c">00277</a>   <a class="code" href="structFC__Subset.html">FC_Subset</a> region;  <span class="comment">// dead element region - coords only valid of not displ'd</span>
<a name="l00278"></a><a class="code" href="structTear.html#6814266189f26d3552a273018cc2f208">00278</a>   <a class="code" href="structFC__Subset.html">FC_Subset</a> exposed; <span class="comment">// exposed surface = part of dead region shared w/ mesh</span>
<a name="l00279"></a><a class="code" href="structTear.html#5cd032f669550c5643e81303465799da">00279</a>   <span class="keywordtype">int</span> meshID;  <span class="comment">// into meshes &amp; meshnames array</span>
<a name="l00280"></a><a class="code" href="structTear.html#a1527488d38878fbb80483ad85e03c31">00280</a>   <span class="keywordtype">int</span> stepID;  <span class="comment">// this is silly?</span>
<a name="l00281"></a><a class="code" href="structTear.html#5aa69777439f6b2136b364628aa454de">00281</a>   <a class="code" href="structTear__Characterization.html">Tear_Characterization</a> data;
<a name="l00282"></a><a class="code" href="structTear.html#122b9bdf9ecaf8a27d7d626cb9039514">00282</a>   <a class="code" href="structShapeIntersection.html">ShapeIntersection</a>* shape_intersection; 
<a name="l00283"></a>00283 } <a class="code" href="structTear.html">Tear</a>;
<a name="l00284"></a>00284 
<a name="l00285"></a><a class="code" href="structSuperTear.html">00285</a> <span class="keyword">typedef</span> <span class="keyword">struct </span>{
<a name="l00286"></a><a class="code" href="structSuperTear.html#53fb4c150d687560f36482111d247e8a">00286</a>   <span class="keywordtype">int</span> tearID;
<a name="l00287"></a><a class="code" href="structSuperTear.html#ff22693a55db8a8d5a1d95dfd92c468a">00287</a>   <span class="keywordtype">int</span> numTear;
<a name="l00288"></a><a class="code" href="structSuperTear.html#e7bd683083da627b7b495e249feb29c8">00288</a>   <a class="code" href="structTear.html">Tear</a>** tears;
<a name="l00289"></a><a class="code" href="structSuperTear.html#011937f2c2e78f268ec587d0a737c0f8">00289</a>   <a class="code" href="structTear__Characterization.html">Tear_Characterization</a> data;
<a name="l00290"></a>00290 } <a class="code" href="structSuperTear.html">SuperTear</a>;
<a name="l00291"></a>00291 
<a name="l00292"></a><a class="code" href="structshape__order.html">00292</a> <span class="keyword">typedef</span> <span class="keyword">struct</span>{
<a name="l00293"></a><a class="code" href="structshape__order.html#f08a6bfc18ebb214d0ecbebe09a8469a">00293</a>   <span class="keywordtype">int</span> meshID; <span class="comment">//wish i didnt have repeat these ids, but its easiest</span>
<a name="l00294"></a><a class="code" href="structshape__order.html#78690defc21a48d6d1efcc81c397e647">00294</a>   <span class="keywordtype">int</span> shapeID;
<a name="l00295"></a><a class="code" href="structshape__order.html#af050e6c6dba45f9092e41e599a2fa7c">00295</a>   <span class="keywordtype">int</span> numSides; 
<a name="l00296"></a><a class="code" href="structshape__order.html#7ab6f7775659770ed82e687f01c6df96">00296</a>   <span class="keywordtype">int</span> *nonadjorder; <span class="comment">//has 2 members</span>
<a name="l00297"></a><a class="code" href="structshape__order.html#3452760b9de1a0c17cbabcfa8f315fa2">00297</a>   <span class="keywordtype">int</span> *opposingorder; <span class="comment">//has 2 members</span>
<a name="l00298"></a><a class="code" href="structshape__order.html#ccf8810f8f2c663f029cd520f3a44e98">00298</a>   <span class="keywordtype">int</span> *screworder;  <span class="comment">//has numSides members</span>
<a name="l00299"></a><a class="code" href="structshape__order.html#d00a47dc16b66ddb1fce79ecfab1f183">00299</a>   <span class="keywordtype">int</span> *areaorder; <span class="comment">//has numSides members</span>
<a name="l00300"></a><a class="code" href="structshape__order.html#4dd79aecf4cfd8ede3934be784c7678f">00300</a>   <span class="keywordtype">int</span> numEnds;
<a name="l00301"></a><a class="code" href="structshape__order.html#200941d921889f0ed377a6b7e2031e5f">00301</a>   <span class="keywordtype">int</span> *ends; <span class="comment">//has numEnds members</span>
<a name="l00302"></a>00302 }<a class="code" href="structshape__order.html">shape_order</a>;
<a name="l00303"></a>00303 
<a name="l00304"></a><a class="code" href="structshape__w__order.html">00304</a> <span class="keyword">typedef</span> <span class="keyword">struct</span>{
<a name="l00305"></a>00305   <span class="comment">//now that we need the innards for breaking, should i delay the building</span>
<a name="l00306"></a>00306   <span class="comment">//of the shape till later? right now keeping both the innards and all the</span>
<a name="l00307"></a>00307   <span class="comment">//sides info until after do all the shapeintersection calcs on that mesh</span>
<a name="l00308"></a><a class="code" href="structshape__w__order.html#c5ea098f4515a52897e7de914095d60e">00308</a>   <span class="keywordtype">int</span> meshID; <span class="comment">//will move ids into shape later</span>
<a name="l00309"></a><a class="code" href="structshape__w__order.html#b40072153b14eb572c93e210c22e5e9b">00309</a>   <span class="keywordtype">int</span> shapeID;
<a name="l00310"></a><a class="code" href="structshape__w__order.html#4ada12ca73e7c791c75deedac5faff52">00310</a>   <a class="code" href="structFC__Shape.html">FC_Shape</a> *shape;
<a name="l00311"></a><a class="code" href="structshape__w__order.html#2011b3f6f06f125da6411c46ee19963e">00311</a>   <a class="code" href="structFC__Subset.html">FC_Subset</a> shapeinnards; <span class="comment">//need this only for breaking</span>
<a name="l00312"></a><a class="code" href="structshape__w__order.html#06e56d16cbd39b8cbb629e350cf34579">00312</a>   <a class="code" href="structshape__order.html">shape_order</a> *order;
<a name="l00313"></a>00313 }<a class="code" href="structshape__w__order.html">shape_w_order</a>;
<a name="l00314"></a>00314 
<a name="l00315"></a><a class="code" href="tears_8c.html#cb3a46b4682216fa4a7faaa40e499a38">00315</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="gaplines_8c.html#cb3a46b4682216fa4a7faaa40e499a38">parseDeathVarSet</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv, <span class="keywordtype">int</span> *idx, <span class="keywordtype">int</span> *numvars,
<a name="l00316"></a>00316                    <a class="code" href="structdeathvarinfo.html">deathvarinfo</a>** deathvars) {
<a name="l00317"></a>00317   <span class="keywordtype">long</span> lcheck;
<a name="l00318"></a>00318   <span class="keywordtype">double</span> dcheck;
<a name="l00319"></a>00319   <span class="keywordtype">int</span> nvars;
<a name="l00320"></a>00320 
<a name="l00321"></a>00321   <span class="keywordtype">char</span>* end_ptr;
<a name="l00322"></a>00322   <span class="keywordtype">int</span> i,j;
<a name="l00323"></a>00323 
<a name="l00324"></a>00324   <span class="keywordflow">if</span> (*numvars !=0){
<a name="l00325"></a>00325     <a class="code" href="group__Library.html#gb41a63cb101314fb41df98cef504a556">fc_printfErrorMessage</a>(<span class="stringliteral">"Invalid deathvar syntax: already have death vars"</span>);
<a name="l00326"></a>00326     <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52e51d318f8c97c8b094cf9820b51e4fa83">FC_ERROR</a>;
<a name="l00327"></a>00327   }
<a name="l00328"></a>00328    
<a name="l00329"></a>00329 
<a name="l00330"></a>00330   i = *idx;
<a name="l00331"></a>00331   <span class="keywordflow">if</span> (argc &lt; *idx+1){
<a name="l00332"></a>00332     <a class="code" href="group__Library.html#gb41a63cb101314fb41df98cef504a556">fc_printfErrorMessage</a>(<span class="stringliteral">"Invalid deathvar syntax: cant get num vars"</span>);
<a name="l00333"></a>00333     <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52e51d318f8c97c8b094cf9820b51e4fa83">FC_ERROR</a>; <span class="comment">//cant get the num of vars</span>
<a name="l00334"></a>00334   }
<a name="l00335"></a>00335 
<a name="l00336"></a>00336   lcheck =  strtol(argv[i], &amp;end_ptr,10);
<a name="l00337"></a>00337   <span class="keywordflow">if</span> (*end_ptr == <span class="charliteral">'\0'</span>){ <span class="comment">//its a number</span>
<a name="l00338"></a>00338     nvars = (int)lcheck;
<a name="l00339"></a>00339   }<span class="keywordflow">else</span> { <span class="comment">//not a number</span>
<a name="l00340"></a>00340     <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52e51d318f8c97c8b094cf9820b51e4fa83">FC_ERROR</a>;
<a name="l00341"></a>00341   }
<a name="l00342"></a>00342 
<a name="l00343"></a>00343   <span class="keywordflow">if</span> (nvars == 0){
<a name="l00344"></a>00344     <a class="code" href="group__Library.html#gb41a63cb101314fb41df98cef504a556">fc_printfErrorMessage</a>(<span class="stringliteral">"Invalid deathvar syntax: no death vars"</span>);
<a name="l00345"></a>00345     <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52e51d318f8c97c8b094cf9820b51e4fa83">FC_ERROR</a>;
<a name="l00346"></a>00346   }
<a name="l00347"></a>00347 
<a name="l00348"></a>00348   <span class="keywordflow">if</span> (argc &lt; i+3*nvars+1){
<a name="l00349"></a>00349     <a class="code" href="group__Library.html#gb41a63cb101314fb41df98cef504a556">fc_printfErrorMessage</a>(<span class="stringliteral">"Invalid deathvar syntax: not enough args for num vars"</span>);
<a name="l00350"></a>00350     <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52e51d318f8c97c8b094cf9820b51e4fa83">FC_ERROR</a>;
<a name="l00351"></a>00351   }
<a name="l00352"></a>00352 
<a name="l00353"></a>00353   *deathvars = (<a class="code" href="structdeathvarinfo.html">deathvarinfo</a>*)malloc(nvars*<span class="keyword">sizeof</span>(<a class="code" href="structdeathvarinfo.html">deathvarinfo</a>));
<a name="l00354"></a>00354   <span class="keywordflow">if</span> (!deathvars){
<a name="l00355"></a>00355     <a class="code" href="group__Library.html#gb41a63cb101314fb41df98cef504a556">fc_printfErrorMessage</a>(<span class="stringliteral">"%s"</span>, <a class="code" href="group__DataTypes.html#g97ca6452d8a5b6625a2c02166dc87bb7">fc_getReturnCodeText</a>(<a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52ee4bf428a2cdead5d4e3e3391a2cdab0d">FC_MEMORY_ERROR</a>));
<a name="l00356"></a>00356     <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52ee4bf428a2cdead5d4e3e3391a2cdab0d">FC_MEMORY_ERROR</a>;
<a name="l00357"></a>00357   }
<a name="l00358"></a>00358 
<a name="l00359"></a>00359   i++;
<a name="l00360"></a>00360   <span class="keywordflow">for</span>(j = 0; j &lt; nvars; j++){
<a name="l00361"></a>00361     (*deathvars)[j].name = argv[i++];
<a name="l00362"></a>00362     (*deathvars)[j].op = argv[i++];
<a name="l00363"></a>00363     dcheck =  strtod(argv[i++], &amp;end_ptr);
<a name="l00364"></a>00364     <span class="keywordflow">if</span> (*end_ptr == <span class="charliteral">'\0'</span>){ <span class="comment">//its a number</span>
<a name="l00365"></a>00365       (*deathvars)[j].val = dcheck;
<a name="l00366"></a>00366     } <span class="keywordflow">else</span>{
<a name="l00367"></a>00367       <a class="code" href="group__Library.html#gb41a63cb101314fb41df98cef504a556">fc_printfErrorMessage</a>(<span class="stringliteral">"Invalid deathvar syntax: non-numerical value for cutoff"</span>);
<a name="l00368"></a>00368       <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52e51d318f8c97c8b094cf9820b51e4fa83">FC_ERROR</a>;
<a name="l00369"></a>00369     }
<a name="l00370"></a>00370   }
<a name="l00371"></a>00371 
<a name="l00372"></a>00372   *numvars = nvars;           
<a name="l00373"></a>00373   *idx = i-1;
<a name="l00374"></a>00374 
<a name="l00375"></a>00375   <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52e27738acee5b8b2ef61be6e9b14a26613">FC_SUCCESS</a>;
<a name="l00376"></a>00376 }
<a name="l00377"></a>00377 
<a name="l00378"></a>00378 <span class="comment">// Sort by diameter - in descending order</span>
<a name="l00379"></a>00379 <span class="comment">// FIX? sort by volume? by displaced exposed diameter?</span>
<a name="l00380"></a><a class="code" href="tears_8c.html#77e7c7c4dd750776b0f1327beaeaf3ba">00380</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="tears_8c.html#77e7c7c4dd750776b0f1327beaeaf3ba">cmpSuperTearsByLength</a>(<span class="keyword">const</span> <span class="keywordtype">void</span>* n, <span class="keyword">const</span> <span class="keywordtype">void</span>* m) {
<a name="l00381"></a>00381   <span class="keywordtype">double</span> a = ((<span class="keyword">const</span> <a class="code" href="structSuperTear.html">SuperTear</a>*)n)-&gt;data.diameter;
<a name="l00382"></a>00382   <span class="keywordtype">double</span> b = ((<span class="keyword">const</span> <a class="code" href="structSuperTear.html">SuperTear</a>*)m)-&gt;data.diameter;
<a name="l00383"></a>00383   <span class="keywordflow">if</span> (a &gt; b)
<a name="l00384"></a>00384     <span class="keywordflow">return</span> -1;
<a name="l00385"></a>00385   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (a &lt; b)
<a name="l00386"></a>00386     <span class="keywordflow">return</span> 1;
<a name="l00387"></a>00387   <span class="keywordflow">else</span>
<a name="l00388"></a>00388     <span class="keywordflow">return</span> 0;
<a name="l00389"></a>00389 }
<a name="l00390"></a>00390 
<a name="l00391"></a>00391 <span class="comment">// Expand the tears array - make sure there is enough</span>
<a name="l00392"></a>00392 <span class="comment">// Note, if the Tear struct get's any more members, may want to change from </span>
<a name="l00393"></a>00393 <span class="comment">// Tear* to Tear** so the array takes less space when emptyish.</span>
<a name="l00394"></a><a class="code" href="tears_8c.html#17cf0636177357d82ea00c22873cc704">00394</a> <span class="keyword">static</span> <a class="code" href="group__DataTypes.html#g2a816f8eddef0c2d8c2e3a0393b1f52e">FC_ReturnCode</a> <a class="code" href="tears_8c.html#17cf0636177357d82ea00c22873cc704">grow_tears</a>(<span class="keywordtype">int</span> numNewTear, <span class="keywordtype">int</span> numCurrentTear, 
<a name="l00395"></a>00395                     <span class="keywordtype">int</span>* maxNumTear, <a class="code" href="structTear.html">Tear</a>** tears) {
<a name="l00396"></a>00396   <a class="code" href="structTear.html">Tear</a>* temp_tears;
<a name="l00397"></a>00397   <span class="keywordtype">int</span> temp_maxNumTear;
<a name="l00398"></a>00398 
<a name="l00399"></a>00399   <span class="comment">// internal, so no input testing</span>
<a name="l00400"></a>00400 
<a name="l00401"></a>00401   <span class="comment">// no new tears, do nothing</span>
<a name="l00402"></a>00402   <span class="keywordflow">if</span> (numNewTear &lt; 1)
<a name="l00403"></a>00403     <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52e27738acee5b8b2ef61be6e9b14a26613">FC_SUCCESS</a>;
<a name="l00404"></a>00404 
<a name="l00405"></a>00405   <span class="comment">// if we are going, to run out of room, expand the array</span>
<a name="l00406"></a>00406   <span class="keywordflow">if</span> (numNewTear + numCurrentTear &gt; *maxNumTear) {
<a name="l00407"></a>00407     temp_maxNumTear = 2*(numNewTear + numCurrentTear);
<a name="l00408"></a>00408     temp_tears = realloc(*tears, temp_maxNumTear*<span class="keyword">sizeof</span>(<a class="code" href="structTear.html">Tear</a>));
<a name="l00409"></a>00409     <span class="keywordflow">if</span> (!temp_tears) {
<a name="l00410"></a>00410       <a class="code" href="group__Library.html#gb41a63cb101314fb41df98cef504a556">fc_printfErrorMessage</a>(<span class="stringliteral">"%s"</span>, <a class="code" href="group__DataTypes.html#g97ca6452d8a5b6625a2c02166dc87bb7">fc_getReturnCodeText</a>(<a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52ee4bf428a2cdead5d4e3e3391a2cdab0d">FC_MEMORY_ERROR</a>));
<a name="l00411"></a>00411       <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52ee4bf428a2cdead5d4e3e3391a2cdab0d">FC_MEMORY_ERROR</a>;
<a name="l00412"></a>00412     }
<a name="l00413"></a>00413     *maxNumTear = temp_maxNumTear;
<a name="l00414"></a>00414     *tears = temp_tears;
<a name="l00415"></a>00415   }
<a name="l00416"></a>00416   <span class="comment">// else, do nothing</span>
<a name="l00417"></a>00417 
<a name="l00418"></a>00418   <span class="comment">// done</span>
<a name="l00419"></a>00419   <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52e27738acee5b8b2ef61be6e9b14a26613">FC_SUCCESS</a>;
<a name="l00420"></a>00420 }
<a name="l00421"></a>00421 
<a name="l00422"></a>00422 
<a name="l00423"></a>00423 
<a name="l00424"></a><a class="code" href="tears_8c.html#33fa21d4cc3a95073e8f64ba5d8d7c36">00424</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="tears_8c.html#33fa21d4cc3a95073e8f64ba5d8d7c36">printShapeIntersection</a>(FILE* output_file, <span class="keywordtype">int</span> tearID,
<a name="l00425"></a>00425                        <a class="code" href="structShapeIntersection.html">ShapeIntersection</a> *si){
<a name="l00426"></a>00426   <span class="keywordtype">int</span> i,j;
<a name="l00427"></a>00427 
<a name="l00428"></a>00428   <span class="keywordflow">if</span> (!si) <span class="keywordflow">return</span>;
<a name="l00429"></a>00429   
<a name="l00430"></a>00430   fprintf(output_file,<span class="stringliteral">"  Subtear %4d Intersections with Shape (%d:%d) "</span>,tearID,
<a name="l00431"></a>00431        si-&gt;<a class="code" href="structShapeIntersection.html#6783d99727efb8c02e1cb3ea96992ef6">meshID</a>,si-&gt;<a class="code" href="structShapeIntersection.html#89571c13fae90ef1f7f2bfe90b8840ac">shapeID</a>);
<a name="l00432"></a>00432 
<a name="l00433"></a>00433   <span class="keywordflow">switch</span>(si-&gt;<a class="code" href="structShapeIntersection.html#cd58e99cfabdba80839a3eab4640d623">type</a>){
<a name="l00434"></a>00434   <span class="keywordflow">case</span> (<a class="code" href="tears_8c.html#88ffdc39a0c1a9f09f1ff65fb830c2f83d75915a5bc9a648f5dea2b351576ac7">BREAK</a>):
<a name="l00435"></a>00435     fprintf(output_file,<span class="stringliteral">"(BREAK,"</span>);
<a name="l00436"></a>00436     <span class="keywordflow">break</span>;
<a name="l00437"></a>00437   <span class="keywordflow">case</span> (<a class="code" href="tears_8c.html#88ffdc39a0c1a9f09f1ff65fb830c2f87cb10bbf443f66bd8a054f6fc7e0e867">TUNNEL</a>):
<a name="l00438"></a>00438     fprintf(output_file,<span class="stringliteral">"(TUNNEL,"</span>);
<a name="l00439"></a>00439     <span class="keywordflow">break</span>;
<a name="l00440"></a>00440   <span class="keywordflow">case</span> (<a class="code" href="tears_8c.html#88ffdc39a0c1a9f09f1ff65fb830c2f84b0a94b59b12dbb374bdd372593b5f2e">PIT</a>):
<a name="l00441"></a>00441     fprintf(output_file,<span class="stringliteral">"(PIT,"</span>);
<a name="l00442"></a>00442     <span class="keywordflow">break</span>;
<a name="l00443"></a>00443   <span class="keywordflow">default</span>:
<a name="l00444"></a>00444     <span class="comment">//shouldnt happen</span>
<a name="l00445"></a>00445     <span class="keywordflow">break</span>;
<a name="l00446"></a>00446   }
<a name="l00447"></a>00447   <span class="keywordflow">switch</span>(si-&gt;<a class="code" href="structShapeIntersection.html#9e6652e42b54aaff0e0972a9b9952e62">subtype</a>){
<a name="l00448"></a>00448   <span class="keywordflow">case</span> (<a class="code" href="tears_8c.html#1af138ee919beeb88a50aa27b42124b7a1c631757d2518799fde56a309d3ce9b">SINGLESIDE</a>):
<a name="l00449"></a>00449     fprintf(output_file,<span class="stringliteral">"SINGLESIDE,"</span>);
<a name="l00450"></a>00450     <span class="keywordflow">break</span>;
<a name="l00451"></a>00451   <span class="keywordflow">case</span> (<a class="code" href="tears_8c.html#1af138ee919beeb88a50aa27b42124b7aa3bdeb8d317fc5f1b2a6b112ee85561">NONADJSIDES</a>):
<a name="l00452"></a>00452     fprintf(output_file,<span class="stringliteral">"NONADJSIDES,"</span>);
<a name="l00453"></a>00453     <span class="keywordflow">break</span>;
<a name="l00454"></a>00454   <span class="keywordflow">case</span> (<a class="code" href="tears_8c.html#1af138ee919beeb88a50aa27b42124b72d96bfc5260f059743090cca38252366">ADJSIDES</a>):
<a name="l00455"></a>00455     fprintf(output_file,<span class="stringliteral">"ADJSIDES,"</span>);
<a name="l00456"></a>00456     <span class="keywordflow">break</span>;
<a name="l00457"></a>00457   }
<a name="l00458"></a>00458   <span class="keywordflow">if</span> (si-&gt;<a class="code" href="structShapeIntersection.html#6084984af08cc599f18ccc421b63446e">major</a>){
<a name="l00459"></a>00459     fprintf(output_file,<span class="stringliteral">"MAJOR)"</span>);
<a name="l00460"></a>00460   }<span class="keywordflow">else</span>{
<a name="l00461"></a>00461     fprintf(output_file,<span class="stringliteral">"MINOR)"</span>);
<a name="l00462"></a>00462   }
<a name="l00463"></a>00463 
<a name="l00464"></a>00464   fprintf(output_file,<span class="stringliteral">": "</span>);
<a name="l00465"></a>00465 
<a name="l00466"></a>00466   <span class="keywordflow">for</span> (i = 0; i &lt; si-&gt;<a class="code" href="structShapeIntersection.html#39ef65e4e345091bbf3300c40f19410d">numIntersections</a>; i++){
<a name="l00467"></a>00467     fprintf(output_file,<span class="stringliteral">"("</span>);
<a name="l00468"></a>00468     <span class="keywordflow">for</span> (j = 0; j &lt; si-&gt;<a class="code" href="structShapeIntersection.html#23f04c6f2dcf82c2f9f88796c1dcf113">intersectedSides</a>[i].<a class="code" href="structFC__SortedIntArray.html#7788cf6104dcf23fe03af42ab8a65ce9">numVal</a>; j++){
<a name="l00469"></a>00469       fprintf(output_file,<span class="stringliteral">" %d"</span>,si-&gt;<a class="code" href="structShapeIntersection.html#23f04c6f2dcf82c2f9f88796c1dcf113">intersectedSides</a>[i].<a class="code" href="structFC__SortedIntArray.html#60520a789b3d255c10053389b65bab10">vals</a>[j]);
<a name="l00470"></a>00470     }
<a name="l00471"></a>00471     fprintf(output_file,<span class="stringliteral">") "</span>);
<a name="l00472"></a>00472   }
<a name="l00473"></a>00473   fprintf(output_file, <span class="stringliteral">"\n"</span>);
<a name="l00474"></a>00474 }
<a name="l00475"></a>00475 
<a name="l00476"></a>00476 <span class="comment">// print tear data</span>
<a name="l00477"></a>00477 <span class="comment">// use "area" or "volume" where appropriate</span>
<a name="l00478"></a>00478 <span class="comment">// treat the "total" object differently</span>
<a name="l00479"></a><a class="code" href="tears_8c.html#02511beb5129ac60b8e63e5842d751e1">00479</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="tears_8c.html#02511beb5129ac60b8e63e5842d751e1">print_tear_characterization</a>(FILE* output_file,
<a name="l00480"></a>00480                          <a class="code" href="structTear__Characterization.html">Tear_Characterization</a> *data,
<a name="l00481"></a>00481                          <span class="keywordtype">int</span> isTotal, <span class="keywordtype">int</span> topoDim,
<a name="l00482"></a>00482                          <span class="keywordtype">int</span> doDispl, <span class="keywordtype">int</span> doDamageWeight,
<a name="l00483"></a>00483                          <span class="keywordtype">double</span> dead_damage) {
<a name="l00484"></a>00484   <span class="keywordtype">char</span>* volTypeStr[3] = { <span class="stringliteral">"area+volume"</span>, <span class="stringliteral">"area"</span>, <span class="stringliteral">"volume"</span> };
<a name="l00485"></a>00485   <span class="keywordtype">int</span> strID = topoDim-1;
<a name="l00486"></a>00486   <span class="keywordflow">if</span> (topoDim &lt; 0)
<a name="l00487"></a>00487     strID = 0;
<a name="l00488"></a>00488 
<a name="l00489"></a>00489   fprintf(output_file, <span class="stringliteral">"  numCell = %d\n"</span>, data-&gt;<a class="code" href="structTear__Characterization.html#ca099f62147f9a82c9919f327fd67aea">numCell</a>);
<a name="l00490"></a>00490   <span class="keywordflow">if</span> (topoDim &gt; 1) 
<a name="l00491"></a>00491     fprintf(output_file, <span class="stringliteral">"  region %s = %g\n"</span>, volTypeStr[strID],
<a name="l00492"></a>00492          data-&gt;<a class="code" href="structTear__Characterization.html#e650cc5f4698f94372ac1a91585d9208">volume</a>);
<a name="l00493"></a>00493   fprintf(output_file, <span class="stringliteral">"  region diameter  = %g\n"</span>, data-&gt;<a class="code" href="structTear__Characterization.html#3dcac12facf10a63033ab58e2bf0ad96">diameter</a>);
<a name="l00494"></a>00494   fprintf(output_file, <span class="stringliteral">"  exposed diameter = %g\n"</span>,
<a name="l00495"></a>00495        data-&gt;<a class="code" href="structTear__Characterization.html#84bb66d1980070f669ea5fa967cc0377">exp_diameter</a>);
<a name="l00496"></a>00496   <span class="keywordflow">if</span> (doDispl) {
<a name="l00497"></a>00497     fprintf(output_file, <span class="stringliteral">"  displ exposed diameter = %g\n"</span>, 
<a name="l00498"></a>00498          data-&gt;<a class="code" href="structTear__Characterization.html#64cf4f755985a2ccd6db4a733eae4a2f">displ_exp_diameter</a>);
<a name="l00499"></a>00499   }
<a name="l00500"></a>00500   <span class="comment">// don't print bb is this is a total, they have no meaning</span>
<a name="l00501"></a>00501   <span class="keywordflow">if</span> (!isTotal) {
<a name="l00502"></a>00502     fprintf(output_file, <span class="stringliteral">"  region bb  = [ %g, %g, %g ] - [ %g, %g, %g ]\n"</span>,
<a name="l00503"></a>00503          data-&gt;<a class="code" href="structTear__Characterization.html#4aaf52496fb7f20a928001c4ef11ffbe">lowers</a>[0], data-&gt;<a class="code" href="structTear__Characterization.html#4aaf52496fb7f20a928001c4ef11ffbe">lowers</a>[1],
<a name="l00504"></a>00504          data-&gt;<a class="code" href="structTear__Characterization.html#4aaf52496fb7f20a928001c4ef11ffbe">lowers</a>[2], data-&gt;<a class="code" href="structTear__Characterization.html#ed364768596f80ba2720b96718c7b3df">uppers</a>[0],
<a name="l00505"></a>00505          data-&gt;<a class="code" href="structTear__Characterization.html#ed364768596f80ba2720b96718c7b3df">uppers</a>[1], data-&gt;<a class="code" href="structTear__Characterization.html#ed364768596f80ba2720b96718c7b3df">uppers</a>[2]);
<a name="l00506"></a>00506     fprintf(output_file, <span class="stringliteral">"  exposed bb = [ %g, %g, %g ] - [ %g, %g, %g ]\n"</span>,
<a name="l00507"></a>00507          data-&gt;<a class="code" href="structTear__Characterization.html#52a54c240fe78aa458908951ecd411cb">exp_lowers</a>[0], data-&gt;<a class="code" href="structTear__Characterization.html#52a54c240fe78aa458908951ecd411cb">exp_lowers</a>[1],
<a name="l00508"></a>00508          data-&gt;<a class="code" href="structTear__Characterization.html#52a54c240fe78aa458908951ecd411cb">exp_lowers</a>[2], data-&gt;<a class="code" href="structTear__Characterization.html#64d8ff371e05aba29882a34bbd8860d7">exp_uppers</a>[0],
<a name="l00509"></a>00509          data-&gt;<a class="code" href="structTear__Characterization.html#64d8ff371e05aba29882a34bbd8860d7">exp_uppers</a>[1], data-&gt;<a class="code" href="structTear__Characterization.html#64d8ff371e05aba29882a34bbd8860d7">exp_uppers</a>[2]);
<a name="l00510"></a>00510     <span class="keywordflow">if</span> (doDispl) {
<a name="l00511"></a>00511       fprintf(output_file, <span class="stringliteral">"  displ exposed bb = [ %g, %g, %g ] - [ %g, %g, %g ]\n"</span>,
<a name="l00512"></a>00512            data-&gt;<a class="code" href="structTear__Characterization.html#ccd5973d5d3b4e6e092fe1afcccb662a">displ_exp_lowers</a>[0], 
<a name="l00513"></a>00513            data-&gt;<a class="code" href="structTear__Characterization.html#ccd5973d5d3b4e6e092fe1afcccb662a">displ_exp_lowers</a>[1],
<a name="l00514"></a>00514            data-&gt;<a class="code" href="structTear__Characterization.html#ccd5973d5d3b4e6e092fe1afcccb662a">displ_exp_lowers</a>[2], 
<a name="l00515"></a>00515            data-&gt;<a class="code" href="structTear__Characterization.html#8b5ec177f7b36b84dfeec4637f2a10f4">displ_exp_uppers</a>[0],
<a name="l00516"></a>00516            data-&gt;<a class="code" href="structTear__Characterization.html#8b5ec177f7b36b84dfeec4637f2a10f4">displ_exp_uppers</a>[1], 
<a name="l00517"></a>00517            data-&gt;<a class="code" href="structTear__Characterization.html#8b5ec177f7b36b84dfeec4637f2a10f4">displ_exp_uppers</a>[2]);
<a name="l00518"></a>00518     }
<a name="l00519"></a>00519   }
<a name="l00520"></a>00520   <span class="keywordflow">if</span> (doDamageWeight) {
<a name="l00521"></a>00521     <span class="keywordtype">double</span> dead_vol_x_damage = data-&gt;<a class="code" href="structTear__Characterization.html#ddb6062312d4738e29a7703f6266f103">dead_vol</a>*dead_damage;
<a name="l00522"></a>00522     <span class="keywordtype">double</span> dead_vol_x_logdamage = data-&gt;<a class="code" href="structTear__Characterization.html#ddb6062312d4738e29a7703f6266f103">dead_vol</a>*log10(dead_damage);
<a name="l00523"></a>00523     <span class="keywordtype">double</span> dead_log_vol_x_damage = data-&gt;<a class="code" href="structTear__Characterization.html#83052feab2c05ff60265124170c6da42">dead_logvol</a> + 
<a name="l00524"></a>00524       data-&gt;<a class="code" href="structTear__Characterization.html#81d5650d0b8647e489d34391c5908ea1">dead_numCell</a>*log10(dead_damage);
<a name="l00525"></a>00525     fprintf(output_file, <span class="stringliteral">"  --- Damage weighted %ss ---\n"</span>, volTypeStr[strID]);
<a name="l00526"></a>00526     fprintf(output_file, <span class="stringliteral">"  dead numCell = %d\n"</span>, data-&gt;<a class="code" href="structTear__Characterization.html#81d5650d0b8647e489d34391c5908ea1">dead_numCell</a>);
<a name="l00527"></a>00527     fprintf(output_file, <span class="stringliteral">"  dead %s = %g\n"</span>, volTypeStr[strID], 
<a name="l00528"></a>00528          data-&gt;<a class="code" href="structTear__Characterization.html#ddb6062312d4738e29a7703f6266f103">dead_vol</a>);
<a name="l00529"></a>00529     fprintf(output_file, <span class="stringliteral">"  dead log(%s) = %g\n"</span>, volTypeStr[strID], 
<a name="l00530"></a>00530          data-&gt;<a class="code" href="structTear__Characterization.html#83052feab2c05ff60265124170c6da42">dead_logvol</a>);
<a name="l00531"></a>00531     fprintf(output_file, <span class="stringliteral">"  dead %s x damage = %g\n"</span>,volTypeStr[strID],
<a name="l00532"></a>00532          dead_vol_x_damage);
<a name="l00533"></a>00533     fprintf(output_file, <span class="stringliteral">"  dead %s x log(damage) = %g\n"</span>,volTypeStr[strID],
<a name="l00534"></a>00534          dead_vol_x_logdamage);
<a name="l00535"></a>00535     fprintf(output_file, <span class="stringliteral">"  dead log(%s x damage) = %g\n"</span>,volTypeStr[strID],
<a name="l00536"></a>00536          dead_log_vol_x_damage);
<a name="l00537"></a>00537     fprintf(output_file, <span class="stringliteral">"  damaged numCell = %d\n"</span>, data-&gt;<a class="code" href="structTear__Characterization.html#d7ba9673f47f5b64e26f9069feea2164">damaged_numCell</a>);
<a name="l00538"></a>00538     fprintf(output_file, <span class="stringliteral">"  damaged %s = %g\n"</span>, volTypeStr[strID],
<a name="l00539"></a>00539          data-&gt;<a class="code" href="structTear__Characterization.html#45526cd884223a0323c79cec9b4a55b1">damaged_vol</a>);
<a name="l00540"></a>00540     fprintf(output_file, <span class="stringliteral">"  damaged %s x damage = %g\n"</span>, volTypeStr[strID],
<a name="l00541"></a>00541          data-&gt;<a class="code" href="structTear__Characterization.html#b8f85a6d397843bcab7a3abd8f8249bf">damaged_vol_x_damage</a>);
<a name="l00542"></a>00542     fprintf(output_file, <span class="stringliteral">"  damaged %s x log(damage) = %g\n"</span>,
<a name="l00543"></a>00543          volTypeStr[strID], data-&gt;<a class="code" href="structTear__Characterization.html#f9a5382459e892efdcbaac28ebae1acc">damaged_vol_x_logdamage</a>);
<a name="l00544"></a>00544     fprintf(output_file, <span class="stringliteral">"  damaged log(%s x damage) = %g\n"</span>,
<a name="l00545"></a>00545          volTypeStr[strID], data-&gt;<a class="code" href="structTear__Characterization.html#8a2dd6b40b03853643fe3f8483b5407c">damaged_log_vol_x_damage</a>);
<a name="l00546"></a>00546     fprintf(output_file, <span class="stringliteral">"  total %s x damage = %g\n"</span>, volTypeStr[strID],
<a name="l00547"></a>00547          dead_vol_x_damage + data-&gt;<a class="code" href="structTear__Characterization.html#b8f85a6d397843bcab7a3abd8f8249bf">damaged_vol_x_damage</a>);
<a name="l00548"></a>00548     fprintf(output_file, <span class="stringliteral">"  total %s x log(damage) = %g\n"</span>, volTypeStr[strID], 
<a name="l00549"></a>00549          dead_vol_x_logdamage + data-&gt;<a class="code" href="structTear__Characterization.html#f9a5382459e892efdcbaac28ebae1acc">damaged_vol_x_logdamage</a>);
<a name="l00550"></a>00550     fprintf(output_file, <span class="stringliteral">"  total log(%s x damage) = %g\n"</span>, volTypeStr[strID],
<a name="l00551"></a>00551          dead_log_vol_x_damage + data-&gt;<a class="code" href="structTear__Characterization.html#8a2dd6b40b03853643fe3f8483b5407c">damaged_log_vol_x_damage</a>);
<a name="l00552"></a>00552   }
<a name="l00553"></a>00553 }
<a name="l00554"></a>00554 
<a name="l00555"></a>00555 
<a name="l00556"></a><a class="code" href="tears_8c.html#e5f4cede39cce84c5ea7aaf6b9dcda91">00556</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="tears_8c.html#e5f4cede39cce84c5ea7aaf6b9dcda91">printShapeOrder</a>(FILE* output_file,<a class="code" href="structshape__order.html">shape_order</a> *order){
<a name="l00557"></a>00557   <span class="keywordflow">if</span> (!order) <span class="keywordflow">return</span>;
<a name="l00558"></a>00558 
<a name="l00559"></a>00559   fprintf(output_file,<span class="stringliteral">"Shape (meshid:shapeid) (%d:%d) (numSides %d):\n"</span>,
<a name="l00560"></a>00560        order-&gt;<a class="code" href="structshape__order.html#f08a6bfc18ebb214d0ecbebe09a8469a">meshID</a>,order-&gt;<a class="code" href="structshape__order.html#78690defc21a48d6d1efcc81c397e647">shapeID</a>,order-&gt;<a class="code" href="structshape__order.html#af050e6c6dba45f9092e41e599a2fa7c">numSides</a>); 
<a name="l00561"></a>00561   fprintf(output_file,<span class="stringliteral">"  Thin shape approx 1: "</span>);
<a name="l00562"></a>00562   <span class="keywordflow">if</span> (order-&gt;<a class="code" href="structshape__order.html#7ab6f7775659770ed82e687f01c6df96">nonadjorder</a>){
<a name="l00563"></a>00563     fprintf(output_file,<span class="stringliteral">"(%d %d)\n"</span>,
<a name="l00564"></a>00564            order-&gt;<a class="code" href="structshape__order.html#7ab6f7775659770ed82e687f01c6df96">nonadjorder</a>[0],order-&gt;<a class="code" href="structshape__order.html#7ab6f7775659770ed82e687f01c6df96">nonadjorder</a>[1]);
<a name="l00565"></a>00565   }<span class="keywordflow">else</span>{
<a name="l00566"></a>00566     fprintf(output_file,<span class="stringliteral">"NA\n"</span>);
<a name="l00567"></a>00567   }
<a name="l00568"></a>00568 
<a name="l00569"></a>00569   fprintf(output_file,<span class="stringliteral">"  Thin shape approx 2: "</span>);
<a name="l00570"></a>00570   <span class="keywordflow">if</span> (order-&gt;<a class="code" href="structshape__order.html#3452760b9de1a0c17cbabcfa8f315fa2">opposingorder</a>){
<a name="l00571"></a>00571     fprintf(output_file,<span class="stringliteral">"(%d %d)\n"</span>,
<a name="l00572"></a>00572            order-&gt;<a class="code" href="structshape__order.html#3452760b9de1a0c17cbabcfa8f315fa2">opposingorder</a>[0],order-&gt;<a class="code" href="structshape__order.html#3452760b9de1a0c17cbabcfa8f315fa2">opposingorder</a>[1]);
<a name="l00573"></a>00573   }<span class="keywordflow">else</span>{
<a name="l00574"></a>00574     fprintf(output_file,<span class="stringliteral">"NA\n"</span>);
<a name="l00575"></a>00575   }
<a name="l00576"></a>00576 
<a name="l00577"></a>00577   fprintf(output_file,<span class="stringliteral">"  Screw shape: "</span>);
<a name="l00578"></a>00578   <span class="keywordflow">if</span> (order-&gt;<a class="code" href="structshape__order.html#ccf8810f8f2c663f029cd520f3a44e98">screworder</a>){
<a name="l00579"></a>00579     <span class="keywordtype">int</span> i;
<a name="l00580"></a>00580    fprintf(output_file,<span class="stringliteral">"("</span>);
<a name="l00581"></a>00581     <span class="keywordflow">for</span> (i = 0 ; i &lt; order-&gt;<a class="code" href="structshape__order.html#af050e6c6dba45f9092e41e599a2fa7c">numSides</a>; i++){
<a name="l00582"></a>00582       fprintf(output_file,<span class="stringliteral">" %d"</span>,order-&gt;<a class="code" href="structshape__order.html#ccf8810f8f2c663f029cd520f3a44e98">screworder</a>[i]);
<a name="l00583"></a>00583     }
<a name="l00584"></a>00584     fprintf(output_file,<span class="stringliteral">")\n"</span>);
<a name="l00585"></a>00585   }<span class="keywordflow">else</span>{
<a name="l00586"></a>00586     fprintf(output_file,<span class="stringliteral">"NA\n"</span>);
<a name="l00587"></a>00587   }
<a name="l00588"></a>00588 
<a name="l00589"></a>00589   fprintf(output_file,<span class="stringliteral">"  Ends: "</span>);
<a name="l00590"></a>00590   <span class="keywordflow">if</span> (order-&gt;<a class="code" href="structshape__order.html#200941d921889f0ed377a6b7e2031e5f">ends</a>){
<a name="l00591"></a>00591     <span class="keywordtype">int</span> i;
<a name="l00592"></a>00592     fprintf(output_file,<span class="stringliteral">"("</span>);
<a name="l00593"></a>00593     <span class="keywordflow">for</span> (i = 0 ; i &lt; order-&gt;<a class="code" href="structshape__order.html#4dd79aecf4cfd8ede3934be784c7678f">numEnds</a>; i++){
<a name="l00594"></a>00594       fprintf(output_file,<span class="stringliteral">" %d"</span>,order-&gt;<a class="code" href="structshape__order.html#200941d921889f0ed377a6b7e2031e5f">ends</a>[i]);
<a name="l00595"></a>00595     }
<a name="l00596"></a>00596     fprintf(output_file,<span class="stringliteral">")\n"</span>);
<a name="l00597"></a>00597   }<span class="keywordflow">else</span>{
<a name="l00598"></a>00598     fprintf(output_file,<span class="stringliteral">"NA\n"</span>);
<a name="l00599"></a>00599   }
<a name="l00600"></a>00600 
<a name="l00601"></a>00601   <span class="keywordflow">if</span> (order-&gt;<a class="code" href="structshape__order.html#d00a47dc16b66ddb1fce79ecfab1f183">areaorder</a>){
<a name="l00602"></a>00602     <span class="keywordtype">int</span> i;
<a name="l00603"></a>00603     fprintf(output_file,<span class="stringliteral">"  Sides in area order (descending) ("</span>);
<a name="l00604"></a>00604     <span class="keywordflow">for</span> (i = 0 ; i &lt; order-&gt;<a class="code" href="structshape__order.html#af050e6c6dba45f9092e41e599a2fa7c">numSides</a>; i++){
<a name="l00605"></a>00605       fprintf(output_file,<span class="stringliteral">" %d"</span>,order-&gt;<a class="code" href="structshape__order.html#d00a47dc16b66ddb1fce79ecfab1f183">areaorder</a>[i]);
<a name="l00606"></a>00606     }
<a name="l00607"></a>00607     fprintf(output_file,<span class="stringliteral">")\n"</span>);
<a name="l00608"></a>00608   }
<a name="l00609"></a>00609 }
<a name="l00610"></a>00610 
<a name="l00611"></a>00611 
<a name="l00612"></a><a class="code" href="tears_8c.html#cf082d8718ee140cd7f361083cd54ac6">00612</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="tears_8c.html#cf082d8718ee140cd7f361083cd54ac6">freeShapeOrder</a>(<a class="code" href="structshape__order.html">shape_order</a> *order){
<a name="l00613"></a>00613   <span class="keywordflow">if</span> (!order) <span class="keywordflow">return</span>;
<a name="l00614"></a>00614 
<a name="l00615"></a>00615   order-&gt;<a class="code" href="structshape__order.html#f08a6bfc18ebb214d0ecbebe09a8469a">meshID</a> = -1;
<a name="l00616"></a>00616   order-&gt;<a class="code" href="structshape__order.html#78690defc21a48d6d1efcc81c397e647">shapeID</a> = -1;
<a name="l00617"></a>00617   <span class="keywordflow">if</span> (order-&gt;<a class="code" href="structshape__order.html#7ab6f7775659770ed82e687f01c6df96">nonadjorder</a>)  free(order-&gt;<a class="code" href="structshape__order.html#7ab6f7775659770ed82e687f01c6df96">nonadjorder</a>);
<a name="l00618"></a>00618   <span class="keywordflow">if</span> (order-&gt;<a class="code" href="structshape__order.html#ccf8810f8f2c663f029cd520f3a44e98">screworder</a>) free(order-&gt;<a class="code" href="structshape__order.html#ccf8810f8f2c663f029cd520f3a44e98">screworder</a>);
<a name="l00619"></a>00619   <span class="keywordflow">if</span> (order-&gt;<a class="code" href="structshape__order.html#3452760b9de1a0c17cbabcfa8f315fa2">opposingorder</a>) free(order-&gt;<a class="code" href="structshape__order.html#3452760b9de1a0c17cbabcfa8f315fa2">opposingorder</a>);
<a name="l00620"></a>00620   <span class="keywordflow">if</span> (order-&gt;<a class="code" href="structshape__order.html#200941d921889f0ed377a6b7e2031e5f">ends</a>) free(order-&gt;<a class="code" href="structshape__order.html#200941d921889f0ed377a6b7e2031e5f">ends</a>);
<a name="l00621"></a>00621   <span class="keywordflow">if</span> (order-&gt;<a class="code" href="structshape__order.html#d00a47dc16b66ddb1fce79ecfab1f183">areaorder</a>) free(order-&gt;<a class="code" href="structshape__order.html#d00a47dc16b66ddb1fce79ecfab1f183">areaorder</a>);
<a name="l00622"></a>00622 }
<a name="l00623"></a>00623 
<a name="l00624"></a><a class="code" href="tears_8c.html#f3ddc0f4d5816c1b1f731ede54fa1e1a">00624</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="tears_8c.html#f3ddc0f4d5816c1b1f731ede54fa1e1a">freeShapeWOrder_ShapeOnly</a>(<a class="code" href="structshape__w__order.html">shape_w_order</a> *wshape){
<a name="l00625"></a>00625   <span class="keywordflow">if</span> (!wshape) <span class="keywordflow">return</span>;
<a name="l00626"></a>00626 
<a name="l00627"></a>00627   wshape-&gt;<a class="code" href="structshape__w__order.html#c5ea098f4515a52897e7de914095d60e">meshID</a> = -1;
<a name="l00628"></a>00628   wshape-&gt;<a class="code" href="structshape__w__order.html#b40072153b14eb572c93e210c22e5e9b">shapeID</a> = -1;
<a name="l00629"></a>00629   <a class="code" href="group__Subset.html#gfdcc399692041499cc461916a9973558">fc_deleteSubset</a>(wshape-&gt;<a class="code" href="structshape__w__order.html#2011b3f6f06f125da6411c46ee19963e">shapeinnards</a>);
<a name="l00630"></a>00630   <a class="code" href="group__Shape.html#g472eb5141c2ac7917aae158bb6181eb5">fc_freeShape</a>(wshape-&gt;<a class="code" href="structshape__w__order.html#4ada12ca73e7c791c75deedac5faff52">shape</a>);
<a name="l00631"></a>00631 }
<a name="l00632"></a>00632 
<a name="l00633"></a>00633 
<a name="l00634"></a><a class="code" href="tears_8c.html#7b51135eb869b38018913acd1dbbbe04">00634</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="tears_8c.html#7b51135eb869b38018913acd1dbbbe04">freeShapeWOrder</a>(<a class="code" href="structshape__w__order.html">shape_w_order</a> *wshape){
<a name="l00635"></a>00635   <a class="code" href="tears_8c.html#cf082d8718ee140cd7f361083cd54ac6">freeShapeOrder</a>(wshape-&gt;<a class="code" href="structshape__w__order.html#06e56d16cbd39b8cbb629e350cf34579">order</a>);
<a name="l00636"></a>00636   <a class="code" href="tears_8c.html#f3ddc0f4d5816c1b1f731ede54fa1e1a">freeShapeWOrder_ShapeOnly</a>(wshape);
<a name="l00637"></a>00637 }
<a name="l00638"></a>00638 
<a name="l00639"></a>00639 
<a name="l00640"></a><a class="code" href="tears_8c.html#e9a3eb4a592189e46815d1adfb47af68">00640</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="tears_8c.html#e9a3eb4a592189e46815d1adfb47af68">createShapeWOrder</a>(<span class="keywordtype">int</span> mid, <span class="keywordtype">int</span> sid,
<a name="l00641"></a>00641                      <a class="code" href="structFC__Shape.html">FC_Shape</a>* shape, 
<a name="l00642"></a>00642                      <a class="code" href="structFC__Subset.html">FC_Subset</a> innards,
<a name="l00643"></a>00643                      <a class="code" href="structshape__w__order.html">shape_w_order</a>* wshape){
<a name="l00644"></a>00644   <span class="comment">//  FC_ReturnCode rc;</span>
<a name="l00645"></a>00645 
<a name="l00646"></a>00646   <span class="keywordtype">double</span> angle = <a class="code" href="tears_8c.html#c903c6d6dff43627c254c7f1f2f3516ecb8d10204cdbc7dbf138c8c480bdf4c4">OPPOSINGSIDES_ANGLE</a>;
<a name="l00647"></a>00647   <a class="code" href="structshape__order.html">shape_order</a> *order = (<a class="code" href="structshape__order.html">shape_order</a>*)malloc(<span class="keyword">sizeof</span>(<a class="code" href="structshape__order.html">shape_order</a>));
<a name="l00648"></a>00648   <span class="keywordflow">if</span> (!order){
<a name="l00649"></a>00649     <a class="code" href="group__ErrorHandling.html#g4a09c0024ecd45d5d63c8b9ec333a717">fc_exitIfError</a>(<a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52ee4bf428a2cdead5d4e3e3391a2cdab0d">FC_MEMORY_ERROR</a>);
<a name="l00650"></a>00650   }
<a name="l00651"></a>00651   
<a name="l00652"></a>00652   wshape-&gt;<a class="code" href="structshape__w__order.html#c5ea098f4515a52897e7de914095d60e">meshID</a> = mid;
<a name="l00653"></a>00653   wshape-&gt;<a class="code" href="structshape__w__order.html#b40072153b14eb572c93e210c22e5e9b">shapeID</a> = sid;
<a name="l00654"></a>00654   wshape-&gt;<a class="code" href="structshape__w__order.html#4ada12ca73e7c791c75deedac5faff52">shape</a> = shape;
<a name="l00655"></a>00655   wshape-&gt;<a class="code" href="structshape__w__order.html#06e56d16cbd39b8cbb629e350cf34579">order</a> = order;
<a name="l00656"></a>00656   wshape-&gt;<a class="code" href="structshape__w__order.html#2011b3f6f06f125da6411c46ee19963e">shapeinnards</a> = innards;
<a name="l00657"></a>00657   wshape-&gt;<a class="code" href="structshape__w__order.html#06e56d16cbd39b8cbb629e350cf34579">order</a>-&gt;<a class="code" href="structshape__order.html#f08a6bfc18ebb214d0ecbebe09a8469a">meshID</a> = wshape-&gt;<a class="code" href="structshape__w__order.html#c5ea098f4515a52897e7de914095d60e">meshID</a>;
<a name="l00658"></a>00658   wshape-&gt;<a class="code" href="structshape__w__order.html#06e56d16cbd39b8cbb629e350cf34579">order</a>-&gt;<a class="code" href="structshape__order.html#78690defc21a48d6d1efcc81c397e647">shapeID</a> = wshape-&gt;<a class="code" href="structshape__w__order.html#b40072153b14eb572c93e210c22e5e9b">shapeID</a>;
<a name="l00659"></a>00659   wshape-&gt;<a class="code" href="structshape__w__order.html#06e56d16cbd39b8cbb629e350cf34579">order</a>-&gt;<a class="code" href="structshape__order.html#af050e6c6dba45f9092e41e599a2fa7c">numSides</a> = wshape-&gt;<a class="code" href="structshape__w__order.html#4ada12ca73e7c791c75deedac5faff52">shape</a>-&gt;<a class="code" href="structFC__Shape.html#0bf1533a6d673f68e4a2b2544f3920d2">numSides</a>;
<a name="l00660"></a>00660 
<a name="l00661"></a>00661   <span class="comment">//we dont care if these orders fail</span>
<a name="l00662"></a>00662   <a class="code" href="group__Shape.html#gd422d8982472fccaa464695acdcaf0f9">fc_createLargeAndNonAdjacentSidesOrder</a>(shape,&amp;(wshape-&gt;<a class="code" href="structshape__w__order.html#06e56d16cbd39b8cbb629e350cf34579">order</a>-&gt;<a class="code" href="structshape__order.html#7ab6f7775659770ed82e687f01c6df96">nonadjorder</a>));
<a name="l00663"></a>00663   <a class="code" href="group__Shape.html#ge8de17804d3bf460696ee739bfe79bd0">fc_createLargeAndOpposingSidesOrder</a>(shape,angle,
<a name="l00664"></a>00664                           &amp;(wshape-&gt;<a class="code" href="structshape__w__order.html#06e56d16cbd39b8cbb629e350cf34579">order</a>-&gt;<a class="code" href="structshape__order.html#3452760b9de1a0c17cbabcfa8f315fa2">opposingorder</a>));
<a name="l00665"></a>00665   <a class="code" href="group__Shape.html#g4dbbcff33504cc04efd1c6be96b69c58">fc_createScrewShapeOrder</a>(shape,&amp;(wshape-&gt;<a class="code" href="structshape__w__order.html#06e56d16cbd39b8cbb629e350cf34579">order</a>-&gt;<a class="code" href="structshape__order.html#ccf8810f8f2c663f029cd520f3a44e98">screworder</a>));
<a name="l00666"></a>00666   <a class="code" href="group__Shape.html#gd862089595d35c47e3a5e3b8b0e63c35">fc_getShapeEnds</a>(shape,&amp;(wshape-&gt;<a class="code" href="structshape__w__order.html#06e56d16cbd39b8cbb629e350cf34579">order</a>-&gt;<a class="code" href="structshape__order.html#4dd79aecf4cfd8ede3934be784c7678f">numEnds</a>),
<a name="l00667"></a>00667             &amp;(wshape-&gt;<a class="code" href="structshape__w__order.html#06e56d16cbd39b8cbb629e350cf34579">order</a>-&gt;<a class="code" href="structshape__order.html#200941d921889f0ed377a6b7e2031e5f">ends</a>));
<a name="l00668"></a>00668   <a class="code" href="group__Shape.html#gfeed0b3f13b8f02d55da46cb19cbf187">fc_createDescendingAreaOrder</a>(shape,&amp;(wshape-&gt;<a class="code" href="structshape__w__order.html#06e56d16cbd39b8cbb629e350cf34579">order</a>-&gt;<a class="code" href="structshape__order.html#d00a47dc16b66ddb1fce79ecfab1f183">areaorder</a>));
<a name="l00669"></a>00669 }
<a name="l00670"></a>00670 
<a name="l00671"></a><a class="code" href="tears_8c.html#0c2892755ed9736d0189b21849646bd1">00671</a> <span class="keyword">static</span> <a class="code" href="group__DataTypes.html#g2a816f8eddef0c2d8c2e3a0393b1f52e">FC_ReturnCode</a> <a class="code" href="tears_8c.html#0c2892755ed9736d0189b21849646bd1">freeShapeIntersection</a>(<a class="code" href="structShapeIntersection.html">ShapeIntersection</a> *si){
<a name="l00672"></a>00672   <span class="keywordtype">int</span> i;
<a name="l00673"></a>00673 
<a name="l00674"></a>00674   <span class="keywordflow">if</span> (!si) <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52e27738acee5b8b2ef61be6e9b14a26613">FC_SUCCESS</a>;
<a name="l00675"></a>00675 
<a name="l00676"></a>00676   <span class="keywordflow">for</span> (i = 0; i &lt; si-&gt;<a class="code" href="structShapeIntersection.html#39ef65e4e345091bbf3300c40f19410d">numIntersections</a>; i++){
<a name="l00677"></a>00677     <a class="code" href="group__SimpleDataObjects.html#ga6ecd909b91f581633b4accbc88642b2">fc_freeSortedIntArray</a>(&amp;(si-&gt;<a class="code" href="structShapeIntersection.html#23f04c6f2dcf82c2f9f88796c1dcf113">intersectedSides</a>[i]));
<a name="l00678"></a>00678   }
<a name="l00679"></a>00679 
<a name="l00680"></a>00680   si-&gt;<a class="code" href="structShapeIntersection.html#39ef65e4e345091bbf3300c40f19410d">numIntersections</a> = 0;
<a name="l00681"></a>00681   free(si-&gt;<a class="code" href="structShapeIntersection.html#23f04c6f2dcf82c2f9f88796c1dcf113">intersectedSides</a>);
<a name="l00682"></a>00682 
<a name="l00683"></a>00683   <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52e27738acee5b8b2ef61be6e9b14a26613">FC_SUCCESS</a>;
<a name="l00684"></a>00684 }
<a name="l00685"></a>00685 
<a name="l00686"></a><a class="code" href="tears_8c.html#6aa4dad5ac93c6d9eb24fe34808f0b29">00686</a> <span class="keyword">static</span> <a class="code" href="group__DataTypes.html#g2a816f8eddef0c2d8c2e3a0393b1f52e">FC_ReturnCode</a> <a class="code" href="tears_8c.html#6aa4dad5ac93c6d9eb24fe34808f0b29">calcShapeIntersection</a>(<span class="keywordtype">int</span> numShapes,
<a name="l00687"></a>00687                             <a class="code" href="structshape__w__order.html">shape_w_order</a> *wshapes,
<a name="l00688"></a>00688                             <span class="keywordtype">int</span> shareddim,
<a name="l00689"></a>00689                             <a class="code" href="structTear.html">Tear</a> *tear){
<a name="l00690"></a>00690   <a class="code" href="group__DataTypes.html#g2a816f8eddef0c2d8c2e3a0393b1f52e">FC_ReturnCode</a> rc;
<a name="l00691"></a>00691   <a class="code" href="structShapeIntersection.html">ShapeIntersection</a> *si = NULL;
<a name="l00692"></a>00692   <span class="keywordtype">int</span> i,j,m,n;
<a name="l00693"></a>00693 
<a name="l00694"></a>00694 
<a name="l00695"></a>00695   <span class="comment">//each segment can intersect only 1 shape</span>
<a name="l00696"></a>00696   <span class="comment">//if its entirely interior to a shape, then</span>
<a name="l00697"></a>00697   <span class="comment">//it will intersect 0 shapes</span>
<a name="l00698"></a>00698 
<a name="l00699"></a>00699   <span class="keywordflow">for</span> (i = 0; i &lt; numShapes; i++){
<a name="l00700"></a>00700     <a class="code" href="structFC__Subset.html">FC_Subset</a> decayedSkin, *livesegments;
<a name="l00701"></a>00701     <span class="keywordtype">int</span> numlive = 0;
<a name="l00702"></a>00702     <a class="code" href="structFC__Subset.html">FC_Subset</a> *decayedSidesSegments;
<a name="l00703"></a>00703     <span class="keywordtype">int</span> numDecayedSidesSegments;
<a name="l00704"></a>00704     <a class="code" href="structFC__Shape.html">FC_Shape</a> *currshape = wshapes[i].<a class="code" href="structshape__w__order.html#4ada12ca73e7c791c75deedac5faff52">shape</a>;
<a name="l00705"></a>00705     <a class="code" href="structshape__order.html">shape_order</a> *order = wshapes[i].<a class="code" href="structshape__w__order.html#06e56d16cbd39b8cbb629e350cf34579">order</a>;
<a name="l00706"></a>00706     <a class="code" href="structFC__Subset.html">FC_Subset</a> currinnards = wshapes[i].<a class="code" href="structshape__w__order.html#2011b3f6f06f125da6411c46ee19963e">shapeinnards</a>;
<a name="l00707"></a>00707 
<a name="l00708"></a>00708     <span class="keywordtype">int</span> numMem;
<a name="l00709"></a>00709     <span class="keywordtype">int</span> <a class="code" href="screwBreaks_8c.html#d97959937abd86c20a00aaed795f6777">broken</a> = 0;
<a name="l00710"></a>00710 
<a name="l00711"></a>00711     rc = <a class="code" href="group__ElemDeath.html#g432a80c6a448b2e0aea75bd009a3b529">fc_getDecayedShapeSkin</a>(tear-&gt;<a class="code" href="structTear.html#b0b90312db96465819df33a2dfaa2c9c">region</a>,currshape,
<a name="l00712"></a>00712                     &amp;decayedSkin);
<a name="l00713"></a>00713     <span class="keywordflow">if</span> (rc != <a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52e27738acee5b8b2ef61be6e9b14a26613">FC_SUCCESS</a>){
<a name="l00714"></a>00714       <a class="code" href="group__Library.html#gb41a63cb101314fb41df98cef504a556">fc_printfErrorMessage</a>(<span class="stringliteral">"Cant get decayedSkin. skipping"</span>);
<a name="l00715"></a>00715       <span class="keywordflow">continue</span>;
<a name="l00716"></a>00716     }
<a name="l00717"></a>00717 
<a name="l00718"></a>00718     <span class="keywordflow">if</span> (<a class="code" href="group__Handles.html#gf1de8e9eed3c2f3c7ffcaa6527fe0adf">FC_HANDLE_EQUIV</a>(decayedSkin,<a class="code" href="group__Handles.html#g05b02ab7a13c2ad72dd9a0862fc11356">FC_NULL_SUBSET</a>)){
<a name="l00719"></a>00719       <span class="comment">//i hate having to check this</span>
<a name="l00720"></a>00720       printf(<span class="stringliteral">"\tNULL SUBSET continuing\n"</span>);
<a name="l00721"></a>00721       <span class="keywordflow">continue</span>;
<a name="l00722"></a>00722     }
<a name="l00723"></a>00723 
<a name="l00724"></a>00724     rc = <a class="code" href="group__Subset.html#g8b932d306fb8f41ef49677f803fd9fd1">fc_getSubsetNumMember</a>(decayedSkin,&amp;numMem);
<a name="l00725"></a>00725     <a class="code" href="error_8h.html#42c09317184affa18e70826cb35f3f04">fc_exitIfErrorPrintf</a>(rc, <span class="stringliteral">"can't get subset members"</span>);
<a name="l00726"></a>00726     <span class="keywordflow">if</span> (!numMem){
<a name="l00727"></a>00727       <span class="comment">//nothing in this shape</span>
<a name="l00728"></a>00728       <a class="code" href="group__Subset.html#gfdcc399692041499cc461916a9973558">fc_deleteSubset</a>(decayedSkin);
<a name="l00729"></a>00729       <span class="keywordflow">continue</span>;
<a name="l00730"></a>00730     }
<a name="l00731"></a>00731 
<a name="l00732"></a>00732 
<a name="l00733"></a>00733     <span class="comment">//segment should work if its an empty set</span>
<a name="l00734"></a>00734     <span class="comment">//segment the dead skin</span>
<a name="l00735"></a>00735     <span class="comment">//not using the shared dim becuase that was just for the shape</span>
<a name="l00736"></a>00736     rc = <a class="code" href="group__TopologyRelations.html#g7a5c5ff506dab80fe40ae60a76b3d886">fc_segment</a>(decayedSkin,0, &amp;numDecayedSidesSegments,
<a name="l00737"></a>00737               &amp;decayedSidesSegments);
<a name="l00738"></a>00738     <a class="code" href="group__Subset.html#gfdcc399692041499cc461916a9973558">fc_deleteSubset</a>(decayedSkin);
<a name="l00739"></a>00739     <span class="keywordflow">if</span> (rc!= <a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52e27738acee5b8b2ef61be6e9b14a26613">FC_SUCCESS</a>){
<a name="l00740"></a>00740       <a class="code" href="group__Library.html#gb41a63cb101314fb41df98cef504a556">fc_printfErrorMessage</a>(<span class="stringliteral">"Can't get Decayed sides segments. Skipping"</span>);
<a name="l00741"></a>00741       <span class="keywordflow">continue</span>;
<a name="l00742"></a>00742     }
<a name="l00743"></a>00743 
<a name="l00744"></a>00744     <span class="keywordflow">if</span> (!decayedSidesSegments){
<a name="l00745"></a>00745       <span class="comment">//tear doesnt intersect this shape</span>
<a name="l00746"></a>00746       <span class="keywordflow">continue</span>;
<a name="l00747"></a>00747     }
<a name="l00748"></a>00748 
<a name="l00749"></a>00749     <span class="comment">//have to try to segment the whole innards to see if there is a break</span>
<a name="l00750"></a>00750     rc = <a class="code" href="group__ElemDeath.html#g0371b6ec91633a487a0aa87fab4c465d">fc_subsetSegmentsSubset</a>(tear-&gt;<a class="code" href="structTear.html#b0b90312db96465819df33a2dfaa2c9c">region</a>,currinnards,shareddim,
<a name="l00751"></a>00751                      <span class="stringliteral">"live"</span>,&amp;numlive,&amp;livesegments);
<a name="l00752"></a>00752     <span class="keywordflow">if</span> (rc != <a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52e27738acee5b8b2ef61be6e9b14a26613">FC_SUCCESS</a>){
<a name="l00753"></a>00753       <a class="code" href="group__Library.html#gb41a63cb101314fb41df98cef504a556">fc_printfErrorMessage</a>(<span class="stringliteral">"Can't get segmentation on live shape"</span>);
<a name="l00754"></a>00754       <span class="comment">//just keep going</span>
<a name="l00755"></a>00755     }<span class="keywordflow">else</span>{
<a name="l00756"></a>00756       <span class="keywordflow">if</span> (numlive &gt; 1){
<a name="l00757"></a>00757      <span class="comment">//   printf("found a break - into %d segments of sizes: ",numlive);</span>
<a name="l00758"></a>00758      <span class="keywordflow">for</span> (j = 0; j &lt; numlive; j++){
<a name="l00759"></a>00759        <span class="comment">//   int num = -1;</span>
<a name="l00760"></a>00760        <span class="comment">//   rc = fc_getSubsetNumMember(livesegments[j],&amp;num);</span>
<a name="l00761"></a>00761        <span class="comment">//   printf("%d ",num);</span>
<a name="l00762"></a>00762        <a class="code" href="group__Subset.html#gfdcc399692041499cc461916a9973558">fc_deleteSubset</a>(livesegments[j]);
<a name="l00763"></a>00763      }
<a name="l00764"></a>00764      <span class="comment">//   printf("\n");</span>
<a name="l00765"></a>00765      free(livesegments);
<a name="l00766"></a>00766      broken = 1;
<a name="l00767"></a>00767       }
<a name="l00768"></a>00768     }
<a name="l00769"></a>00769 
<a name="l00770"></a>00770 
<a name="l00771"></a>00771     <span class="comment">//tear does intersect this shape, set up for the intersection</span>
<a name="l00772"></a>00772     si = (<a class="code" href="structShapeIntersection.html">ShapeIntersection</a>*)malloc(<span class="keyword">sizeof</span>(<a class="code" href="structShapeIntersection.html">ShapeIntersection</a>));
<a name="l00773"></a>00773     <span class="keywordflow">if</span> (!si){
<a name="l00774"></a>00774       <a class="code" href="group__ErrorHandling.html#g4a09c0024ecd45d5d63c8b9ec333a717">fc_exitIfError</a>(<a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52ee4bf428a2cdead5d4e3e3391a2cdab0d">FC_MEMORY_ERROR</a>);
<a name="l00775"></a>00775     }
<a name="l00776"></a>00776 
<a name="l00777"></a>00777     <span class="keywordflow">if</span> (broken){
<a name="l00778"></a>00778       si-&gt;<a class="code" href="structShapeIntersection.html#cd58e99cfabdba80839a3eab4640d623">type</a> = <a class="code" href="tears_8c.html#88ffdc39a0c1a9f09f1ff65fb830c2f83d75915a5bc9a648f5dea2b351576ac7">BREAK</a>;
<a name="l00779"></a>00779     }<span class="keywordflow">else</span>{
<a name="l00780"></a>00780       <span class="keywordflow">if</span> (numDecayedSidesSegments &gt; 1){
<a name="l00781"></a>00781      si-&gt;<a class="code" href="structShapeIntersection.html#cd58e99cfabdba80839a3eab4640d623">type</a> = <a class="code" href="tears_8c.html#88ffdc39a0c1a9f09f1ff65fb830c2f87cb10bbf443f66bd8a054f6fc7e0e867">TUNNEL</a>;
<a name="l00782"></a>00782       }<span class="keywordflow">else</span> {
<a name="l00783"></a>00783      si-&gt;<a class="code" href="structShapeIntersection.html#cd58e99cfabdba80839a3eab4640d623">type</a> = <a class="code" href="tears_8c.html#88ffdc39a0c1a9f09f1ff65fb830c2f84b0a94b59b12dbb374bdd372593b5f2e">PIT</a>;
<a name="l00784"></a>00784       }
<a name="l00785"></a>00785     }
<a name="l00786"></a>00786 
<a name="l00787"></a>00787     si-&gt;<a class="code" href="structShapeIntersection.html#89571c13fae90ef1f7f2bfe90b8840ac">shapeID</a> = wshapes[i].<a class="code" href="structshape__w__order.html#b40072153b14eb572c93e210c22e5e9b">shapeID</a>;
<a name="l00788"></a>00788     si-&gt;<a class="code" href="structShapeIntersection.html#6783d99727efb8c02e1cb3ea96992ef6">meshID</a> = wshapes[i].<a class="code" href="structshape__w__order.html#c5ea098f4515a52897e7de914095d60e">meshID</a>;
<a name="l00789"></a>00789     si-&gt;<a class="code" href="structShapeIntersection.html#39ef65e4e345091bbf3300c40f19410d">numIntersections</a> = numDecayedSidesSegments;
<a name="l00790"></a>00790     si-&gt;<a class="code" href="structShapeIntersection.html#23f04c6f2dcf82c2f9f88796c1dcf113">intersectedSides</a> = (<a class="code" href="structFC__SortedIntArray.html">FC_SortedIntArray</a>*)malloc((si-&gt;<a class="code" href="structShapeIntersection.html#39ef65e4e345091bbf3300c40f19410d">numIntersections</a>)*
<a name="l00791"></a>00791                                     <span class="keyword">sizeof</span>(<a class="code" href="structFC__SortedIntArray.html">FC_SortedIntArray</a>));
<a name="l00792"></a>00792     <span class="keywordflow">if</span> (!(si-&gt;<a class="code" href="structShapeIntersection.html#23f04c6f2dcf82c2f9f88796c1dcf113">intersectedSides</a>)){
<a name="l00793"></a>00793       <a class="code" href="group__ErrorHandling.html#g4a09c0024ecd45d5d63c8b9ec333a717">fc_exitIfError</a>(<a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52ee4bf428a2cdead5d4e3e3391a2cdab0d">FC_MEMORY_ERROR</a>);
<a name="l00794"></a>00794     }
<a name="l00795"></a>00795 
<a name="l00796"></a>00796     <span class="keywordflow">for</span> (m = 0; m &lt; si-&gt;<a class="code" href="structShapeIntersection.html#39ef65e4e345091bbf3300c40f19410d">numIntersections</a>; m++){
<a name="l00797"></a>00797       <span class="comment">//each intersection of this tear with the skin</span>
<a name="l00798"></a>00798       <span class="keywordtype">int</span> sidedecay;
<a name="l00799"></a>00799 
<a name="l00800"></a>00800       <a class="code" href="group__SimpleDataObjects.html#g06e00500dd0122a9ad53fdeb52649de7">fc_initSortedIntArray</a>(&amp;(si-&gt;<a class="code" href="structShapeIntersection.html#23f04c6f2dcf82c2f9f88796c1dcf113">intersectedSides</a>[m]));
<a name="l00801"></a>00801       <span class="keywordflow">for</span> (n = 0; n &lt; currshape-&gt;<a class="code" href="structFC__Shape.html#0bf1533a6d673f68e4a2b2544f3920d2">numSides</a>; n++){
<a name="l00802"></a>00802      rc = <a class="code" href="group__Subset.html#ge8dd6b44e551c0b7d28816784358919a">fc_doSubsetsIntersect</a>(decayedSidesSegments[m],
<a name="l00803"></a>00803                        currshape-&gt;<a class="code" href="structFC__Shape.html#287a16f0313b8ba291887b7fc22a03df">faces</a>[n],
<a name="l00804"></a>00804                        &amp;sidedecay);
<a name="l00805"></a>00805      <a class="code" href="error_8h.html#42c09317184affa18e70826cb35f3f04">fc_exitIfErrorPrintf</a>(rc,<span class="stringliteral">"can't get subset intersection"</span>);
<a name="l00806"></a>00806      
<a name="l00807"></a>00807      <span class="keywordflow">if</span> (sidedecay){
<a name="l00808"></a>00808        <a class="code" href="group__SimpleDataObjects.html#g64768f52c122c1cd322cbebac85979f2">fc_addIntToSortedIntArray</a>(&amp;(si-&gt;<a class="code" href="structShapeIntersection.html#23f04c6f2dcf82c2f9f88796c1dcf113">intersectedSides</a>[m]),n);
<a name="l00809"></a>00809      }
<a name="l00810"></a>00810       }
<a name="l00811"></a>00811       
<a name="l00812"></a>00812       <span class="comment">//clean up</span>
<a name="l00813"></a>00813       <a class="code" href="group__Subset.html#gfdcc399692041499cc461916a9973558">fc_deleteSubset</a>(decayedSidesSegments[m]);
<a name="l00814"></a>00814     } <span class="comment">//numintersections</span>
<a name="l00815"></a>00815 
<a name="l00816"></a>00816     <span class="comment">//now use intersections to determine major, subtype</span>
<a name="l00817"></a>00817     si-&gt;<a class="code" href="structShapeIntersection.html#6084984af08cc599f18ccc421b63446e">major</a> = 0;
<a name="l00818"></a>00818     <span class="keywordflow">for</span> (m = 0; m &lt; si-&gt;<a class="code" href="structShapeIntersection.html#39ef65e4e345091bbf3300c40f19410d">numIntersections</a>; m++){
<a name="l00819"></a>00819       <span class="keywordflow">if</span> (order-&gt;<a class="code" href="structshape__order.html#7ab6f7775659770ed82e687f01c6df96">nonadjorder</a>){
<a name="l00820"></a>00820      if (<a class="code" href="group__SimpleDataObjects.html#g767cf2f73bd364f145e7d0c53573694e">fc_isIntInSortedIntArray</a>(&amp;(si-&gt;<a class="code" href="structShapeIntersection.html#23f04c6f2dcf82c2f9f88796c1dcf113">intersectedSides</a>[m]),
<a name="l00821"></a>00821                          order-&gt;<a class="code" href="structshape__order.html#7ab6f7775659770ed82e687f01c6df96">nonadjorder</a>[0]) ||
<a name="l00822"></a>00822          <a class="code" href="group__SimpleDataObjects.html#g767cf2f73bd364f145e7d0c53573694e">fc_isIntInSortedIntArray</a>(&amp;(si-&gt;<a class="code" href="structShapeIntersection.html#23f04c6f2dcf82c2f9f88796c1dcf113">intersectedSides</a>[m]),
<a name="l00823"></a>00823                          order-&gt;<a class="code" href="structshape__order.html#7ab6f7775659770ed82e687f01c6df96">nonadjorder</a>[1])){
<a name="l00824"></a>00824        si-&gt;<a class="code" href="structShapeIntersection.html#6084984af08cc599f18ccc421b63446e">major</a> = 1;
<a name="l00825"></a>00825        <span class="keywordflow">break</span>;
<a name="l00826"></a>00826      }
<a name="l00827"></a>00827       }
<a name="l00828"></a>00828       <span class="keywordflow">if</span> (order-&gt;opposingorder){
<a name="l00829"></a>00829      if (<a class="code" href="group__SimpleDataObjects.html#g767cf2f73bd364f145e7d0c53573694e">fc_isIntInSortedIntArray</a>(&amp;(si-&gt;<a class="code" href="structShapeIntersection.html#23f04c6f2dcf82c2f9f88796c1dcf113">intersectedSides</a>[m]),
<a name="l00830"></a>00830                          order-&gt;opposingorder[0]) ||
<a name="l00831"></a>00831          <a class="code" href="group__SimpleDataObjects.html#g767cf2f73bd364f145e7d0c53573694e">fc_isIntInSortedIntArray</a>(&amp;(si-&gt;<a class="code" href="structShapeIntersection.html#23f04c6f2dcf82c2f9f88796c1dcf113">intersectedSides</a>[m]),
<a name="l00832"></a>00832                          order-&gt;opposingorder[1])){
<a name="l00833"></a>00833        si-&gt;<a class="code" href="structShapeIntersection.html#6084984af08cc599f18ccc421b63446e">major</a> = 1;
<a name="l00834"></a>00834        <span class="keywordflow">break</span>;
<a name="l00835"></a>00835      }
<a name="l00836"></a>00836       }
<a name="l00837"></a>00837     }
<a name="l00838"></a>00838 
<a name="l00839"></a>00839     <span class="comment">//subtypes</span>
<a name="l00840"></a>00840     si-&gt;subtype = <a class="code" href="tears_8c.html#1af138ee919beeb88a50aa27b42124b7a1c631757d2518799fde56a309d3ce9b">SINGLESIDE</a>; <span class="comment">//this will be updated below</span>
<a name="l00841"></a>00841     {
<a name="l00842"></a>00842       <a class="code" href="structFC__SortedIntArray.html">FC_SortedIntArray</a> uniqueintersections;
<a name="l00843"></a>00843       <a class="code" href="group__SimpleDataObjects.html#g06e00500dd0122a9ad53fdeb52649de7">fc_initSortedIntArray</a>(&amp;uniqueintersections);
<a name="l00844"></a>00844       <span class="keywordflow">for</span> (m = 0; m &lt; si-&gt;numIntersections; m++){
<a name="l00845"></a>00845      <span class="keywordflow">for</span> (n = 0; n &lt; si-&gt;intersectedSides[m].numVal; n++){
<a name="l00846"></a>00846        <a class="code" href="group__SimpleDataObjects.html#g64768f52c122c1cd322cbebac85979f2">fc_addIntToSortedIntArray</a>(&amp;uniqueintersections,
<a name="l00847"></a>00847                         si-&gt;intersectedSides[m].<a class="code" href="structFC__SortedIntArray.html#60520a789b3d255c10053389b65bab10">vals</a>[n]);
<a name="l00848"></a>00848      }
<a name="l00849"></a>00849       }
<a name="l00850"></a>00850       
<a name="l00851"></a>00851       <span class="keywordflow">switch</span> (uniqueintersections.<a class="code" href="structFC__SortedIntArray.html#7788cf6104dcf23fe03af42ab8a65ce9">numVal</a>){
<a name="l00852"></a>00852       <span class="keywordflow">case</span> 0:
<a name="l00853"></a>00853       <span class="keywordflow">case</span> -1:
<a name="l00854"></a>00854      <a class="code" href="error_8h.html#42c09317184affa18e70826cb35f3f04">fc_exitIfErrorPrintf</a>(<a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52e51d318f8c97c8b094cf9820b51e4fa83">FC_ERROR</a>,<span class="stringliteral">"Developer error: must be at least one intersection"</span>);
<a name="l00855"></a>00855      <span class="keywordflow">break</span>;
<a name="l00856"></a>00856       <span class="keywordflow">case</span> 1:
<a name="l00857"></a>00857      si-&gt;subtype = <a class="code" href="tears_8c.html#1af138ee919beeb88a50aa27b42124b7a1c631757d2518799fde56a309d3ce9b">SINGLESIDE</a>;
<a name="l00858"></a>00858      <span class="keywordflow">break</span>;
<a name="l00859"></a>00859       <span class="keywordflow">default</span>:
<a name="l00860"></a>00860      si-&gt;subtype = <a class="code" href="tears_8c.html#1af138ee919beeb88a50aa27b42124b72d96bfc5260f059743090cca38252366">ADJSIDES</a>;
<a name="l00861"></a>00861      <span class="keywordflow">for</span> (m = 0; m &lt; uniqueintersections.<a class="code" href="structFC__SortedIntArray.html#7788cf6104dcf23fe03af42ab8a65ce9">numVal</a>; m++){
<a name="l00862"></a>00862        <span class="keywordflow">for</span> (n = m+1; n &lt; uniqueintersections.<a class="code" href="structFC__SortedIntArray.html#7788cf6104dcf23fe03af42ab8a65ce9">numVal</a>; n++){
<a name="l00863"></a>00863          <span class="keywordflow">if</span> (currshape-&gt;adjmatrix[uniqueintersections.<a class="code" href="structFC__SortedIntArray.html#60520a789b3d255c10053389b65bab10">vals</a>[m]][uniqueintersections.<a class="code" href="structFC__SortedIntArray.html#60520a789b3d255c10053389b65bab10">vals</a>[n]]
<a name="l00864"></a>00864           == 0){
<a name="l00865"></a>00865            si-&gt;subtype = <a class="code" href="tears_8c.html#1af138ee919beeb88a50aa27b42124b7aa3bdeb8d317fc5f1b2a6b112ee85561">NONADJSIDES</a>;
<a name="l00866"></a>00866            <span class="keywordflow">break</span>;
<a name="l00867"></a>00867          }
<a name="l00868"></a>00868        }
<a name="l00869"></a>00869        <span class="keywordflow">if</span> (si-&gt;subtype == <a class="code" href="tears_8c.html#1af138ee919beeb88a50aa27b42124b7aa3bdeb8d317fc5f1b2a6b112ee85561">NONADJSIDES</a>){
<a name="l00870"></a>00870          <span class="keywordflow">break</span>;
<a name="l00871"></a>00871        }
<a name="l00872"></a>00872      }
<a name="l00873"></a>00873       }
<a name="l00874"></a>00874 
<a name="l00875"></a>00875       <a class="code" href="group__SimpleDataObjects.html#ga6ecd909b91f581633b4accbc88642b2">fc_freeSortedIntArray</a>(&amp;uniqueintersections);
<a name="l00876"></a>00876     }
<a name="l00877"></a>00877 
<a name="l00878"></a>00878 
<a name="l00879"></a>00879     <span class="comment">//clean up</span>
<a name="l00880"></a>00880     free(decayedSidesSegments);
<a name="l00881"></a>00881 
<a name="l00882"></a>00882     <span class="comment">//if weve gotten this far, we have an intersection</span>
<a name="l00883"></a>00883     <span class="keywordflow">break</span>;
<a name="l00884"></a>00884 
<a name="l00885"></a>00885   } <span class="comment">//numshapes</span>
<a name="l00886"></a>00886 
<a name="l00887"></a>00887   tear-&gt;shape_intersection = si;
<a name="l00888"></a>00888   <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52e27738acee5b8b2ef61be6e9b14a26613">FC_SUCCESS</a>;
<a name="l00889"></a>00889 }
<a name="l00890"></a>00890 
<a name="l00891"></a>00891 
<a name="l00892"></a>00892 <span class="comment">// Expand the order array - make sure there is enough</span>
<a name="l00893"></a><a class="code" href="tears_8c.html#5776ceee8c0a3cdf15c2c4282d10476e">00893</a> <span class="keyword">static</span> <a class="code" href="group__DataTypes.html#g2a816f8eddef0c2d8c2e3a0393b1f52e">FC_ReturnCode</a> <a class="code" href="tears_8c.html#5776ceee8c0a3cdf15c2c4282d10476e">grow_orders</a>(<span class="keywordtype">int</span> numNewShapes, <span class="keywordtype">int</span> numCurrentShapes, 
<a name="l00894"></a>00894                     <span class="keywordtype">int</span>* maxNumShapes, <a class="code" href="structshape__order.html">shape_order</a>*** order) {
<a name="l00895"></a>00895   <a class="code" href="structshape__order.html">shape_order</a>** temp_order; <span class="comment">//array of ptrs</span>
<a name="l00896"></a>00896   <span class="keywordtype">int</span> temp_maxNumShapes;
<a name="l00897"></a>00897 
<a name="l00898"></a>00898   <span class="comment">// internal, so no input testing</span>
<a name="l00899"></a>00899 
<a name="l00900"></a>00900   <span class="comment">// no new shapes do nothing</span>
<a name="l00901"></a>00901   <span class="keywordflow">if</span> (numNewShapes &lt; 1)
<a name="l00902"></a>00902     <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52e27738acee5b8b2ef61be6e9b14a26613">FC_SUCCESS</a>;
<a name="l00903"></a>00903 
<a name="l00904"></a>00904   <span class="comment">// if we are going, to run out of room, expand the array</span>
<a name="l00905"></a>00905   <span class="keywordflow">if</span> (numNewShapes + numCurrentShapes &gt; *maxNumShapes) {
<a name="l00906"></a>00906     temp_maxNumShapes = 2*(numNewShapes + numCurrentShapes);
<a name="l00907"></a>00907     temp_order = (<a class="code" href="structshape__order.html">shape_order</a>**)realloc(*order,
<a name="l00908"></a>00908                          temp_maxNumShapes*
<a name="l00909"></a>00909                          <span class="keyword">sizeof</span>(<a class="code" href="structshape__order.html">shape_order</a>*));
<a name="l00910"></a>00910     <span class="keywordflow">if</span> (!temp_order) {
<a name="l00911"></a>00911       <a class="code" href="group__ErrorHandling.html#g4a09c0024ecd45d5d63c8b9ec333a717">fc_exitIfError</a>(<a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52ee4bf428a2cdead5d4e3e3391a2cdab0d">FC_MEMORY_ERROR</a>);
<a name="l00912"></a>00912     }
<a name="l00913"></a>00913     *maxNumShapes = temp_maxNumShapes;
<a name="l00914"></a>00914     *order = temp_order;
<a name="l00915"></a>00915   }
<a name="l00916"></a>00916   <span class="comment">// else, do nothing</span>
<a name="l00917"></a>00917 
<a name="l00918"></a>00918   <span class="comment">// done</span>
<a name="l00919"></a>00919   <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52e27738acee5b8b2ef61be6e9b14a26613">FC_SUCCESS</a>;
<a name="l00920"></a>00920 }
<a name="l00921"></a>00921 
<a name="l00922"></a><a class="code" href="tears_8c.html#24e6ce6d053864cf5fb7af941457bb0e">00922</a> <span class="keywordtype">int</span> <a class="code" href="analyzeSpotWelds_8c.html#24e6ce6d053864cf5fb7af941457bb0e">main</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv) {
<a name="l00923"></a>00923   <a class="code" href="group__DataTypes.html#g2a816f8eddef0c2d8c2e3a0393b1f52e">FC_ReturnCode</a> rc;
<a name="l00924"></a>00924   <span class="keywordtype">int</span> i, j, k;
<a name="l00925"></a>00925   <span class="keywordtype">char</span>* dataset_file_name = NULL;
<a name="l00926"></a>00926   <span class="keywordtype">char</span>* output_file_name = NULL;
<a name="l00927"></a>00927   <span class="keywordtype">char</span>* displ_var_name = NULL;
<a name="l00928"></a>00928   <span class="keywordtype">char</span>** meshNames = NULL;
<a name="l00929"></a>00929   <a class="code" href="group__DataTypes.html#g6c0891f21e34bad1d8b2bc7c76193a39">FC_VerbosityLevel</a> verbose_level = <a class="code" href="group__DataTypes.html#gg6c0891f21e34bad1d8b2bc7c76193a399cb0ad9c1f97775f8954860a08d78144">FC_QUIET</a>;
<a name="l00930"></a>00930   <span class="keywordtype">int</span> numMesh = 0, numStep, temp_numStep;
<a name="l00931"></a>00931   <a class="code" href="structFC__Dataset.html">FC_Dataset</a> dataset;
<a name="l00932"></a>00932   <a class="code" href="structFC__Mesh.html">FC_Mesh</a>* meshes;
<a name="l00933"></a>00933   FILE* output_file, *bb_file, *aux_file;
<a name="l00934"></a>00934   <span class="keywordtype">int</span> numDeathVar = 0;
<a name="l00935"></a>00935   <a class="code" href="structdeathvarinfo.html">deathvarinfo</a>* deathVarInfos;
<a name="l00936"></a>00936   <span class="keywordtype">int</span> numTear = 0, maxNumTear = 0;
<a name="l00937"></a>00937   <a class="code" href="structTear.html">Tear</a> *tears = NULL;
<a name="l00938"></a>00938   <span class="keywordtype">int</span> doDispl = 0, doCombine = 0;
<a name="l00939"></a>00939   <span class="comment">// This assumes elem_death and the displacements are seq vars </span>
<a name="l00940"></a>00940   <a class="code" href="structFC__Variable.html">FC_Variable</a> ***deathVars;  <span class="comment">// deathVars[meshID][deathVarID][stepID]</span>
<a name="l00941"></a>00941   <a class="code" href="structFC__Variable.html">FC_Variable</a> **displs;  <span class="comment">// displs[meshID][stepID]</span>
<a name="l00942"></a>00942   <span class="keywordtype">int</span> numSuperTear = 0;
<a name="l00943"></a>00943   <a class="code" href="structSuperTear.html">SuperTear</a>* superTears = NULL;
<a name="l00944"></a>00944   <a class="code" href="structSuperTear.html">SuperTear</a> superDuperTear; <span class="comment">// grand total</span>
<a name="l00945"></a>00945   <span class="keywordtype">double</span> min_dist;
<a name="l00946"></a>00946   <span class="keywordtype">char</span> name_buf[1028];
<a name="l00947"></a>00947   <span class="keywordtype">int</span>* topoDims;     <span class="comment">// topoDim per mesh</span>
<a name="l00948"></a>00948   <span class="keywordtype">int</span> globalTopoDim; <span class="comment">// globalTopoDim = -1 means diff dims on diff meshes</span>
<a name="l00949"></a>00949   <span class="keywordtype">int</span> doDamageWeight = 0;
<a name="l00950"></a>00950   <span class="keywordtype">double</span> dead_damage;
<a name="l00951"></a>00951   <span class="keywordtype">int</span> deathID = 0;  <span class="comment">// assuming death criterion will be first</span>
<a name="l00952"></a>00952   <span class="keywordtype">int</span> damageID = 1; <span class="comment">// and damage criterion is second</span>
<a name="l00953"></a>00953   <span class="keywordtype">int</span> stepID = -1;  <span class="comment">// the id of the timestep of interest</span>
<a name="l00954"></a>00954 
<a name="l00955"></a>00955   <span class="keywordtype">int</span> useShape = 0; <span class="comment">//default to not do shape calc</span>
<a name="l00956"></a>00956   <span class="keywordtype">int</span> setangle = 0; <span class="comment">//check for if the user set an angle </span>
<a name="l00957"></a>00957   <span class="keywordtype">double</span> shapeangle = <a class="code" href="tears_8c.html#c903c6d6dff43627c254c7f1f2f3516efd34c30fdef835923240803d8b6330b5">SHAPE_ANGLE</a>;
<a name="l00958"></a>00958   <span class="keywordtype">int</span> shareddim = <a class="code" href="tears_8c.html#c903c6d6dff43627c254c7f1f2f3516ea72439ec90bc8177728bc3447a4ea50c">SHARED_DIM</a>;
<a name="l00959"></a>00959   <a class="code" href="structshape__order.html">shape_order</a> **shapeorder = NULL; <span class="comment">//array of ptrs to already allocated shape_orders</span>
<a name="l00960"></a>00960   <span class="keywordtype">int</span> numShapes = 0;
<a name="l00961"></a>00961   <span class="keywordtype">int</span> maxNumShapes = 0;
<a name="l00962"></a>00962 
<a name="l00963"></a>00963   <span class="comment">// --- handle arguments</span>
<a name="l00964"></a>00964 
<a name="l00965"></a>00965   <span class="keywordflow">if</span> (argc &lt; 2 ) {
<a name="l00966"></a>00966   usage:
<a name="l00967"></a>00967     printf(<span class="stringliteral">"usage: %s [options] dataset [mesh_names]\n"</span>, 
<a name="l00968"></a>00968            argv[0]);
<a name="l00969"></a>00969     printf(<span class="stringliteral">"options: \n"</span>);
<a name="l00970"></a>00970     printf(<span class="stringliteral">"   -h              : print this help message\n"</span>);
<a name="l00971"></a>00971     printf(<span class="stringliteral">"   -v              : verbose: print warning and error messages\n"</span>);
<a name="l00972"></a>00972     printf(<span class="stringliteral">"   -V              : very verbose: prints log and error messages\n"</span>);
<a name="l00973"></a>00973     printf(<span class="stringliteral">"   -o              : name of output file (default is stdout)\n"</span>);
<a name="l00974"></a>00974     printf(<span class="stringliteral">"                     value (default is \"&lt;=\") \n"</span>);
<a name="l00975"></a>00975     printf(<span class="stringliteral">"   -d var_name     : calc the displaced values using this displacement\n"</span>);
<a name="l00976"></a>00976     printf(<span class="stringliteral">"                     variable\n"</span>);
<a name="l00977"></a>00977     printf(<span class="stringliteral">"   -m min_dist     : combine tears from different parts if they are less\n"</span>);
<a name="l00978"></a>00978     printf(<span class="stringliteral">"                     than (or equal to) a minimum distance apart\n"</span>);
<a name="l00979"></a>00979     printf(<span class="stringliteral">"   -n # &lt;triplets&gt; : Specify the rules for finding dead elements.\n"</span>);
<a name="l00980"></a>00980     printf(<span class="stringliteral">"                     The first parameter is the number of triplets. Each\n"</span>); 
<a name="l00981"></a>00981     printf(<span class="stringliteral">"                     triplet is the name of variable to test, the comparison\n"</span>);
<a name="l00982"></a>00982     printf(<span class="stringliteral">"                     operator, and the value. The default is \n"</span>);
<a name="l00983"></a>00983     printf(<span class="stringliteral">"                     '-n 1 elem_death \"&lt;=\" 0', meaning all elements\n"</span>);
<a name="l00984"></a>00984     printf(<span class="stringliteral">"                     where the variable 'elem_death' is less than or\n"</span>);
<a name="l00985"></a>00985     printf(<span class="stringliteral">"                     equal to zero are treated as being dead.\n"</span>);
<a name="l00986"></a>00986     printf(<span class="stringliteral">"   -t time_step    : The index of the timestep at which to find tears\n"</span>);
<a name="l00987"></a>00987     printf(<span class="stringliteral">"                     (indexing from 0). The default is to use the last one.\n"</span>);
<a name="l00988"></a>00988     printf(<span class="stringliteral">"   -w dead_damage  : Calculate damage weighted volumes. You must specify\n"</span>);
<a name="l00989"></a>00989     printf(<span class="stringliteral">"                     exactly 2 death criteria using the -n flag. The first\n"</span>);
<a name="l00990"></a>00990     printf(<span class="stringliteral">"                     must be for the dead elements and the second for the\n"</span>);
<a name="l00991"></a>00991     printf(<span class="stringliteral">"                     damaged elements. The supplied dead_damage value is\n"</span>);
<a name="l00992"></a>00992     printf(<span class="stringliteral">"                     used as the damage value for the dead elements.\n"</span>);
<a name="l00993"></a>00993     printf(<span class="stringliteral">"   -ss             : Include shape calculation, defaults to no shape calc \n"</span>);
<a name="l00994"></a>00994     printf(<span class="stringliteral">"                     shape (defaults to 40, must be between 0 and 180).\n"</span>);
<a name="l00995"></a>00995     printf(<span class="stringliteral">"   -sa angle       : Angle to be used for determining sides of a \n"</span>);
<a name="l00996"></a>00996     printf(<span class="stringliteral">"                     shape (defaults to 40, must be between 0 and 180).\n"</span>);
<a name="l00997"></a>00997     printf(<span class="stringliteral">"\n"</span>);
<a name="l00998"></a>00998     printf(<span class="stringliteral">"examples:\n"</span>);
<a name="l00999"></a>00999     printf(<span class="stringliteral">"   tears -d \"displ var\" data.ex2 - use default values but also calculate\n"</span>);
<a name="l01000"></a>01000     printf(<span class="stringliteral">"                       the displaced version.\n"</span>);
<a name="l01001"></a>01001     printf(<span class="stringliteral">"   tears -n 2 elem_death \"&lt;=\" 0 damage \"&gt;\" .1 data.ex2 - tears are\n"</span>);
<a name="l01002"></a>01002     printf(<span class="stringliteral">"                       elements where elem_death is greater &lt; 0 or damage\n"</span>);
<a name="l01003"></a>01003     printf(<span class="stringliteral">"                       is greater than .1\n"</span>);
<a name="l01004"></a>01004     fflush(NULL);
<a name="l01005"></a>01005     exit(-1);
<a name="l01006"></a>01006   }
<a name="l01007"></a>01007   <span class="keywordflow">for</span> (i = 1; i &lt; argc; i++) {
<a name="l01008"></a>01008     <span class="keywordflow">if</span> (!strcmp(argv[i], <span class="stringliteral">"-v"</span>)) {
<a name="l01009"></a>01009       verbose_level = <a class="code" href="group__DataTypes.html#gg6c0891f21e34bad1d8b2bc7c76193a3995521f4f1526a6565b08e663106dd6e7">FC_WARNING_MESSAGES</a>;
<a name="l01010"></a>01010     }
<a name="l01011"></a>01011     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!strcmp(argv[i], <span class="stringliteral">"-V"</span>)) {
<a name="l01012"></a>01012       verbose_level = <a class="code" href="group__DataTypes.html#gg6c0891f21e34bad1d8b2bc7c76193a395a6192ba586cd970dd36a49cd8862714">FC_LOG_MESSAGES</a>;
<a name="l01013"></a>01013     }
<a name="l01014"></a>01014     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!strncmp(argv[i], <span class="stringliteral">"-h"</span>, 2))
<a name="l01015"></a>01015       <span class="keywordflow">goto</span> usage;
<a name="l01016"></a>01016     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!strcmp(argv[i], <span class="stringliteral">"-o"</span>)) {
<a name="l01017"></a>01017       i++;
<a name="l01018"></a>01018       output_file_name = argv[i];
<a name="l01019"></a>01019     }
<a name="l01020"></a>01020     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!strcmp(argv[i], <span class="stringliteral">"-d"</span>)) {
<a name="l01021"></a>01021       doDispl = 1;
<a name="l01022"></a>01022       i++;
<a name="l01023"></a>01023       displ_var_name = argv[i];
<a name="l01024"></a>01024     }
<a name="l01025"></a>01025     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!strcmp(argv[i], <span class="stringliteral">"-m"</span>)) {
<a name="l01026"></a>01026       doCombine = 1;
<a name="l01027"></a>01027       i++;
<a name="l01028"></a>01028       min_dist = atof(argv[i]);
<a name="l01029"></a>01029     }
<a name="l01030"></a>01030     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!strcmp(argv[i], <span class="stringliteral">"-n"</span>)) {
<a name="l01031"></a>01031       i++;
<a name="l01032"></a>01032       rc = <a class="code" href="gaplines_8c.html#cb3a46b4682216fa4a7faaa40e499a38">parseDeathVarSet</a>(argc, argv, &amp;i, &amp;numDeathVar, &amp;deathVarInfos);
<a name="l01033"></a>01033       <span class="keywordflow">if</span> (rc != <a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52e27738acee5b8b2ef61be6e9b14a26613">FC_SUCCESS</a>)
<a name="l01034"></a>01034      <span class="keywordflow">goto</span> usage;
<a name="l01035"></a>01035     }
<a name="l01036"></a>01036     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!strcmp(argv[i], <span class="stringliteral">"-t"</span>)) {
<a name="l01037"></a>01037       i++;
<a name="l01038"></a>01038       stepID = atoi(argv[i]);
<a name="l01039"></a>01039     }
<a name="l01040"></a>01040     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!strcmp(argv[i], <span class="stringliteral">"-w"</span>)) {
<a name="l01041"></a>01041       doDamageWeight = 1;
<a name="l01042"></a>01042       i++;
<a name="l01043"></a>01043       dead_damage = atof(argv[i]);
<a name="l01044"></a>01044     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!strcmp(argv[i], <span class="stringliteral">"-ss"</span>)) {
<a name="l01045"></a>01045       useShape = 1;
<a name="l01046"></a>01046     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!strcmp(argv[i], <span class="stringliteral">"-sa"</span>)) {
<a name="l01047"></a>01047       <span class="keywordtype">char</span>* end_ptr;
<a name="l01048"></a>01048       i++;
<a name="l01049"></a>01049       <span class="keywordflow">if</span> (argc &lt; i+1){
<a name="l01050"></a>01050      <span class="keywordflow">goto</span> usage;
<a name="l01051"></a>01051       }
<a name="l01052"></a>01052       shapeangle = strtod(argv[i], &amp;end_ptr);
<a name="l01053"></a>01053       <span class="keywordflow">if</span> (*end_ptr == <span class="charliteral">'\0'</span>){ <span class="comment">//its a number</span>
<a name="l01054"></a>01054         <span class="keywordflow">if</span> (shapeangle &lt; 0 || shapeangle &gt; 180){
<a name="l01055"></a>01055           <a class="code" href="group__Library.html#gb41a63cb101314fb41df98cef504a556">fc_printfErrorMessage</a>(<span class="stringliteral">"Invalid angle: must be between 0-180"</span>);
<a name="l01056"></a>01056           <span class="keywordflow">goto</span> usage;
<a name="l01057"></a>01057         }
<a name="l01058"></a>01058       }<span class="keywordflow">else</span>{
<a name="l01059"></a>01059         <a class="code" href="group__Library.html#gb41a63cb101314fb41df98cef504a556">fc_printfErrorMessage</a>(<span class="stringliteral">"Invalid angle: must be a number"</span>);
<a name="l01060"></a>01060         <span class="keywordflow">goto</span> usage;
<a name="l01061"></a>01061       }
<a name="l01062"></a>01062       setangle = 1;
<a name="l01063"></a>01063     }
<a name="l01064"></a>01064     <span class="keywordflow">else</span> {
<a name="l01065"></a>01065       dataset_file_name = argv[i];
<a name="l01066"></a>01066       <span class="comment">// optional mesh names</span>
<a name="l01067"></a>01067       <span class="keywordflow">for</span> (j =i+1; j &lt; argc; j++) {
<a name="l01068"></a>01068      <span class="keywordtype">void</span>* tmp;
<a name="l01069"></a>01069      <span class="keywordflow">if</span> (argv[j][0] == <span class="charliteral">'-'</span>) 
<a name="l01070"></a>01070        <span class="keywordflow">break</span>;
<a name="l01071"></a>01071      tmp = (<span class="keywordtype">char</span>**)realloc(meshNames, (numMesh+1)*<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>*));
<a name="l01072"></a>01072      <span class="keywordflow">if</span> (!tmp)
<a name="l01073"></a>01073        <a class="code" href="group__ErrorHandling.html#g4a09c0024ecd45d5d63c8b9ec333a717">fc_exitIfError</a>(<a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52ee4bf428a2cdead5d4e3e3391a2cdab0d">FC_MEMORY_ERROR</a>);
<a name="l01074"></a>01074      meshNames = tmp;
<a name="l01075"></a>01075      meshNames[numMesh] = (<span class="keywordtype">char</span>*)malloc((strlen(argv[j])+1)*<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));
<a name="l01076"></a>01076      strcpy(meshNames[numMesh], argv[j]);
<a name="l01077"></a>01077      numMesh++;
<a name="l01078"></a>01078      i++;
<a name="l01079"></a>01079       }
<a name="l01080"></a>01080     }
<a name="l01081"></a>01081   }
<a name="l01082"></a>01082 
<a name="l01083"></a>01083   <span class="comment">// testing args</span>
<a name="l01084"></a>01084   <span class="keywordflow">if</span> (!dataset_file_name)
<a name="l01085"></a>01085     <span class="keywordflow">goto</span> usage;
<a name="l01086"></a>01086   <span class="keywordflow">if</span> (doCombine &amp;&amp; min_dist &lt; 0) 
<a name="l01087"></a>01087     <a class="code" href="error_8h.html#42c09317184affa18e70826cb35f3f04">fc_exitIfErrorPrintf</a>(<a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52e51d318f8c97c8b094cf9820b51e4fa83">FC_ERROR</a>, <span class="stringliteral">"min_dist must be 0 or greater"</span>);
<a name="l01088"></a>01088   <span class="keywordflow">if</span> (doDamageWeight &amp;&amp; numDeathVar != 2)
<a name="l01089"></a>01089     <a class="code" href="error_8h.html#42c09317184affa18e70826cb35f3f04">fc_exitIfErrorPrintf</a>(<a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52e51d318f8c97c8b094cf9820b51e4fa83">FC_ERROR</a>, <span class="stringliteral">"you must specify 2 death criteria to "</span>
<a name="l01090"></a>01090                 <span class="stringliteral">"do damage weighting"</span>);
<a name="l01091"></a>01091   <span class="keywordflow">if</span>(setangle &amp;&amp; !useShape)
<a name="l01092"></a>01092     <a class="code" href="error_8h.html#42c09317184affa18e70826cb35f3f04">fc_exitIfErrorPrintf</a>(<a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52e51d318f8c97c8b094cf9820b51e4fa83">FC_ERROR</a>, <span class="stringliteral">"you must set use shape if you want to "</span>
<a name="l01093"></a>01093                 <span class="stringliteral">"specify an angle"</span>);
<a name="l01094"></a>01094 
<a name="l01095"></a>01095 
<a name="l01096"></a>01096   <span class="comment">// default death criteria</span>
<a name="l01097"></a>01097   <span class="keywordflow">if</span> (numDeathVar &lt; 1) {
<a name="l01098"></a>01098     numDeathVar = 1;
<a name="l01099"></a>01099     deathVarInfos = (<a class="code" href="structdeathvarinfo.html">deathvarinfo</a>*)malloc(<span class="keyword">sizeof</span>(<a class="code" href="structdeathvarinfo.html">deathvarinfo</a>));
<a name="l01100"></a>01100     <span class="keywordflow">if</span> (deathVarInfos == NULL)
<a name="l01101"></a>01101       <a class="code" href="group__ErrorHandling.html#g4a09c0024ecd45d5d63c8b9ec333a717">fc_exitIfError</a>(<a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52ee4bf428a2cdead5d4e3e3391a2cdab0d">FC_MEMORY_ERROR</a>);
<a name="l01102"></a>01102     deathVarInfos[0].<a class="code" href="structdeathvarinfo.html#1ebd5a95b4c6e28486008caed06d2728">name</a> = <span class="stringliteral">"elem_death"</span>;
<a name="l01103"></a>01103     deathVarInfos[0].<a class="code" href="structdeathvarinfo.html#b70b406afadea0a12dda1670415c1249">op</a> = <span class="stringliteral">"&lt;="</span>;
<a name="l01104"></a>01104     deathVarInfos[0].<a class="code" href="structdeathvarinfo.html#27e8b3504f5a5b0ecefb58b992c31031">val</a> = 0;
<a name="l01105"></a>01105   }
<a name="l01106"></a>01106 
<a name="l01107"></a>01107   <span class="comment">// --- setup</span>
<a name="l01108"></a>01108 
<a name="l01109"></a>01109   <span class="comment">// init library and load dataset </span>
<a name="l01110"></a>01110   rc = <a class="code" href="group__Library.html#gf13f047de6d44c9028d4944bc29867db">fc_setLibraryVerbosity</a>(verbose_level);
<a name="l01111"></a>01111   <a class="code" href="group__ErrorHandling.html#g4a09c0024ecd45d5d63c8b9ec333a717">fc_exitIfError</a>(rc);
<a name="l01112"></a>01112   rc = <a class="code" href="group__Library.html#g355d03ffe3f8c560e9343716f78af097">fc_initLibrary</a>();
<a name="l01113"></a>01113   <a class="code" href="group__ErrorHandling.html#g4a09c0024ecd45d5d63c8b9ec333a717">fc_exitIfError</a>(rc);
<a name="l01114"></a>01114   rc = <a class="code" href="group__FileIO.html#g953a8c4a7feb785e0091b7cf58626092">fc_loadDataset</a>(dataset_file_name, &amp;dataset);
<a name="l01115"></a>01115   <a class="code" href="error_8h.html#42c09317184affa18e70826cb35f3f04">fc_exitIfErrorPrintf</a>(rc, <span class="stringliteral">"Failed to load dataset '%s'"</span>, dataset_file_name);
<a name="l01116"></a>01116   
<a name="l01117"></a>01117 
<a name="l01118"></a>01118   <span class="comment">// Make sure meshes exist (or get all meshes) {</span>
<a name="l01119"></a>01119   <span class="keywordflow">if</span> (numMesh &gt; 0) {
<a name="l01120"></a>01120     meshes = (<a class="code" href="structFC__Mesh.html">FC_Mesh</a>*)malloc(numMesh*<span class="keyword">sizeof</span>(<a class="code" href="structFC__Mesh.html">FC_Mesh</a>));
<a name="l01121"></a>01121     <span class="keywordflow">if</span> (!meshes)
<a name="l01122"></a>01122       <a class="code" href="group__ErrorHandling.html#g4a09c0024ecd45d5d63c8b9ec333a717">fc_exitIfError</a>(<a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52ee4bf428a2cdead5d4e3e3391a2cdab0d">FC_MEMORY_ERROR</a>);
<a name="l01123"></a>01123     <span class="keywordflow">for</span> (i = 0; i &lt; numMesh; i++) {
<a name="l01124"></a>01124       FC_Mesh *returnMeshes;
<a name="l01125"></a>01125       <span class="keywordtype">int</span> numReturnMeshes;
<a name="l01126"></a>01126 
<a name="l01127"></a>01127       rc = <a class="code" href="group__Mesh.html#g8f35371531555da3b336a94d7ce3053d">fc_getMeshByName</a>(dataset, meshNames[i], 
<a name="l01128"></a>01128                    &amp;numReturnMeshes,&amp;returnMeshes);
<a name="l01129"></a>01129       <a class="code" href="error_8h.html#42c09317184affa18e70826cb35f3f04">fc_exitIfErrorPrintf</a>(rc, <span class="stringliteral">"Failed to get mesh by name"</span>);
<a name="l01130"></a>01130       <span class="keywordflow">if</span> (numReturnMeshes != 1){
<a name="l01131"></a>01131      <a class="code" href="error_8h.html#42c09317184affa18e70826cb35f3f04">fc_exitIfErrorPrintf</a>(<a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52e4905abab801292d8b6338a89462b8e22">FC_INPUT_ERROR</a>,
<a name="l01132"></a>01132                     <span class="stringliteral">"Failed to find (unique) mesh '%s' - found %d matches"</span>,
<a name="l01133"></a>01133                     meshNames[i],numReturnMeshes);
<a name="l01134"></a>01134       }
<a name="l01135"></a>01135       meshes[i] = returnMeshes[0];
<a name="l01136"></a>01136       free(returnMeshes);
<a name="l01137"></a>01137     }
<a name="l01138"></a>01138   }
<a name="l01139"></a>01139   <span class="keywordflow">else</span> {
<a name="l01140"></a>01140     rc = <a class="code" href="group__Mesh.html#ge71cd0e179143c6d82d58b9cc78cc436">fc_getMeshes</a>(dataset, &amp;numMesh, &amp;meshes);
<a name="l01141"></a>01141     <a class="code" href="group__ErrorHandling.html#g4a09c0024ecd45d5d63c8b9ec333a717">fc_exitIfError</a>(rc);
<a name="l01142"></a>01142     <span class="keywordflow">if</span> (numMesh &lt; 1)
<a name="l01143"></a>01143       <a class="code" href="error_8h.html#42c09317184affa18e70826cb35f3f04">fc_exitIfErrorPrintf</a>(FC_ERROR, <span class="stringliteral">"No meshes in dataset"</span>);
<a name="l01144"></a>01144     meshNames = (<span class="keywordtype">char</span>**)malloc(numMesh*<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>*));
<a name="l01145"></a>01145     <span class="keywordflow">if</span> (!meshNames)
<a name="l01146"></a>01146       <a class="code" href="group__ErrorHandling.html#g4a09c0024ecd45d5d63c8b9ec333a717">fc_exitIfError</a>(<a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52ee4bf428a2cdead5d4e3e3391a2cdab0d">FC_MEMORY_ERROR</a>);
<a name="l01147"></a>01147     <span class="keywordflow">for</span> (i = 0; i &lt; numMesh; i++) {
<a name="l01148"></a>01148       rc = <a class="code" href="group__Mesh.html#g9f5a1b484e4b5ab4e0e137bfe34e10d6">fc_getMeshName</a>(meshes[i], &amp;meshNames[i]);
<a name="l01149"></a>01149       <a class="code" href="error_8h.html#42c09317184affa18e70826cb35f3f04">fc_exitIfErrorPrintf</a>(rc, <span class="stringliteral">"Failed to get mesh name"</span>);
<a name="l01150"></a>01150     }
<a name="l01151"></a>01151   }
<a name="l01152"></a>01152 
<a name="l01153"></a>01153   <span class="comment">// Collect &amp; test topo dims</span>
<a name="l01154"></a>01154   <span class="comment">// 1) topodims need to be 2 or 3</span>
<a name="l01155"></a>01155   <span class="comment">// 2) If combining, all topodims must be the same</span>
<a name="l01156"></a>01156   topoDims = (<span class="keywordtype">int</span>*)malloc(numMesh*<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
<a name="l01157"></a>01157   <span class="keywordflow">if</span> (!topoDims)
<a name="l01158"></a>01158     <a class="code" href="group__ErrorHandling.html#g4a09c0024ecd45d5d63c8b9ec333a717">fc_exitIfError</a>(<a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52ee4bf428a2cdead5d4e3e3391a2cdab0d">FC_MEMORY_ERROR</a>);
<a name="l01159"></a>01159   <span class="keywordflow">for</span> (i = 0; i &lt; numMesh; i++) {
<a name="l01160"></a>01160     rc = <a class="code" href="group__Mesh.html#g06bdd16c4f8ea1d805927fb26ca8d8ef">fc_getMeshTopodim</a>(meshes[i], &amp;topoDims[i]);
<a name="l01161"></a>01161     <a class="code" href="error_8h.html#42c09317184affa18e70826cb35f3f04">fc_exitIfErrorPrintf</a>(rc, <span class="stringliteral">"Failed to get topo dims"</span>);
<a name="l01162"></a>01162     <span class="keywordflow">if</span> (topoDims[i] != 2 &amp;&amp; topoDims[i] != 3)
<a name="l01163"></a>01163       <a class="code" href="error_8h.html#42c09317184affa18e70826cb35f3f04">fc_exitIfErrorPrintf</a>(FC_ERROR, <span class="stringliteral">"Meshes must be of topo dim 2 or 3"</span>);
<a name="l01164"></a>01164     <span class="keywordflow">if</span> (i == 0)
<a name="l01165"></a>01165       globalTopoDim = topoDims[i];
<a name="l01166"></a>01166     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (topoDims[i] != topoDims[0]) {
<a name="l01167"></a>01167       globalTopoDim = -1;
<a name="l01168"></a>01168       <span class="keywordflow">if</span> (doCombine)
<a name="l01169"></a>01169      <a class="code" href="error_8h.html#42c09317184affa18e70826cb35f3f04">fc_exitIfErrorPrintf</a>(FC_ERROR, <span class="stringliteral">"If combining tears across meshes, all"</span>
<a name="l01170"></a>01170                     <span class="stringliteral">"meshes must have the same topoDim"</span>);
<a name="l01171"></a>01171     }
<a name="l01172"></a>01172   }
<a name="l01173"></a>01173 
<a name="l01174"></a>01174   <span class="comment">// Make sure required variable fields exist on the meshes</span>
<a name="l01175"></a>01175   <span class="comment">// and that death vars are on elements</span>
<a name="l01176"></a>01176   deathVars = (<a class="code" href="structFC__Variable.html">FC_Variable</a>***)malloc(numMesh*<span class="keyword">sizeof</span>(<a class="code" href="structFC__Variable.html">FC_Variable</a>**));
<a name="l01177"></a>01177   <span class="keywordflow">if</span> (!deathVars)
<a name="l01178"></a>01178     <a class="code" href="group__ErrorHandling.html#g4a09c0024ecd45d5d63c8b9ec333a717">fc_exitIfError</a>(FC_MEMORY_ERROR);
<a name="l01179"></a>01179   <span class="keywordflow">for</span> (i = 0; i &lt; numMesh; i++) {
<a name="l01180"></a>01180     deathVars[i] = (FC_Variable**)malloc(numDeathVar*<span class="keyword">sizeof</span>(FC_Variable*));
<a name="l01181"></a>01181     <span class="keywordflow">if</span> (!deathVars[i])
<a name="l01182"></a>01182       <a class="code" href="group__ErrorHandling.html#g4a09c0024ecd45d5d63c8b9ec333a717">fc_exitIfError</a>(FC_MEMORY_ERROR);
<a name="l01183"></a>01183     <span class="keywordflow">for</span> (j = 0; j &lt; numDeathVar; j++) {
<a name="l01184"></a>01184       <a class="code" href="group__DataTypes.html#g63044bd7bb5313d8a79ea8a71f1b3040">FC_AssociationType</a> assoc;
<a name="l01185"></a>01185       rc = <a class="code" href="group__Variable.html#g81cdc76a742e4bbf85fcbf5deba8c0e7">fc_getOrGenerateUniqueSeqVariableByName</a>(meshes[i], deathVarInfos[j].name,
<a name="l01186"></a>01186                                  &amp;numStep, &amp;deathVars[i][j]);
<a name="l01187"></a>01187       <a class="code" href="error_8h.html#42c09317184affa18e70826cb35f3f04">fc_exitIfErrorPrintf</a>(rc, <span class="stringliteral">"Failed to find element death variable '%s'"</span>,
<a name="l01188"></a>01188                   deathVarInfos[j].name);
<a name="l01189"></a>01189       <span class="keywordflow">if</span> (!deathVars[i][j]){
<a name="l01190"></a>01190      <a class="code" href="error_8h.html#42c09317184affa18e70826cb35f3f04">fc_exitIfErrorPrintf</a>(<a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52e4905abab801292d8b6338a89462b8e22">FC_INPUT_ERROR</a>,
<a name="l01191"></a>01191                     <span class="stringliteral">"Failed to find (unique) element death variable '%s'"</span>,
<a name="l01192"></a>01192                     deathVarInfos[j].name);
<a name="l01193"></a>01193       }
<a name="l01194"></a>01194 
<a name="l01195"></a>01195       <a class="code" href="group__Variable.html#g36c4ac9f503bcf040c378c06e1ad9188">fc_getVariableAssociationType</a>(deathVars[i][j][0], &amp;assoc);
<a name="l01196"></a>01196       <span class="keywordflow">if</span> (assoc != <a class="code" href="group__DataTypes.html#gg63044bd7bb5313d8a79ea8a71f1b3040f4be04f2efb0e31c558b6146cf83f191">FC_AT_ELEMENT</a>) {
<a name="l01197"></a>01197      <a class="code" href="error_8h.html#42c09317184affa18e70826cb35f3f04">fc_exitIfErrorPrintf</a>(FC_ERROR, <span class="stringliteral">"Death var '%s' should be of assoc "</span>
<a name="l01198"></a>01198                     <span class="stringliteral">"%s not %s"</span>, deathVarInfos[j].name,
<a name="l01199"></a>01199                     <a class="code" href="group__DataTypes.html#gdb7ce28f8a85a1cc1e68b55f64eb54f5">fc_getAssociationTypeText</a>(<a class="code" href="group__DataTypes.html#gg63044bd7bb5313d8a79ea8a71f1b3040f4be04f2efb0e31c558b6146cf83f191">FC_AT_ELEMENT</a>),
<a name="l01200"></a>01200                     <a class="code" href="group__DataTypes.html#gdb7ce28f8a85a1cc1e68b55f64eb54f5">fc_getAssociationTypeText</a>(assoc));
<a name="l01201"></a>01201       }
<a name="l01202"></a>01202     }
<a name="l01203"></a>01203   }
<a name="l01204"></a>01204   <span class="keywordflow">if</span> (doDispl) {
<a name="l01205"></a>01205     displs = (FC_Variable**)malloc(numMesh*<span class="keyword">sizeof</span>(FC_Variable*));
<a name="l01206"></a>01206     <span class="keywordflow">if</span> (!displs)
<a name="l01207"></a>01207       <a class="code" href="group__ErrorHandling.html#g4a09c0024ecd45d5d63c8b9ec333a717">fc_exitIfError</a>(FC_MEMORY_ERROR);
<a name="l01208"></a>01208     <span class="keywordflow">for</span> (i = 0; i &lt; numMesh; i++) {
<a name="l01209"></a>01209       rc = <a class="code" href="group__Variable.html#g81cdc76a742e4bbf85fcbf5deba8c0e7">fc_getOrGenerateUniqueSeqVariableByName</a>(meshes[i], displ_var_name,
<a name="l01210"></a>01210                                  &amp;temp_numStep, &amp;displs[i]);
<a name="l01211"></a>01211 
<a name="l01212"></a>01212       <a class="code" href="error_8h.html#42c09317184affa18e70826cb35f3f04">fc_exitIfErrorPrintf</a>(rc, <span class="stringliteral">"Failed to find element displacement variable '%s'"</span>,
<a name="l01213"></a>01213                   displ_var_name);              
<a name="l01214"></a>01214       <span class="keywordflow">if</span> (!displs[i]){
<a name="l01215"></a>01215      <a class="code" href="error_8h.html#42c09317184affa18e70826cb35f3f04">fc_exitIfErrorPrintf</a>(<a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52e4905abab801292d8b6338a89462b8e22">FC_INPUT_ERROR</a>, 
<a name="l01216"></a>01216                     <span class="stringliteral">"Failed to find (unique) displacement variable '%s'"</span>,
<a name="l01217"></a>01217                     displ_var_name);
<a name="l01218"></a>01218       }
<a name="l01219"></a>01219 
<a name="l01220"></a>01220       <span class="comment">//this line was outside the loop but i think it was mean to be in</span>
<a name="l01221"></a>01221       <span class="keywordflow">if</span> (temp_numStep != numStep)
<a name="l01222"></a>01222      <a class="code" href="error_8h.html#42c09317184affa18e70826cb35f3f04">fc_exitIfErrorPrintf</a>(FC_ERROR, <span class="stringliteral">"Element death var and displacment var"</span>
<a name="l01223"></a>01223                     <span class="stringliteral">"  must have the same number of steps"</span>);
<a name="l01224"></a>01224     }
<a name="l01225"></a>01225   }
<a name="l01226"></a>01226 
<a name="l01227"></a>01227   <span class="comment">// set the stepID</span>
<a name="l01228"></a>01228   <span class="keywordflow">if</span> (stepID == -1) {
<a name="l01229"></a>01229     stepID = numStep-1;
<a name="l01230"></a>01230   }
<a name="l01231"></a>01231   <span class="keywordflow">else</span> {
<a name="l01232"></a>01232     <span class="keywordflow">if</span> (stepID &lt; 0 || stepID &gt; numStep-1)
<a name="l01233"></a>01233       <a class="code" href="error_8h.html#42c09317184affa18e70826cb35f3f04">fc_exitIfErrorPrintf</a>(FC_ERROR, <span class="stringliteral">"stepID (%d) is out of range (0-%d)"</span>,
<a name="l01234"></a>01234                   stepID, numStep-1);
<a name="l01235"></a>01235   }
<a name="l01236"></a>01236 
<a name="l01237"></a>01237   <span class="comment">// get the output file</span>
<a name="l01238"></a>01238   <span class="keywordflow">if</span> (output_file_name) {
<a name="l01239"></a>01239     output_file = fopen(output_file_name, <span class="stringliteral">"w"</span>);
<a name="l01240"></a>01240     <span class="keywordflow">if</span> (!output_file) 
<a name="l01241"></a>01241       <a class="code" href="error_8h.html#42c09317184affa18e70826cb35f3f04">fc_exitIfErrorPrintf</a>(<a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52e41dd0a2fc17e1c521fa4a96cfd412708">FC_FILE_IO_ERROR</a>, <span class="stringliteral">"Failed to open file '%s' to "</span>
<a name="l01242"></a>01242                            <span class="stringliteral">"write output to"</span>, output_file_name);
<a name="l01243"></a>01243   }
<a name="l01244"></a>01244   <span class="keywordflow">else</span>
<a name="l01245"></a>01245     output_file = stdout;
<a name="l01246"></a>01246 
<a name="l01247"></a>01247   <span class="comment">// header</span>
<a name="l01248"></a>01248   fprintf(output_file, <span class="stringliteral">"Tear characterizations for dataset '%s'\n"</span>, 
<a name="l01249"></a>01249           dataset_file_name);
<a name="l01250"></a>01250   fprintf(output_file, <span class="stringliteral">"Tears criteria: '%s' %s %g"</span>, deathVarInfos[0].name,
<a name="l01251"></a>01251        deathVarInfos[0].op, deathVarInfos[0].val);
<a name="l01252"></a>01252   <span class="keywordflow">for</span> (i = 1; i &lt; numDeathVar; i++) 
<a name="l01253"></a>01253     fprintf(output_file, <span class="stringliteral">"  &amp;&amp;  '%s' %s %g"</span>, deathVarInfos[i].name,
<a name="l01254"></a>01254          deathVarInfos[i].op, deathVarInfos[i].val);
<a name="l01255"></a>01255   fprintf(output_file, <span class="stringliteral">"\n"</span>);
<a name="l01256"></a>01256   fprintf(output_file, <span class="stringliteral">"Time step index: %d\n"</span>, stepID);
<a name="l01257"></a>01257   <span class="keywordflow">if</span> (doDamageWeight) {
<a name="l01258"></a>01258     fprintf(output_file, <span class="stringliteral">"Damage weighted volumes of dead elements calculated "</span>
<a name="l01259"></a>01259          <span class="stringliteral">"using damage = %g\n"</span>, dead_damage);
<a name="l01260"></a>01260   }
<a name="l01261"></a>01261   fprintf(output_file, <span class="stringliteral">"%d mesh(es)\n"</span>, numMesh);
<a name="l01262"></a>01262   fflush(NULL);
<a name="l01263"></a>01263   
<a name="l01264"></a>01264   <span class="comment">// --- find (&amp; characterize) dead element regions</span>
<a name="l01265"></a>01265 
<a name="l01266"></a>01266   <span class="comment">// for each mesh, look for tears in the specified time step</span>
<a name="l01267"></a>01267   <span class="keywordflow">for</span> (i = 0; i &lt; numMesh; i++) {
<a name="l01268"></a>01268     <span class="keywordtype">int</span> numSegment;
<a name="l01269"></a>01269     <a class="code" href="structFC__Subset.html">FC_Subset</a> threshPerDeathVar[numDeathVar], threshAll;
<a name="l01270"></a>01270     <a class="code" href="structFC__Subset.html">FC_Subset</a> *segsPerDeathVar[numDeathVar], *segments;
<a name="l01271"></a>01271 
<a name="l01272"></a>01272     <a class="code" href="structshape__w__order.html">shape_w_order</a> *localwshapes = NULL;
<a name="l01273"></a>01273     <span class="keywordtype">int</span> numlocalshapes = 0;
<a name="l01274"></a>01274 
<a name="l01275"></a>01275     <span class="comment">// Find dead regions in last step</span>
<a name="l01276"></a>01276     rc = <a class="code" href="group__Subset.html#g40d47282abccd83987c83e8051064db2">fc_createSubset</a>(meshes[i], <span class="stringliteral">"threshold"</span>, <a class="code" href="group__DataTypes.html#gg63044bd7bb5313d8a79ea8a71f1b3040f4be04f2efb0e31c558b6146cf83f191">FC_AT_ELEMENT</a>, &amp;threshAll);
<a name="l01277"></a>01277     <a class="code" href="error_8h.html#42c09317184affa18e70826cb35f3f04">fc_exitIfErrorPrintf</a>(rc,<span class="stringliteral">"failed to create empty threshold subset"</span>);
<a name="l01278"></a>01278     <span class="keywordflow">for</span> (j = 0; j &lt; numDeathVar; j++) {
<a name="l01279"></a>01279       <a class="code" href="structFC__Subset.html">FC_Subset</a> tempSubset;
<a name="l01280"></a>01280       rc = <a class="code" href="group__Threshold.html#g96adad55812ccdee300831275ea3b355">fc_createThresholdSubset</a>(deathVars[i][j][stepID],
<a name="l01281"></a>01281                         deathVarInfos[j].op, deathVarInfos[j].val,
<a name="l01282"></a>01282                         <span class="stringliteral">"temp"</span>, &amp;threshPerDeathVar[j]);
<a name="l01283"></a>01283       <a class="code" href="error_8h.html#42c09317184affa18e70826cb35f3f04">fc_exitIfErrorPrintf</a>(rc, <span class="stringliteral">"Failed to theshold using op '%s' and value '%g'"</span>,
<a name="l01284"></a>01284                   deathVarInfos[j].op, deathVarInfos[j].val);
<a name="l01285"></a>01285       rc = <a class="code" href="group__Subset.html#gdc68d18522eac86b0c3eeb655e91f80b">fc_createSubsetIntersection</a>(threshPerDeathVar[j], <span class="stringliteral">"OR"</span>, threshAll, 
<a name="l01286"></a>01286                            <span class="stringliteral">"threshold"</span>, &amp;tempSubset);
<a name="l01287"></a>01287       <a class="code" href="error_8h.html#42c09317184affa18e70826cb35f3f04">fc_exitIfErrorPrintf</a>(rc, <span class="stringliteral">"Failed to combine subsets"</span>);
<a name="l01288"></a>01288 
<a name="l01289"></a>01289       <a class="code" href="group__Subset.html#gfdcc399692041499cc461916a9973558">fc_deleteSubset</a>(threshAll);
<a name="l01290"></a>01290       threshAll = tempSubset;
<a name="l01291"></a>01291     }
<a name="l01292"></a>01292     rc = <a class="code" href="group__TopologyRelations.html#g7a5c5ff506dab80fe40ae60a76b3d886">fc_segment</a>(threshAll, 0, &amp;numSegment, &amp;segments);
<a name="l01293"></a>01293     <a class="code" href="group__Subset.html#gfdcc399692041499cc461916a9973558">fc_deleteSubset</a>(threshAll);
<a name="l01294"></a>01294     <a class="code" href="error_8h.html#42c09317184affa18e70826cb35f3f04">fc_exitIfErrorPrintf</a>(rc, <span class="stringliteral">"Failed to segment dead regions"</span>);
<a name="l01295"></a>01295 
<a name="l01296"></a>01296     <span class="comment">// if doing damage weighting, split the segments by death var</span>
<a name="l01297"></a>01297     <span class="comment">// Note: if elem passes both death criteria, dead claims elem since we </span>
<a name="l01298"></a>01298     <span class="comment">// are assuming damage variable has no meaning on dead elements</span>
<a name="l01299"></a>01299     <span class="keywordflow">if</span> (doDamageWeight &amp;&amp; numSegment &gt; 0) {
<a name="l01300"></a>01300       segsPerDeathVar[0] = (<a class="code" href="structFC__Subset.html">FC_Subset</a>*)malloc(numSegment*<span class="keyword">sizeof</span>(<a class="code" href="structFC__Subset.html">FC_Subset</a>));
<a name="l01301"></a>01301       segsPerDeathVar[1] = (FC_Subset*)malloc(numSegment*<span class="keyword">sizeof</span>(FC_Subset));
<a name="l01302"></a>01302       <span class="keywordflow">if</span> (!segsPerDeathVar[0] || !segsPerDeathVar[1])
<a name="l01303"></a>01303      <a class="code" href="group__ErrorHandling.html#g4a09c0024ecd45d5d63c8b9ec333a717">fc_exitIfError</a>(FC_MEMORY_ERROR);
<a name="l01304"></a>01304       <span class="keywordflow">for</span> (k = 0; k &lt; numSegment; k++) {
<a name="l01305"></a>01305      FC_Subset tempSubset, overlap;
<a name="l01306"></a>01306      rc = <a class="code" href="group__Subset.html#gdc68d18522eac86b0c3eeb655e91f80b">fc_createSubsetIntersection</a>(threshPerDeathVar[deathID], <span class="stringliteral">"AND"</span>, 
<a name="l01307"></a>01307                           segments[k], <span class="stringliteral">"deadSegment"</span>, 
<a name="l01308"></a>01308                           &amp;segsPerDeathVar[deathID][k]);
<a name="l01309"></a>01309      <a class="code" href="error_8h.html#42c09317184affa18e70826cb35f3f04">fc_exitIfErrorPrintf</a>(rc, <span class="stringliteral">"Failed to AND subsets"</span>);
<a name="l01310"></a>01310      rc = <a class="code" href="group__Subset.html#gdc68d18522eac86b0c3eeb655e91f80b">fc_createSubsetIntersection</a>(threshPerDeathVar[damageID], <span class="stringliteral">"AND"</span>,
<a name="l01311"></a>01311                       segments[k], <span class="stringliteral">"damageSegment"</span>, &amp;tempSubset);
<a name="l01312"></a>01312      <a class="code" href="error_8h.html#42c09317184affa18e70826cb35f3f04">fc_exitIfErrorPrintf</a>(rc, <span class="stringliteral">"Failed to AND subsets"</span>);
<a name="l01313"></a>01313      rc = <a class="code" href="group__Subset.html#gdc68d18522eac86b0c3eeb655e91f80b">fc_createSubsetIntersection</a>(tempSubset, <span class="stringliteral">"AND"</span>,
<a name="l01314"></a>01314                           segsPerDeathVar[deathID][k],
<a name="l01315"></a>01315                           <span class="stringliteral">"temp"</span>, &amp;overlap);
<a name="l01316"></a>01316      <a class="code" href="error_8h.html#42c09317184affa18e70826cb35f3f04">fc_exitIfErrorPrintf</a>(rc, <span class="stringliteral">"Failed to AND subsets"</span>);
<a name="l01317"></a>01317      rc = <a class="code" href="group__Subset.html#gdc68d18522eac86b0c3eeb655e91f80b">fc_createSubsetIntersection</a>(tempSubset, <span class="stringliteral">"XOR"</span>, overlap,
<a name="l01318"></a>01318                           <span class="stringliteral">"damageSegment-deadSegment"</span>,
<a name="l01319"></a>01319                           &amp;segsPerDeathVar[damageID][k]);
<a name="l01320"></a>01320      <a class="code" href="error_8h.html#42c09317184affa18e70826cb35f3f04">fc_exitIfErrorPrintf</a>(rc, <span class="stringliteral">"Failed to AND subsets"</span>);
<a name="l01321"></a>01321       }
<a name="l01322"></a>01322     }
<a name="l01323"></a>01323     <span class="keywordflow">for</span> (j = 0; j &lt; numDeathVar; j++) {
<a name="l01324"></a>01324       <a class="code" href="group__Subset.html#gfdcc399692041499cc461916a9973558">fc_deleteSubset</a>(threshPerDeathVar[j]);
<a name="l01325"></a>01325     }
<a name="l01326"></a>01326 
<a name="l01327"></a>01327     <span class="comment">// Midway report </span>
<a name="l01328"></a>01328     fprintf(output_file, <span class="stringliteral">"Mesh %d: '%s' has %d dead element region(s)"</span>, 
<a name="l01329"></a>01329          i, meshNames[i], numSegment);
<a name="l01330"></a>01330     fflush(output_file);
<a name="l01331"></a>01331 
<a name="l01332"></a>01332     <span class="comment">//do shapes here and write out as part of the midway report</span>
<a name="l01333"></a>01333     <span class="keywordflow">if</span> (useShape &amp;&amp; numSegment &gt; 0){
<a name="l01334"></a>01334       <span class="comment">//in order to check breaking, we need the innards of the shape and</span>
<a name="l01335"></a>01335       <span class="comment">//therefore have to segment first</span>
<a name="l01336"></a>01336       <span class="keywordtype">int</span> numinnards = 0;
<a name="l01337"></a>01337       <span class="keywordtype">int</span> numElem = 0;
<a name="l01338"></a>01338       <a class="code" href="structFC__Subset.html">FC_Subset</a>* innards = NULL;
<a name="l01339"></a>01339       <a class="code" href="structFC__Subset.html">FC_Subset</a> whole;
<a name="l01340"></a>01340 
<a name="l01341"></a>01341       rc = <a class="code" href="group__Mesh.html#g83a0b8188d49812c8d6d4c883cb8e9c4">fc_getMeshNumElement</a>(meshes[i],&amp;numElem);
<a name="l01342"></a>01342       <a class="code" href="error_8h.html#42c09317184affa18e70826cb35f3f04">fc_exitIfErrorPrintf</a>(rc, <span class="stringliteral">"Failed get num elem"</span>);
<a name="l01343"></a>01343 
<a name="l01344"></a>01344       rc = <a class="code" href="group__Subset.html#g40d47282abccd83987c83e8051064db2">fc_createSubset</a> (meshes[i],<span class="stringliteral">"whole"</span>, <a class="code" href="group__DataTypes.html#gg63044bd7bb5313d8a79ea8a71f1b3040f4be04f2efb0e31c558b6146cf83f191">FC_AT_ELEMENT</a>,&amp;whole);
<a name="l01345"></a>01345       <a class="code" href="error_8h.html#42c09317184affa18e70826cb35f3f04">fc_exitIfErrorPrintf</a>(rc, <span class="stringliteral">"Failed to create new subset whole"</span>);
<a name="l01346"></a>01346 
<a name="l01347"></a>01347       <span class="keywordflow">for</span> (j = 0; j &lt; numElem; j++){
<a name="l01348"></a>01348      rc = <a class="code" href="group__Subset.html#gf105b25f063533c8bdc24a6e0f1d1002">fc_addMemberToSubset</a> (whole,j);
<a name="l01349"></a>01349      <a class="code" href="error_8h.html#42c09317184affa18e70826cb35f3f04">fc_exitIfErrorPrintf</a>(rc, <span class="stringliteral">"Failed to add member to subset whole"</span>);
<a name="l01350"></a>01350       }
<a name="l01351"></a>01351 
<a name="l01352"></a>01352       rc = <a class="code" href="group__TopologyRelations.html#g7a5c5ff506dab80fe40ae60a76b3d886">fc_segment</a>(whole,shareddim,&amp;numinnards,&amp;innards);
<a name="l01353"></a>01353       <a class="code" href="group__Subset.html#gfdcc399692041499cc461916a9973558">fc_deleteSubset</a>(whole);
<a name="l01354"></a>01354       <span class="keywordflow">if</span> (rc!= <a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52e27738acee5b8b2ef61be6e9b14a26613">FC_SUCCESS</a>){
<a name="l01355"></a>01355      <a class="code" href="group__Library.html#gb41a63cb101314fb41df98cef504a556">fc_printfErrorMessage</a>(<span class="stringliteral">"Can't get shapes for mesh %d. Skipping shape calculation."</span>,i);
<a name="l01356"></a>01356      numlocalshapes = 0;
<a name="l01357"></a>01357       }<span class="keywordflow">else</span>{
<a name="l01358"></a>01358      <span class="comment">//now make each innard into a shape</span>
<a name="l01359"></a>01359      numlocalshapes = numinnards;
<a name="l01360"></a>01360 
<a name="l01361"></a>01361      localwshapes = (<a class="code" href="structshape__w__order.html">shape_w_order</a>*)malloc(numlocalshapes*<span class="keyword">sizeof</span>(<a class="code" href="structshape__w__order.html">shape_w_order</a>));
<a name="l01362"></a>01362      <span class="keywordflow">if</span> (!localwshapes){
<a name="l01363"></a>01363        <a class="code" href="group__ErrorHandling.html#g4a09c0024ecd45d5d63c8b9ec333a717">fc_exitIfError</a>(FC_MEMORY_ERROR);
<a name="l01364"></a>01364      }
<a name="l01365"></a>01365 
<a name="l01366"></a>01366      <span class="keywordflow">for</span> (j = 0; j &lt; numinnards; j++){
<a name="l01367"></a>01367        <span class="comment">//now make each innard into a separate shape w order</span>
<a name="l01368"></a>01368        <a class="code" href="structFC__Shape.html">FC_Shape</a> *singleshape;
<a name="l01369"></a>01369        <span class="keywordtype">int</span> numsingleshape;
<a name="l01370"></a>01370 
<a name="l01371"></a>01371        rc = <a class="code" href="group__Shape.html#g676c7405326649504e5c52fb700fecf4">fc_getSubsetShapes</a>(innards[j],shapeangle,shareddim,&amp;numsingleshape,&amp;singleshape);
<a name="l01372"></a>01372        <span class="keywordflow">if</span> (rc != <a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52e27738acee5b8b2ef61be6e9b14a26613">FC_SUCCESS</a>){
<a name="l01373"></a>01373          <a class="code" href="group__Library.html#gb41a63cb101314fb41df98cef504a556">fc_printfErrorMessage</a>(<span class="stringliteral">"Can't get shapes for mesh %d. Skipping shape calculation."</span>,i);
<a name="l01374"></a>01374          <span class="keywordflow">for</span> (k = 0; k &lt; numinnards; k++){
<a name="l01375"></a>01375            <a class="code" href="group__Subset.html#gfdcc399692041499cc461916a9973558">fc_deleteSubset</a>(innards[k]);
<a name="l01376"></a>01376          }
<a name="l01377"></a>01377          numinnards = 0;
<a name="l01378"></a>01378          <span class="comment">//        free(innards); will free outside</span>
<a name="l01379"></a>01379 
<a name="l01380"></a>01380          <span class="comment">//free any new shapes we already have for this mesh</span>
<a name="l01381"></a>01381          <span class="keywordflow">for</span> (k = 0; k &lt; j; k++){
<a name="l01382"></a>01382            <a class="code" href="tears_8c.html#7b51135eb869b38018913acd1dbbbe04">freeShapeWOrder</a>(&amp;localwshapes[k]);
<a name="l01383"></a>01383          }
<a name="l01384"></a>01384          free(localwshapes);
<a name="l01385"></a>01385          numlocalshapes = 0;
<a name="l01386"></a>01386        }<span class="keywordflow">else</span> <span class="keywordflow">if</span> (numsingleshape != 1){
<a name="l01387"></a>01387          <a class="code" href="group__Library.html#gb41a63cb101314fb41df98cef504a556">fc_printfErrorMessage</a>(<span class="stringliteral">"Wrong shape division for mesh %d. Skipping shape calculation."</span>,i);
<a name="l01388"></a>01388          <span class="keywordflow">for</span> (k = 0; k &lt; numinnards; k++){
<a name="l01389"></a>01389            <a class="code" href="group__Subset.html#gfdcc399692041499cc461916a9973558">fc_deleteSubset</a>(innards[k]);
<a name="l01390"></a>01390          }
<a name="l01391"></a>01391          numinnards = 0;
<a name="l01392"></a>01392          <span class="comment">//        free(innards); will free outside</span>
<a name="l01393"></a>01393          <span class="keywordflow">for</span> (k = 0; k &lt; j; k++){
<a name="l01394"></a>01394            <a class="code" href="tears_8c.html#7b51135eb869b38018913acd1dbbbe04">freeShapeWOrder</a>(&amp;localwshapes[k]);
<a name="l01395"></a>01395          }
<a name="l01396"></a>01396          free(localwshapes);
<a name="l01397"></a>01397          numlocalshapes = 0;
<a name="l01398"></a>01398        }<span class="keywordflow">else</span>{
<a name="l01399"></a>01399          <a class="code" href="tears_8c.html#e9a3eb4a592189e46815d1adfb47af68">createShapeWOrder</a>(i,j,&amp;(singleshape[0]),innards[j],&amp;(localwshapes[j]));
<a name="l01400"></a>01400          <span class="comment">//        free(singleshape);</span>
<a name="l01401"></a>01401          <span class="comment">//never delete the shapes, later wshapes will free the memory</span>
<a name="l01402"></a>01402        }
<a name="l01403"></a>01403      } <span class="comment">//each innard (shape)</span>
<a name="l01404"></a>01404      <span class="keywordflow">if</span> (innards) free(innards);
<a name="l01405"></a>01405       }
<a name="l01406"></a>01406     }
<a name="l01407"></a>01407     printf(<span class="stringliteral">"\n"</span>);
<a name="l01408"></a>01408 
<a name="l01409"></a>01409 
<a name="l01410"></a>01410     <span class="comment">// Do as much characterization as possible of tears &amp; save info</span>
<a name="l01411"></a>01411     <span class="keywordflow">if</span> (numSegment &gt; 0) {
<a name="l01412"></a>01412       <a class="code" href="structFC__Subset.html">FC_Subset</a> meshSkin;
<a name="l01413"></a>01413       FC_Variable area_or_vol, logVol;
<a name="l01414"></a>01414       FC_Variable volXdamage, logdamage, volXlogdamage, logVolXdamage;
<a name="l01415"></a>01415 
<a name="l01416"></a>01416       <span class="comment">// expand the tears array</span>
<a name="l01417"></a>01417       rc = <a class="code" href="tears_8c.html#17cf0636177357d82ea00c22873cc704">grow_tears</a>(numSegment, numTear, &amp;maxNumTear, &amp;tears);
<a name="l01418"></a>01418       <a class="code" href="error_8h.html#42c09317184affa18e70826cb35f3f04">fc_exitIfErrorPrintf</a>(rc, <span class="stringliteral">"Failed to grow tears array"</span>);
<a name="l01419"></a>01419 
<a name="l01420"></a>01420       <span class="comment">// get mesh skin</span>
<a name="l01421"></a>01421       rc = <a class="code" href="group__TopologyRelations.html#ga4961b6dfaf20254b4c72082a7c070c6">fc_getMeshSkin</a>(meshes[i], &amp;meshSkin);
<a name="l01422"></a>01422       <a class="code" href="error_8h.html#42c09317184affa18e70826cb35f3f04">fc_exitIfErrorPrintf</a>(rc, <span class="stringliteral">"Failed to get mesh skin"</span>);
<a name="l01423"></a>01423 
<a name="l01424"></a>01424       <span class="comment">// get face areas or region volumes</span>
<a name="l01425"></a>01425       <span class="keywordflow">if</span> (topoDims[i] == 2) {
<a name="l01426"></a>01426      rc = <a class="code" href="group__GeometricRelations.html#gf2bc95dcfbc5842503038dfc47e43efa">fc_getFaceAreas</a>(meshes[i], &amp;area_or_vol);
<a name="l01427"></a>01427      <a class="code" href="error_8h.html#42c09317184affa18e70826cb35f3f04">fc_exitIfErrorPrintf</a>(rc, <span class="stringliteral">"Failed to get face areas"</span>);
<a name="l01428"></a>01428       }
<a name="l01429"></a>01429       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (topoDims[i] == 3) {
<a name="l01430"></a>01430      rc = <a class="code" href="group__GeometricRelations.html#gf7687aa264403fd9234d8b1ff133a6b7">fc_getRegionVolumes</a>(meshes[i], &amp;area_or_vol);
<a name="l01431"></a>01431      <a class="code" href="error_8h.html#42c09317184affa18e70826cb35f3f04">fc_exitIfErrorPrintf</a>(rc, <span class="stringliteral">"Failed to get region volumes"</span>);
<a name="l01432"></a>01432       }
<a name="l01433"></a>01433 
<a name="l01434"></a>01434       <span class="comment">// calc variables for damage weighting</span>
<a name="l01435"></a>01435       <span class="keywordflow">if</span> (doDamageWeight) {
<a name="l01436"></a>01436      FC_Variable damage = deathVars[i][damageID][stepID];
<a name="l01437"></a>01437      rc = <a class="code" href="group__VariableMath.html#g84b3f6963472cbe8c79fe1d6c1c39640">fc_varUnaryFunction</a>(area_or_vol, log10, <span class="stringliteral">"logVol"</span>, &amp;logVol);
<a name="l01438"></a>01438      <a class="code" href="error_8h.html#42c09317184affa18e70826cb35f3f04">fc_exitIfErrorPrintf</a>(rc, <span class="stringliteral">"Failed to tak log of var"</span>);
<a name="l01439"></a>01439      rc = <a class="code" href="group__VariableMath.html#g84b3f6963472cbe8c79fe1d6c1c39640">fc_varUnaryFunction</a>(damage, log10, <span class="stringliteral">"logdamage"</span>, &amp;logdamage);
<a name="l01440"></a>01440      <a class="code" href="error_8h.html#42c09317184affa18e70826cb35f3f04">fc_exitIfErrorPrintf</a>(rc, <span class="stringliteral">"Failed to take log of var"</span>);
<a name="l01441"></a>01441      rc = <a class="code" href="group__VariableMath.html#g4bc1d027d0c58095361d5b4389a4739c">fc_varOperatorVar</a>(area_or_vol, <span class="stringliteral">"*"</span>, damage,
<a name="l01442"></a>01442                       <span class="stringliteral">"volXdamage"</span>, &amp;volXdamage);
<a name="l01443"></a>01443      <a class="code" href="error_8h.html#42c09317184affa18e70826cb35f3f04">fc_exitIfErrorPrintf</a>(rc, <span class="stringliteral">"Failed to multiply vars"</span>);
<a name="l01444"></a>01444      rc = <a class="code" href="group__VariableMath.html#g4bc1d027d0c58095361d5b4389a4739c">fc_varOperatorVar</a>(area_or_vol, <span class="stringliteral">"*"</span>, logdamage, 
<a name="l01445"></a>01445                       <span class="stringliteral">"volXlogdamage"</span>, &amp;volXlogdamage);
<a name="l01446"></a>01446      <a class="code" href="error_8h.html#42c09317184affa18e70826cb35f3f04">fc_exitIfErrorPrintf</a>(rc, <span class="stringliteral">"Failed to multipl vars"</span>);
<a name="l01447"></a>01447      rc = <a class="code" href="group__VariableMath.html#g84b3f6963472cbe8c79fe1d6c1c39640">fc_varUnaryFunction</a>(volXdamage, log10, <span class="stringliteral">"logVolXdamage"</span>,
<a name="l01448"></a>01448                      &amp;logVolXdamage);
<a name="l01449"></a>01449      <a class="code" href="error_8h.html#42c09317184affa18e70826cb35f3f04">fc_exitIfErrorPrintf</a>(rc, <span class="stringliteral">"Failed to take log of var"</span>);
<a name="l01450"></a>01450      <a class="code" href="group__Variable.html#g2f48fcbd551131488dd5757c27364656">fc_deleteVariable</a>(logdamage);
<a name="l01451"></a>01451       }
<a name="l01452"></a>01452 
<a name="l01453"></a>01453       <span class="comment">// Process each tear</span>
<a name="l01454"></a>01454       <span class="comment">// Loop over segments - each is a new tear</span>
<a name="l01455"></a>01455       <span class="keywordflow">for</span> (j = 0; j &lt; numSegment; j++) {
<a name="l01456"></a>01456      <a class="code" href="structTear.html">Tear</a> *tear = &amp;tears[numTear];
<a name="l01457"></a>01457      <a class="code" href="structTear__Characterization.html">Tear_Characterization</a> *tearData = &amp;tears[numTear].<a class="code" href="structTear.html#5aa69777439f6b2136b364628aa454de">data</a>;
<a name="l01458"></a>01458 
<a name="l01459"></a>01459      <span class="keywordtype">int</span> numExposedMember;
<a name="l01460"></a>01460 
<a name="l01461"></a>01461      <span class="comment">// basic info</span>
<a name="l01462"></a>01462      tear-&gt;tearID = numTear;
<a name="l01463"></a>01463      tear-&gt;region = segments[j];
<a name="l01464"></a>01464      tear-&gt;meshID = i;
<a name="l01465"></a>01465      tear-&gt;stepID = stepID;
<a name="l01466"></a>01466      
<a name="l01467"></a>01467      <span class="comment">// get exposed surface - the "live" part of tear</span>
<a name="l01468"></a>01468      rc = <a class="code" href="group__ElemDeath.html#ga12a54d4731f9e2a11acdd2777cd3634">fc_getExposedSkin</a>(segments[j], &amp;meshSkin, &amp;tear-&gt;exposed);
<a name="l01469"></a>01469      <a class="code" href="error_8h.html#42c09317184affa18e70826cb35f3f04">fc_exitIfErrorPrintf</a>(rc, <span class="stringliteral">"Failed to get exposed skin"</span>);
<a name="l01470"></a>01470      
<a name="l01471"></a>01471      <a class="code" href="group__Subset.html#g8b932d306fb8f41ef49677f803fd9fd1">fc_getSubsetNumMember</a>(tear-&gt;exposed, &amp;numExposedMember);
<a name="l01472"></a>01472      <span class="keywordflow">if</span> (numExposedMember &lt; 1) {
<a name="l01473"></a>01473        <a class="code" href="group__Library.html#gbf7b424a5a96a9887547a6545f03e3e2">fc_printfWarningMessage</a>(<span class="stringliteral">"There are no members in an exposed skin"</span>
<a name="l01474"></a>01474                       <span class="stringliteral">"subset; some exposed measurements are NA"</span>);
<a name="l01475"></a>01475      }
<a name="l01476"></a>01476 
<a name="l01477"></a>01477      <span class="comment">// rename the subsets for friendly output</span>
<a name="l01478"></a>01478      sprintf(name_buf, <span class="stringliteral">"region%d"</span>, numTear);
<a name="l01479"></a>01479      <a class="code" href="group__Subset.html#g5fc5615ab23de3d36bb444e3de13084f">fc_changeSubsetName</a>(tear-&gt;region, name_buf);
<a name="l01480"></a>01480      sprintf(name_buf, <span class="stringliteral">"exposed%d"</span>, numTear);
<a name="l01481"></a>01481      <a class="code" href="group__Subset.html#g5fc5615ab23de3d36bb444e3de13084f">fc_changeSubsetName</a>(tear-&gt;exposed, name_buf);
<a name="l01482"></a>01482 
<a name="l01483"></a>01483         <span class="comment">// Number of cells in region</span>
<a name="l01484"></a>01484         rc = <a class="code" href="group__Subset.html#g8b932d306fb8f41ef49677f803fd9fd1">fc_getSubsetNumMember</a>(segments[j], &amp;tearData-&gt;<a class="code" href="structTear__Characterization.html#ca099f62147f9a82c9919f327fd67aea">numCell</a>);
<a name="l01485"></a>01485         <a class="code" href="error_8h.html#42c09317184affa18e70826cb35f3f04">fc_exitIfErrorPrintf</a>(rc, <span class="stringliteral">"Failed to get number of members in region"</span>);
<a name="l01486"></a>01486         
<a name="l01487"></a>01487         <span class="comment">// area/volume of region - nondisplaced only</span>
<a name="l01488"></a>01488      rc = <a class="code" href="group__Statistics.html#g3562623371a53cba9846b576fb605433">fc_getVariableSubsetSum</a>(area_or_vol, segments[j], 
<a name="l01489"></a>01489                          &amp;tearData-&gt;<a class="code" href="structTear__Characterization.html#e650cc5f4698f94372ac1a91585d9208">volume</a>);
<a name="l01490"></a>01490      <a class="code" href="error_8h.html#42c09317184affa18e70826cb35f3f04">fc_exitIfErrorPrintf</a>(rc, <span class="stringliteral">"Failed to get area of region"</span>);
<a name="l01491"></a>01491 
<a name="l01492"></a>01492      <span class="comment">// bounding boxes</span>
<a name="l01493"></a>01493      <span class="comment">// bounding box of region - nondisplaced only</span>
<a name="l01494"></a>01494      rc = <a class="code" href="group__GeometricRelations.html#gea0c3be70612767ac91c6c9b6d9b8be2">fc_getSubsetBoundingBox</a>(segments[j], &amp;tearData-&gt;<a class="code" href="structTear__Characterization.html#55ed0d0a7177ddd23d5ae714e21273ac">numDim</a>, 
<a name="l01495"></a>01495                          &amp;tearData-&gt;<a class="code" href="structTear__Characterization.html#4aaf52496fb7f20a928001c4ef11ffbe">lowers</a>, &amp;tearData-&gt;<a class="code" href="structTear__Characterization.html#ed364768596f80ba2720b96718c7b3df">uppers</a>);
<a name="l01496"></a>01496      <a class="code" href="error_8h.html#42c09317184affa18e70826cb35f3f04">fc_exitIfErrorPrintf</a>(rc, <span class="stringliteral">"Failed to get region bounding box"</span>);
<a name="l01497"></a>01497      <span class="comment">// bounding boxes of exposed </span>
<a name="l01498"></a>01498      <span class="keywordflow">if</span> (numExposedMember &gt; 0) {
<a name="l01499"></a>01499        rc = <a class="code" href="group__GeometricRelations.html#gea0c3be70612767ac91c6c9b6d9b8be2">fc_getSubsetBoundingBox</a>(tear-&gt;exposed, &amp;tearData-&gt;<a class="code" href="structTear__Characterization.html#55ed0d0a7177ddd23d5ae714e21273ac">numDim</a>, 
<a name="l01500"></a>01500                            &amp;tearData-&gt;<a class="code" href="structTear__Characterization.html#52a54c240fe78aa458908951ecd411cb">exp_lowers</a>, 
<a name="l01501"></a>01501                            &amp;tearData-&gt;<a class="code" href="structTear__Characterization.html#64d8ff371e05aba29882a34bbd8860d7">exp_uppers</a>);
<a name="l01502"></a>01502        <a class="code" href="error_8h.html#42c09317184affa18e70826cb35f3f04">fc_exitIfErrorPrintf</a>(rc, <span class="stringliteral">"Failed to get exposed bounding box"</span>);
<a name="l01503"></a>01503        <span class="keywordflow">if</span> (doDispl) {
<a name="l01504"></a>01504          rc = <a class="code" href="group__GeometricRelations.html#gcd393977ed8c8b505edb6402ab20afa7">fc_getDisplacedSubsetBoundingBox</a>(tear-&gt;exposed,
<a name="l01505"></a>01505                   displs[i][stepID],  &amp;tearData-&gt;<a class="code" href="structTear__Characterization.html#55ed0d0a7177ddd23d5ae714e21273ac">numDim</a>, 
<a name="l01506"></a>01506                   &amp;tearData-&gt;<a class="code" href="structTear__Characterization.html#ccd5973d5d3b4e6e092fe1afcccb662a">displ_exp_lowers</a>, 
<a name="l01507"></a>01507                            &amp;tearData-&gt;<a class="code" href="structTear__Characterization.html#8b5ec177f7b36b84dfeec4637f2a10f4">displ_exp_uppers</a>);
<a name="l01508"></a>01508          <a class="code" href="error_8h.html#42c09317184affa18e70826cb35f3f04">fc_exitIfErrorPrintf</a>(rc, <span class="stringliteral">"Failed to get displaced exposed bb"</span>);
<a name="l01509"></a>01509        }
<a name="l01510"></a>01510      }
<a name="l01511"></a>01511      <span class="keywordflow">else</span> {
<a name="l01512"></a>01512        <span class="keywordflow">for</span> (k = 0; k &lt; 3; k++) {
<a name="l01513"></a>01513          tearData-&gt;<a class="code" href="structTear__Characterization.html#52a54c240fe78aa458908951ecd411cb">exp_lowers</a>[k] = -2;
<a name="l01514"></a>01514          tearData-&gt;<a class="code" href="structTear__Characterization.html#64d8ff371e05aba29882a34bbd8860d7">exp_uppers</a>[k] = -1;
<a name="l01515"></a>01515          tearData-&gt;<a class="code" href="structTear__Characterization.html#ccd5973d5d3b4e6e092fe1afcccb662a">displ_exp_lowers</a>[k] = -2;
<a name="l01516"></a>01516          tearData-&gt;<a class="code" href="structTear__Characterization.html#8b5ec177f7b36b84dfeec4637f2a10f4">displ_exp_uppers</a>[k] = -1;
<a name="l01517"></a>01517        }
<a name="l01518"></a>01518      }
<a name="l01519"></a>01519         
<a name="l01520"></a>01520      <span class="comment">// diameters</span>
<a name="l01521"></a>01521         <span class="comment">// diameter of region - nondisplaced only</span>
<a name="l01522"></a>01522         rc = <a class="code" href="group__GeometricRelations.html#g065a93ebc03ea18a0c7c25ad237f78da">fc_getSubsetDiameter</a>(segments[j], &amp;tearData-&gt;<a class="code" href="structTear__Characterization.html#3dcac12facf10a63033ab58e2bf0ad96">diameter</a>, NULL, 
<a name="l01523"></a>01523                       NULL);
<a name="l01524"></a>01524         <a class="code" href="error_8h.html#42c09317184affa18e70826cb35f3f04">fc_exitIfErrorPrintf</a>(rc, <span class="stringliteral">"Failed to get region diameter"</span>);
<a name="l01525"></a>01525      <span class="comment">// diameters of exposed</span>
<a name="l01526"></a>01526      <span class="keywordflow">if</span> (numExposedMember &gt; 0) {
<a name="l01527"></a>01527        rc = <a class="code" href="group__GeometricRelations.html#g065a93ebc03ea18a0c7c25ad237f78da">fc_getSubsetDiameter</a>(tear-&gt;exposed, &amp;tearData-&gt;<a class="code" href="structTear__Characterization.html#84bb66d1980070f669ea5fa967cc0377">exp_diameter</a>,
<a name="l01528"></a>01528                         NULL, NULL);
<a name="l01529"></a>01529        <a class="code" href="error_8h.html#42c09317184affa18e70826cb35f3f04">fc_exitIfErrorPrintf</a>(rc, <span class="stringliteral">"Failed to get exposed diameter"</span>);
<a name="l01530"></a>01530        <span class="keywordflow">if</span> (doDispl) {
<a name="l01531"></a>01531          rc = <a class="code" href="group__GeometricRelations.html#g582f174f144644a7c2e2ff22e53b8349">fc_getDisplacedSubsetDiameter</a>(tear-&gt;exposed, 
<a name="l01532"></a>01532                                 displs[i][stepID], 
<a name="l01533"></a>01533                                 &amp;tearData-&gt;<a class="code" href="structTear__Characterization.html#64cf4f755985a2ccd6db4a733eae4a2f">displ_exp_diameter</a>,
<a name="l01534"></a>01534                                 NULL, NULL);
<a name="l01535"></a>01535          <a class="code" href="error_8h.html#42c09317184affa18e70826cb35f3f04">fc_exitIfErrorPrintf</a>(rc, <span class="stringliteral">"Failed to get displaced exposed diameter"</span>);
<a name="l01536"></a>01536        }
<a name="l01537"></a>01537      }
<a name="l01538"></a>01538      <span class="keywordflow">else</span> {
<a name="l01539"></a>01539        tearData-&gt;<a class="code" href="structTear__Characterization.html#84bb66d1980070f669ea5fa967cc0377">exp_diameter</a> = -1;
<a name="l01540"></a>01540        tearData-&gt;<a class="code" href="structTear__Characterization.html#64cf4f755985a2ccd6db4a733eae4a2f">displ_exp_diameter</a> = -1;
<a name="l01541"></a>01541      }
<a name="l01542"></a>01542      
<a name="l01543"></a>01543      <span class="comment">// damage weighted volumes</span>
<a name="l01544"></a>01544      <span class="keywordflow">if</span> (doDamageWeight) {
<a name="l01545"></a>01545        <a class="code" href="structFC__Subset.html">FC_Subset</a> deadSubset = segsPerDeathVar[deathID][j];
<a name="l01546"></a>01546        <a class="code" href="structFC__Subset.html">FC_Subset</a> damageSubset = segsPerDeathVar[damageID][j];
<a name="l01547"></a>01547        <a class="code" href="group__Subset.html#g8b932d306fb8f41ef49677f803fd9fd1">fc_getSubsetNumMember</a>(deadSubset, &amp;tearData-&gt;<a class="code" href="structTear__Characterization.html#81d5650d0b8647e489d34391c5908ea1">dead_numCell</a>);
<a name="l01548"></a>01548        <a class="code" href="group__Subset.html#g8b932d306fb8f41ef49677f803fd9fd1">fc_getSubsetNumMember</a>(damageSubset, &amp;tearData-&gt;<a class="code" href="structTear__Characterization.html#d7ba9673f47f5b64e26f9069feea2164">damaged_numCell</a>);
<a name="l01549"></a>01549        <span class="keywordflow">if</span> (tearData-&gt;<a class="code" href="structTear__Characterization.html#81d5650d0b8647e489d34391c5908ea1">dead_numCell</a> &lt; 1) {
<a name="l01550"></a>01550          tearData-&gt;<a class="code" href="structTear__Characterization.html#ddb6062312d4738e29a7703f6266f103">dead_vol</a> = 0;
<a name="l01551"></a>01551          tearData-&gt;<a class="code" href="structTear__Characterization.html#83052feab2c05ff60265124170c6da42">dead_logvol</a> = 0;
<a name="l01552"></a>01552        }
<a name="l01553"></a>01553        <span class="keywordflow">else</span> {
<a name="l01554"></a>01554          rc = <a class="code" href="group__Statistics.html#g3562623371a53cba9846b576fb605433">fc_getVariableSubsetSum</a>(area_or_vol, deadSubset,
<a name="l01555"></a>01555                           &amp;tearData-&gt;<a class="code" href="structTear__Characterization.html#ddb6062312d4738e29a7703f6266f103">dead_vol</a>); 
<a name="l01556"></a>01556          <a class="code" href="error_8h.html#42c09317184affa18e70826cb35f3f04">fc_exitIfErrorPrintf</a>(rc, <span class="stringliteral">"Failed to get volume of dead part of tear"</span>);
<a name="l01557"></a>01557          rc = <a class="code" href="group__Statistics.html#g3562623371a53cba9846b576fb605433">fc_getVariableSubsetSum</a>(logVol, deadSubset,
<a name="l01558"></a>01558                           &amp;tearData-&gt;<a class="code" href="structTear__Characterization.html#83052feab2c05ff60265124170c6da42">dead_logvol</a>);
<a name="l01559"></a>01559          <a class="code" href="error_8h.html#42c09317184affa18e70826cb35f3f04">fc_exitIfErrorPrintf</a>(rc, <span class="stringliteral">"Failed to get sum of log dead vol"</span>);
<a name="l01560"></a>01560        }
<a name="l01561"></a>01561        <span class="keywordflow">if</span> (tearData-&gt;<a class="code" href="structTear__Characterization.html#d7ba9673f47f5b64e26f9069feea2164">damaged_numCell</a> &lt; 1) {
<a name="l01562"></a>01562          tearData-&gt;<a class="code" href="structTear__Characterization.html#45526cd884223a0323c79cec9b4a55b1">damaged_vol</a> = 0;
<a name="l01563"></a>01563          tearData-&gt;<a class="code" href="structTear__Characterization.html#b8f85a6d397843bcab7a3abd8f8249bf">damaged_vol_x_damage</a> = 0;
<a name="l01564"></a>01564          tearData-&gt;<a class="code" href="structTear__Characterization.html#f9a5382459e892efdcbaac28ebae1acc">damaged_vol_x_logdamage</a> = 0;
<a name="l01565"></a>01565          tearData-&gt;<a class="code" href="structTear__Characterization.html#8a2dd6b40b03853643fe3f8483b5407c">damaged_log_vol_x_damage</a> = 0;
<a name="l01566"></a>01566        }
<a name="l01567"></a>01567        <span class="keywordflow">else</span> {
<a name="l01568"></a>01568          rc = <a class="code" href="group__Statistics.html#g3562623371a53cba9846b576fb605433">fc_getVariableSubsetSum</a>(area_or_vol, damageSubset,
<a name="l01569"></a>01569                           &amp;tearData-&gt;<a class="code" href="structTear__Characterization.html#45526cd884223a0323c79cec9b4a55b1">damaged_vol</a>);
<a name="l01570"></a>01570          <a class="code" href="error_8h.html#42c09317184affa18e70826cb35f3f04">fc_exitIfErrorPrintf</a>(rc, <span class="stringliteral">"Failed to get volume of damage"</span>);
<a name="l01571"></a>01571          rc = <a class="code" href="group__Statistics.html#g3562623371a53cba9846b576fb605433">fc_getVariableSubsetSum</a>(volXdamage, damageSubset,
<a name="l01572"></a>01572                           &amp;tearData-&gt;<a class="code" href="structTear__Characterization.html#b8f85a6d397843bcab7a3abd8f8249bf">damaged_vol_x_damage</a>); 
<a name="l01573"></a>01573          <a class="code" href="error_8h.html#42c09317184affa18e70826cb35f3f04">fc_exitIfErrorPrintf</a>(rc, <span class="stringliteral">"Failed to get sum of vol x damage"</span>);
<a name="l01574"></a>01574          rc = <a class="code" href="group__Statistics.html#g3562623371a53cba9846b576fb605433">fc_getVariableSubsetSum</a>(volXlogdamage, damageSubset,
<a name="l01575"></a>01575                           &amp;tearData-&gt;<a class="code" href="structTear__Characterization.html#f9a5382459e892efdcbaac28ebae1acc">damaged_vol_x_logdamage</a>);
<a name="l01576"></a>01576          <a class="code" href="error_8h.html#42c09317184affa18e70826cb35f3f04">fc_exitIfErrorPrintf</a>(rc, <span class="stringliteral">"Failed to get sum of vol x logdamage"</span>);
<a name="l01577"></a>01577          rc = <a class="code" href="group__Statistics.html#g3562623371a53cba9846b576fb605433">fc_getVariableSubsetSum</a>(logVolXdamage,damageSubset,
<a name="l01578"></a>01578                           &amp;tearData-&gt;<a class="code" href="structTear__Characterization.html#8a2dd6b40b03853643fe3f8483b5407c">damaged_log_vol_x_damage</a>);
<a name="l01579"></a>01579          <a class="code" href="error_8h.html#42c09317184affa18e70826cb35f3f04">fc_exitIfErrorPrintf</a>(rc, <span class="stringliteral">"Failed to get sum of log (vol x damage)"</span>);
<a name="l01580"></a>01580        }
<a name="l01581"></a>01581      }
<a name="l01582"></a>01582 
<a name="l01583"></a>01583      <span class="comment">//will return null shape_intersection to the tear if no shapes</span>
<a name="l01584"></a>01584      rc = <a class="code" href="tears_8c.html#6aa4dad5ac93c6d9eb24fe34808f0b29">calcShapeIntersection</a>(numlocalshapes,localwshapes,shareddim,tear);
<a name="l01585"></a>01585 
<a name="l01586"></a>01586      <span class="comment">// done with this tear</span>
<a name="l01587"></a>01587      numTear++;
<a name="l01588"></a>01588       }
<a name="l01589"></a>01589 
<a name="l01590"></a>01590       <span class="comment">//add only the orders to the order array,</span>
<a name="l01591"></a>01591       <span class="comment">//get rid of the shapes. </span>
<a name="l01592"></a>01592       rc = <a class="code" href="tears_8c.html#5776ceee8c0a3cdf15c2c4282d10476e">grow_orders</a>(numlocalshapes, numShapes,
<a name="l01593"></a>01593                  &amp;maxNumShapes, &amp;shapeorder);
<a name="l01594"></a>01594 
<a name="l01595"></a>01595       <span class="keywordflow">for</span> (j = 0; j &lt; numlocalshapes; j++){
<a name="l01596"></a>01596      shapeorder[numShapes+j] = localwshapes[j].order;
<a name="l01597"></a>01597      <a class="code" href="tears_8c.html#f3ddc0f4d5816c1b1f731ede54fa1e1a">freeShapeWOrder_ShapeOnly</a>(&amp;(localwshapes[j])); <span class="comment">//frees the localshape</span>
<a name="l01598"></a>01598      localwshapes[j].<a class="code" href="structshape__w__order.html#06e56d16cbd39b8cbb629e350cf34579">order</a> = NULL;
<a name="l01599"></a>01599       }
<a name="l01600"></a>01600       numShapes+=numlocalshapes;
<a name="l01601"></a>01601       <span class="keywordflow">if</span> (localwshapes)  free(localwshapes); <span class="comment">//free the array</span>
<a name="l01602"></a>01602 
<a name="l01603"></a>01603       <span class="comment">// cleanup</span>
<a name="l01604"></a>01604       <a class="code" href="group__Subset.html#gfdcc399692041499cc461916a9973558">fc_deleteSubset</a>(meshSkin);
<a name="l01605"></a>01605       <a class="code" href="group__Variable.html#g2f48fcbd551131488dd5757c27364656">fc_deleteVariable</a>(area_or_vol);
<a name="l01606"></a>01606       free(segments);
<a name="l01607"></a>01607       <span class="keywordflow">if</span> (doDamageWeight) {
<a name="l01608"></a>01608      free(segsPerDeathVar[deathID]);
<a name="l01609"></a>01609      free(segsPerDeathVar[damageID]);
<a name="l01610"></a>01610      <a class="code" href="group__Variable.html#g2f48fcbd551131488dd5757c27364656">fc_deleteVariable</a>(logVol);
<a name="l01611"></a>01611      <a class="code" href="group__Variable.html#g2f48fcbd551131488dd5757c27364656">fc_deleteVariable</a>(volXdamage);
<a name="l01612"></a>01612      <a class="code" href="group__Variable.html#g2f48fcbd551131488dd5757c27364656">fc_deleteVariable</a>(volXlogdamage);
<a name="l01613"></a>01613      <a class="code" href="group__Variable.html#g2f48fcbd551131488dd5757c27364656">fc_deleteVariable</a>(logVolXdamage);
<a name="l01614"></a>01614       }
<a name="l01615"></a>01615     } <span class="comment">//if numSegment &gt; 0</span>
<a name="l01616"></a>01616 
<a name="l01617"></a>01617     <span class="comment">// get rid of extra data structures on meshes, maybe delete!</span>
<a name="l01618"></a>01618     <span class="keywordflow">if</span> (numSegment == 0)
<a name="l01619"></a>01619       <a class="code" href="group__Mesh.html#gc3572be7c4803b339a6110f2c3980e8e">fc_deleteMesh</a>(meshes[i]);
<a name="l01620"></a>01620     <span class="keywordflow">else</span>
<a name="l01621"></a>01621       <a class="code" href="group__Mesh.html#g794ab95c549f52f5a7ae932ff450923b">fc_releaseMesh</a>(meshes[i]);
<a name="l01622"></a>01622   }
<a name="l01623"></a>01623   <span class="keywordflow">for</span> (i = 0; i &lt; numMesh; i++) {
<a name="l01624"></a>01624     <span class="keywordflow">for</span> (j = 0; j &lt; numDeathVar; j++)
<a name="l01625"></a>01625       free(deathVars[i][j]);
<a name="l01626"></a>01626     free(deathVars[i]);
<a name="l01627"></a>01627   }
<a name="l01628"></a>01628   free(deathVars);
<a name="l01629"></a>01629   free(meshes);
<a name="l01630"></a>01630 
<a name="l01631"></a>01631   <span class="comment">// Report how many tears found</span>
<a name="l01632"></a>01632   <span class="comment">// Early exit: if no tears, we're done</span>
<a name="l01633"></a>01633   <span class="keywordflow">if</span> (numTear == 0) {
<a name="l01634"></a>01634     fprintf(output_file, <span class="stringliteral">"No tears found\n"</span>);
<a name="l01635"></a>01635     <span class="keywordflow">if</span> (output_file_name)
<a name="l01636"></a>01636       fclose(output_file);
<a name="l01637"></a>01637     <a class="code" href="group__Library.html#g68cec1422dde03b636cf039faafa7baa">fc_finalLibrary</a>();
<a name="l01638"></a>01638     exit(0);
<a name="l01639"></a>01639   }
<a name="l01640"></a>01640   <span class="keywordflow">else</span> {
<a name="l01641"></a>01641     fprintf(output_file, <span class="stringliteral">"Found %d dead element regions\n"</span>, numTear);
<a name="l01642"></a>01642     fflush(NULL);
<a name="l01643"></a>01643   }
<a name="l01644"></a>01644 
<a name="l01645"></a>01645   <span class="comment">// --- Combine tears (if requested)</span>
<a name="l01646"></a>01646 
<a name="l01647"></a>01647   <span class="comment">// NOTE: whether combining or not, will convert from Tear to SuperTear type</span>
<a name="l01648"></a>01648   <span class="keywordflow">if</span> (!doCombine) {
<a name="l01649"></a>01649     <span class="comment">// report that we are combining</span>
<a name="l01650"></a>01650     fprintf(output_file, <span class="stringliteral">"Combining of dead elem regions not requested\n"</span>);
<a name="l01651"></a>01651     fflush(NULL);
<a name="l01652"></a>01652 
<a name="l01653"></a>01653     numSuperTear = numTear;
<a name="l01654"></a>01654     superTears = (<a class="code" href="structSuperTear.html">SuperTear</a>*)malloc(numTear*<span class="keyword">sizeof</span>(<a class="code" href="structSuperTear.html">SuperTear</a>));
<a name="l01655"></a>01655     <span class="keywordflow">for</span> (i = 0; i &lt; numTear; i++) {
<a name="l01656"></a>01656       superTears[i].tearID = tears[i].tearID;
<a name="l01657"></a>01657       superTears[i].<a class="code" href="structSuperTear.html#ff22693a55db8a8d5a1d95dfd92c468a">numTear</a> = 1;
<a name="l01658"></a>01658       superTears[i].<a class="code" href="structSuperTear.html#e7bd683083da627b7b495e249feb29c8">tears</a> = (<a class="code" href="structTear.html">Tear</a>**)malloc(<span class="keyword">sizeof</span>(<a class="code" href="structTear.html">Tear</a>*));
<a name="l01659"></a>01659       superTears[i].<a class="code" href="structSuperTear.html#e7bd683083da627b7b495e249feb29c8">tears</a>[0] = &amp;tears[i];
<a name="l01660"></a>01660     }
<a name="l01661"></a>01661   }
<a name="l01662"></a>01662   <span class="keywordflow">else</span> {
<a name="l01663"></a>01663     <span class="comment">// NOTE: this is done with time zero geometry</span>
<a name="l01664"></a>01664     <span class="keywordtype">int</span>** proxMatrix;
<a name="l01665"></a>01665     <span class="keywordtype">int</span>* numPerGroup, **idsPerGroup, numGroup, count;
<a name="l01666"></a>01666 
<a name="l01667"></a>01667     <span class="comment">// report that we are combining</span>
<a name="l01668"></a>01668     fprintf(output_file, <span class="stringliteral">"Combining dead elem regions that have verts "</span>
<a name="l01669"></a>01669          <span class="stringliteral">"within '%g' of each other ...\n"</span>, min_dist);
<a name="l01670"></a>01670     fflush(NULL);
<a name="l01671"></a>01671          
<a name="l01672"></a>01672     proxMatrix = (<span class="keywordtype">int</span>**)malloc(numTear*<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>*));
<a name="l01673"></a>01673     <span class="keywordflow">for</span> (i = 0; i &lt; numTear; i++) 
<a name="l01674"></a>01674       proxMatrix[i] = (<span class="keywordtype">int</span>*)malloc(numTear*<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
<a name="l01675"></a>01675     <span class="comment">// get the numPairs (proxities) - store in matrix </span>
<a name="l01676"></a>01676     <span class="comment">// FIX? is next thing what we really want to do?</span>
<a name="l01677"></a>01677     <span class="comment">// Don't test if on same mesh, that was already done with segment!</span>
<a name="l01678"></a>01678     <span class="keywordflow">for</span> (i = 0; i &lt; numTear; i++) {
<a name="l01679"></a>01679       <span class="keywordflow">for</span> (j = i+1; j &lt; numTear; j++) {
<a name="l01680"></a>01680      <span class="keywordflow">if</span> (tears[i].meshID == tears[j].meshID)
<a name="l01681"></a>01681        proxMatrix[i][j] = 0;
<a name="l01682"></a>01682      <span class="keywordflow">else</span> {
<a name="l01683"></a>01683        rc = <a class="code" href="group__GeometricRelations.html#g29e5532aa97ec9d43456579e8e1b26ea">fc_getSubsetsProximity</a>(tears[i].region, tears[j].region, 
<a name="l01684"></a>01684                           min_dist, &amp;proxMatrix[i][j], NULL, NULL);
<a name="l01685"></a>01685        <a class="code" href="error_8h.html#42c09317184affa18e70826cb35f3f04">fc_exitIfErrorPrintf</a>(rc, <span class="stringliteral">"failed to get subsets' proximity"</span>);
<a name="l01686"></a>01686      }
<a name="l01687"></a>01687       }
<a name="l01688"></a>01688     }
<a name="l01689"></a>01689 
<a name="l01690"></a>01690     <span class="comment">// debug - look at matrix</span>
<a name="l01691"></a>01691     <span class="comment">/* </span>
<a name="l01692"></a>01692 <span class="comment">    printf("ProxMatrix\n");</span>
<a name="l01693"></a>01693 <span class="comment">    printf("     ");</span>
<a name="l01694"></a>01694 <span class="comment">    for (i = 0; i &lt; numTear; i++)</span>
<a name="l01695"></a>01695 <span class="comment">      printf("%3d ", i);</span>
<a name="l01696"></a>01696 <span class="comment">    printf("\n");</span>
<a name="l01697"></a>01697 <span class="comment">    printf("-----");</span>
<a name="l01698"></a>01698 <span class="comment">    for (i = 0; i &lt; numTear; i++)</span>
<a name="l01699"></a>01699 <span class="comment">      printf("----");</span>
<a name="l01700"></a>01700 <span class="comment">    printf("\n");</span>
<a name="l01701"></a>01701 <span class="comment">    for (i = 0; i &lt; numTear; i++) {</span>
<a name="l01702"></a>01702 <span class="comment">      printf("%3d: ", i);</span>
<a name="l01703"></a>01703 <span class="comment">      for (j = 0; j &lt; numTear; j++) {</span>
<a name="l01704"></a>01704 <span class="comment">     if (j &lt;= i)</span>
<a name="l01705"></a>01705 <span class="comment">       printf("%3s ", "-");</span>
<a name="l01706"></a>01706 <span class="comment">     else</span>
<a name="l01707"></a>01707 <span class="comment">       printf("%3d ", proxMatrix[i][j]);</span>
<a name="l01708"></a>01708 <span class="comment">      }</span>
<a name="l01709"></a>01709 <span class="comment">      printf("\n");</span>
<a name="l01710"></a>01710 <span class="comment">    }</span>
<a name="l01711"></a>01711 <span class="comment">    */</span>
<a name="l01712"></a>01712 
<a name="l01713"></a>01713     <span class="comment">// determine groups</span>
<a name="l01714"></a>01714     rc = <a class="code" href="group__FeatureTracking.html#gb2dfac72059a09c26bf3479904659568">fc_groupSelfCorrespond</a>(numTear, proxMatrix, &amp;numGroup,
<a name="l01715"></a>01715                     &amp;numPerGroup, &amp;idsPerGroup);
<a name="l01716"></a>01716     <a class="code" href="error_8h.html#42c09317184affa18e70826cb35f3f04">fc_exitIfErrorPrintf</a>(rc, <span class="stringliteral">"failed to group by proximity"</span>);
<a name="l01717"></a>01717     <span class="keywordflow">for</span> (i = 0; i &lt; numTear; i++)
<a name="l01718"></a>01718       free(proxMatrix[i]);
<a name="l01719"></a>01719     free(proxMatrix);
<a name="l01720"></a>01720 
<a name="l01721"></a>01721     <span class="comment">// make the super tears </span>
<a name="l01722"></a>01722     superTears = malloc(numGroup*<span class="keyword">sizeof</span>(<a class="code" href="structSuperTear.html">SuperTear</a>));
<a name="l01723"></a>01723     numSuperTear = 0;
<a name="l01724"></a>01724     count = 0; <span class="comment">// for a quick check</span>
<a name="l01725"></a>01725     <span class="keywordflow">for</span> (i = 0; i &lt; numGroup; i++) {
<a name="l01726"></a>01726       superTears[numSuperTear].tearID = numSuperTear;
<a name="l01727"></a>01727       superTears[numSuperTear].<a class="code" href="structSuperTear.html#ff22693a55db8a8d5a1d95dfd92c468a">numTear</a> = numPerGroup[i];
<a name="l01728"></a>01728       count += numPerGroup[i];
<a name="l01729"></a>01729       superTears[numSuperTear].<a class="code" href="structSuperTear.html#e7bd683083da627b7b495e249feb29c8">tears</a> = malloc(numPerGroup[i]*<span class="keyword">sizeof</span>(<a class="code" href="structTear.html">Tear</a>*));
<a name="l01730"></a>01730       <span class="keywordflow">for</span> (j = 0; j &lt; numPerGroup[i]; j++)
<a name="l01731"></a>01731      superTears[numSuperTear].tears[j] = &amp;tears[idsPerGroup[i][j]];
<a name="l01732"></a>01732       numSuperTear++;
<a name="l01733"></a>01733       free(idsPerGroup[i]);
<a name="l01734"></a>01734     }
<a name="l01735"></a>01735     free(numPerGroup);
<a name="l01736"></a>01736     free(idsPerGroup);
<a name="l01737"></a>01737     <span class="keywordflow">if</span> (count != numTear) 
<a name="l01738"></a>01738       fprintf(output_file, 
<a name="l01739"></a>01739            <span class="stringliteral">"WARNING! Algorithm error. Please report to FCLib developers.\n"</span>
<a name="l01740"></a>01740            <span class="stringliteral">"WARNING! Total number of tears in groups (%d) does not match\n"</span>
<a name="l01741"></a>01741            <span class="stringliteral">"WARNING! original number of tears(%d)\n"</span>, count, numTear);
<a name="l01742"></a>01742   }
<a name="l01743"></a>01743 
<a name="l01744"></a>01744   <span class="comment">// report number of super tear tears</span>
<a name="l01745"></a>01745   fprintf(output_file, <span class="stringliteral">"Found %d tears\n"</span>, numSuperTear);
<a name="l01746"></a>01746   fflush(NULL);
<a name="l01747"></a>01747 
<a name="l01748"></a>01748   <span class="comment">// --- Create data for the super tears</span>
<a name="l01749"></a>01749 
<a name="l01750"></a>01750   <span class="comment">// create data for the super tears</span>
<a name="l01751"></a>01751   <span class="keywordflow">for</span> (i = 0; i &lt; numSuperTear; i++) {
<a name="l01752"></a>01752     <span class="keywordtype">int</span> numDim;
<a name="l01753"></a>01753     <a class="code" href="group__SimpleDataObjects.html#g9687c6aad22d56c60f87659f533869c2">FC_Coords</a> temp_lowers, temp_uppers;
<a name="l01754"></a>01754     <a class="code" href="structTear__Characterization.html">Tear_Characterization</a> *superTearData;
<a name="l01755"></a>01755 
<a name="l01756"></a>01756     <span class="comment">// copy 1st tear's data -- if numTear = 1, we are done</span>
<a name="l01757"></a>01757     superTears[i].<a class="code" href="structSuperTear.html#011937f2c2e78f268ec587d0a737c0f8">data</a> = superTears[i].<a class="code" href="structSuperTear.html#e7bd683083da627b7b495e249feb29c8">tears</a>[0]-&gt;<a class="code" href="structTear.html#5aa69777439f6b2136b364628aa454de">data</a>;
<a name="l01758"></a>01758     <span class="keywordflow">if</span> (superTears[i].numTear == 1)
<a name="l01759"></a>01759       <span class="keywordflow">continue</span>;
<a name="l01760"></a>01760 
<a name="l01761"></a>01761     <span class="comment">// shortcuts for following work</span>
<a name="l01762"></a>01762     numDim = superTears[i].<a class="code" href="structSuperTear.html#011937f2c2e78f268ec587d0a737c0f8">data</a>.<a class="code" href="structTear__Characterization.html#55ed0d0a7177ddd23d5ae714e21273ac">numDim</a>;
<a name="l01763"></a>01763     superTearData = &amp;superTears[i].<a class="code" href="structSuperTear.html#011937f2c2e78f268ec587d0a737c0f8">data</a>;
<a name="l01764"></a>01764 
<a name="l01765"></a>01765     <span class="comment">// for some quantities, can just add other tears' data</span>
<a name="l01766"></a>01766     <span class="keywordflow">for</span> (j = 1; j &lt; superTears[i].<a class="code" href="structSuperTear.html#ff22693a55db8a8d5a1d95dfd92c468a">numTear</a>; j++) {
<a name="l01767"></a>01767       <a class="code" href="structTear__Characterization.html">Tear_Characterization</a> *tearData = &amp;superTears[i].tears[j]-&gt;data;
<a name="l01768"></a>01768       superTearData-&gt;<a class="code" href="structTear__Characterization.html#ca099f62147f9a82c9919f327fd67aea">numCell</a> += tearData-&gt;numCell;
<a name="l01769"></a>01769       superTearData-&gt;<a class="code" href="structTear__Characterization.html#e650cc5f4698f94372ac1a91585d9208">volume</a> += tearData-&gt;volume;
<a name="l01770"></a>01770       <span class="keywordflow">for</span> (k = 0; k &lt; numDim; k++) {
<a name="l01771"></a>01771      temp_lowers[k] = superTearData-&gt;<a class="code" href="structTear__Characterization.html#4aaf52496fb7f20a928001c4ef11ffbe">lowers</a>[k];
<a name="l01772"></a>01772      temp_uppers[k] = superTearData-&gt;<a class="code" href="structTear__Characterization.html#ed364768596f80ba2720b96718c7b3df">uppers</a>[k];
<a name="l01773"></a>01773       }
<a name="l01774"></a>01774       <a class="code" href="group__GeometricRelations.html#gf5cb2b10ac399d18fa138f8206083190">fc_combineBoundingBoxes</a>(numDim, temp_lowers, temp_uppers,
<a name="l01775"></a>01775                      tearData-&gt;lowers, tearData-&gt;uppers,
<a name="l01776"></a>01776                      &amp;superTearData-&gt;<a class="code" href="structTear__Characterization.html#4aaf52496fb7f20a928001c4ef11ffbe">lowers</a>,
<a name="l01777"></a>01777                      &amp;superTearData-&gt;<a class="code" href="structTear__Characterization.html#ed364768596f80ba2720b96718c7b3df">uppers</a>);
<a name="l01778"></a>01778       <span class="keywordflow">for</span> (k = 0; k &lt; numDim; k++) {
<a name="l01779"></a>01779      temp_lowers[k] = superTearData-&gt;<a class="code" href="structTear__Characterization.html#52a54c240fe78aa458908951ecd411cb">exp_lowers</a>[k];
<a name="l01780"></a>01780      temp_uppers[k] = superTearData-&gt;<a class="code" href="structTear__Characterization.html#64d8ff371e05aba29882a34bbd8860d7">exp_uppers</a>[k];
<a name="l01781"></a>01781       }
<a name="l01782"></a>01782       <a class="code" href="group__GeometricRelations.html#gf5cb2b10ac399d18fa138f8206083190">fc_combineBoundingBoxes</a>(numDim, temp_lowers, temp_uppers,
<a name="l01783"></a>01783                      tearData-&gt;exp_lowers, tearData-&gt;exp_uppers,
<a name="l01784"></a>01784                      &amp;superTearData-&gt;<a class="code" href="structTear__Characterization.html#52a54c240fe78aa458908951ecd411cb">exp_lowers</a>,
<a name="l01785"></a>01785                      &amp;superTearData-&gt;<a class="code" href="structTear__Characterization.html#64d8ff371e05aba29882a34bbd8860d7">exp_uppers</a>);
<a name="l01786"></a>01786       <span class="keywordflow">if</span> (doDispl) {
<a name="l01787"></a>01787      <span class="keywordflow">for</span> (k = 0; k &lt; numDim; k++) {
<a name="l01788"></a>01788        temp_lowers[k] = superTearData-&gt;<a class="code" href="structTear__Characterization.html#ccd5973d5d3b4e6e092fe1afcccb662a">displ_exp_lowers</a>[k];
<a name="l01789"></a>01789        temp_uppers[k] = superTearData-&gt;<a class="code" href="structTear__Characterization.html#8b5ec177f7b36b84dfeec4637f2a10f4">displ_exp_uppers</a>[k];
<a name="l01790"></a>01790      }
<a name="l01791"></a>01791      <a class="code" href="group__GeometricRelations.html#gf5cb2b10ac399d18fa138f8206083190">fc_combineBoundingBoxes</a>(numDim, temp_lowers, temp_uppers,
<a name="l01792"></a>01792                     tearData-&gt;displ_exp_lowers,
<a name="l01793"></a>01793                     tearData-&gt;displ_exp_uppers,
<a name="l01794"></a>01794                     &amp;superTearData-&gt;<a class="code" href="structTear__Characterization.html#ccd5973d5d3b4e6e092fe1afcccb662a">displ_exp_lowers</a>,
<a name="l01795"></a>01795                     &amp;superTearData-&gt;<a class="code" href="structTear__Characterization.html#8b5ec177f7b36b84dfeec4637f2a10f4">displ_exp_uppers</a>);
<a name="l01796"></a>01796       }
<a name="l01797"></a>01797       <span class="keywordflow">if</span> (doDamageWeight) {
<a name="l01798"></a>01798      superTearData-&gt;<a class="code" href="structTear__Characterization.html#81d5650d0b8647e489d34391c5908ea1">dead_numCell</a> += tearData-&gt;dead_numCell;
<a name="l01799"></a>01799      superTearData-&gt;<a class="code" href="structTear__Characterization.html#d7ba9673f47f5b64e26f9069feea2164">damaged_numCell</a> += tearData-&gt;damaged_numCell;
<a name="l01800"></a>01800      superTearData-&gt;<a class="code" href="structTear__Characterization.html#ddb6062312d4738e29a7703f6266f103">dead_vol</a> += tearData-&gt;dead_vol;
<a name="l01801"></a>01801      superTearData-&gt;<a class="code" href="structTear__Characterization.html#83052feab2c05ff60265124170c6da42">dead_logvol</a> += tearData-&gt;dead_logvol;
<a name="l01802"></a>01802      superTearData-&gt;<a class="code" href="structTear__Characterization.html#45526cd884223a0323c79cec9b4a55b1">damaged_vol</a> += tearData-&gt;damaged_vol;
<a name="l01803"></a>01803      superTearData-&gt;<a class="code" href="structTear__Characterization.html#b8f85a6d397843bcab7a3abd8f8249bf">damaged_vol_x_damage</a> += tearData-&gt;damaged_vol_x_damage;
<a name="l01804"></a>01804      superTearData-&gt;<a class="code" href="structTear__Characterization.html#f9a5382459e892efdcbaac28ebae1acc">damaged_vol_x_logdamage</a> += tearData-&gt;damaged_vol_x_logdamage;
<a name="l01805"></a>01805      superTearData-&gt;<a class="code" href="structTear__Characterization.html#8a2dd6b40b03853643fe3f8483b5407c">damaged_log_vol_x_damage</a> += tearData-&gt;damaged_log_vol_x_damage;
<a name="l01806"></a>01806       }
<a name="l01807"></a>01807     }
<a name="l01808"></a>01808     <span class="comment">// for some quantities, have to recalculate using all tears</span>
<a name="l01809"></a>01809     <span class="keywordflow">if</span> (superTears[i].numTear &gt; 1) {
<a name="l01810"></a>01810       <span class="keywordtype">int</span> exposedsExist = 1;
<a name="l01811"></a>01811       <a class="code" href="structFC__Subset.html">FC_Subset</a> tear_regions[superTears[i].<a class="code" href="structSuperTear.html#ff22693a55db8a8d5a1d95dfd92c468a">numTear</a>];
<a name="l01812"></a>01812       <a class="code" href="structFC__Subset.html">FC_Subset</a> tear_exposeds[superTears[i].numTear];
<a name="l01813"></a>01813       FC_Variable tear_displs[superTears[i].numTear];
<a name="l01814"></a>01814       <span class="keywordflow">for</span> (j = 0; j &lt; superTears[i].numTear; j++) {
<a name="l01815"></a>01815      <span class="keywordflow">if</span> (<a class="code" href="group__Handles.html#gf1de8e9eed3c2f3c7ffcaa6527fe0adf">FC_HANDLE_EQUIV</a>(superTears[i].tears[j]-&gt;exposed, <a class="code" href="group__Handles.html#g05b02ab7a13c2ad72dd9a0862fc11356">FC_NULL_SUBSET</a>)) {
<a name="l01816"></a>01816        exposedsExist = 0;
<a name="l01817"></a>01817        <span class="keywordflow">break</span>;
<a name="l01818"></a>01818      }
<a name="l01819"></a>01819       }
<a name="l01820"></a>01820       <span class="keywordflow">for</span> (j = 0; j &lt; superTears[i].numTear; j++) {
<a name="l01821"></a>01821      <a class="code" href="structTear.html">Tear</a>* tear = superTears[i].tears[j];
<a name="l01822"></a>01822      tear_regions[j] = tear-&gt;<a class="code" href="structTear.html#b0b90312db96465819df33a2dfaa2c9c">region</a>;
<a name="l01823"></a>01823      tear_exposeds[j] = tear-&gt;exposed;
<a name="l01824"></a>01824      <span class="keywordflow">if</span> (doDispl)
<a name="l01825"></a>01825        tear_displs[j] = displs[tear-&gt;meshID][tear-&gt;stepID];
<a name="l01826"></a>01826       }
<a name="l01827"></a>01827       rc = <a class="code" href="group__GeometricRelations.html#gc6a90cc1b35e9acb6c94c2857b11e730">fc_getSubsetsDiameter</a>(superTears[i].numTear, tear_regions,
<a name="l01828"></a>01828                      &amp;superTearData-&gt;<a class="code" href="structTear__Characterization.html#3dcac12facf10a63033ab58e2bf0ad96">diameter</a>, NULL, NULL, NULL);
<a name="l01829"></a>01829       <span class="keywordflow">if</span> (exposedsExist) {
<a name="l01830"></a>01830      rc = <a class="code" href="group__GeometricRelations.html#gc6a90cc1b35e9acb6c94c2857b11e730">fc_getSubsetsDiameter</a>(superTears[i].numTear, tear_exposeds,
<a name="l01831"></a>01831                        &amp;superTearData-&gt;<a class="code" href="structTear__Characterization.html#84bb66d1980070f669ea5fa967cc0377">exp_diameter</a>, NULL,
<a name="l01832"></a>01832                        NULL, NULL);
<a name="l01833"></a>01833      <span class="keywordflow">if</span> (doDispl) {
<a name="l01834"></a>01834        rc = <a class="code" href="group__GeometricRelations.html#g7da48dd54f4ae3e1a20ec50854d87c41">fc_getDisplacedSubsetsDiameter</a>(superTears[i].numTear,
<a name="l01835"></a>01835                                tear_exposeds, tear_displs,
<a name="l01836"></a>01836                            &amp;superTearData-&gt;<a class="code" href="structTear__Characterization.html#64cf4f755985a2ccd6db4a733eae4a2f">displ_exp_diameter</a>,
<a name="l01837"></a>01837                                NULL, NULL, NULL);
<a name="l01838"></a>01838        <a class="code" href="error_8h.html#42c09317184affa18e70826cb35f3f04">fc_exitIfErrorPrintf</a>(rc, <span class="stringliteral">"Failed to get displaced exposed diameter"</span>);
<a name="l01839"></a>01839      }
<a name="l01840"></a>01840       }
<a name="l01841"></a>01841       <span class="keywordflow">else</span> {
<a name="l01842"></a>01842      <span class="keywordflow">for</span> (k = 0; k &lt; 3; k++) {
<a name="l01843"></a>01843        superTearData-&gt;<a class="code" href="structTear__Characterization.html#52a54c240fe78aa458908951ecd411cb">exp_lowers</a>[k] = -2;
<a name="l01844"></a>01844        superTearData-&gt;<a class="code" href="structTear__Characterization.html#64d8ff371e05aba29882a34bbd8860d7">exp_uppers</a>[k] = -1;
<a name="l01845"></a>01845        superTearData-&gt;<a class="code" href="structTear__Characterization.html#ccd5973d5d3b4e6e092fe1afcccb662a">displ_exp_lowers</a>[k] = -2;
<a name="l01846"></a>01846        superTearData-&gt;<a class="code" href="structTear__Characterization.html#8b5ec177f7b36b84dfeec4637f2a10f4">displ_exp_uppers</a>[k] = -1;
<a name="l01847"></a>01847      }
<a name="l01848"></a>01848       }
<a name="l01849"></a>01849     }
<a name="l01850"></a>01850   }
<a name="l01851"></a>01851 
<a name="l01852"></a>01852   <span class="comment">// midway cleanup - don't need displs any more</span>
<a name="l01853"></a>01853   <span class="keywordflow">if</span> (doDispl) {
<a name="l01854"></a>01854     <span class="keywordflow">for</span> (i = 0; i &lt; numMesh; i++)
<a name="l01855"></a>01855       free(displs[i]);
<a name="l01856"></a>01856     free(displs);
<a name="l01857"></a>01857   }
<a name="l01858"></a>01858 
<a name="l01859"></a>01859   <span class="comment">// --- sort</span>
<a name="l01860"></a>01860 
<a name="l01861"></a>01861   <span class="comment">// sort the super tears</span>
<a name="l01862"></a>01862   fprintf(output_file, <span class="stringliteral">"Sorting tears by region diameter (largest first) ...\n"</span>);
<a name="l01863"></a>01863   fflush(NULL);
<a name="l01864"></a>01864   qsort((<span class="keywordtype">void</span>*)superTears, (size_t)numSuperTear, <span class="keyword">sizeof</span>(<a class="code" href="structSuperTear.html">SuperTear</a>), 
<a name="l01865"></a>01865      <a class="code" href="tears_8c.html#77e7c7c4dd750776b0f1327beaeaf3ba">cmpSuperTearsByLength</a>);
<a name="l01866"></a>01866   <span class="comment">//for (i = 0; i &lt; numSuperTear; i++) </span>
<a name="l01867"></a>01867   <span class="comment">//printf("%d: superTear %d, diameter = %f, bbchord = %f\n", i,</span>
<a name="l01868"></a>01868   <span class="comment">//   superTears[i].tearID, superTears[i].data.diameter,</span>
<a name="l01869"></a>01869   <span class="comment">//   sqrt(pow(superTears[i].data.uppers[0]-superTears[i].data.lowers[0],2)+</span>
<a name="l01870"></a>01870   <span class="comment">// pow(superTears[i].data.uppers[1]-superTears[i].data.lowers[1],2)+</span>
<a name="l01871"></a>01871   <span class="comment">// pow(superTears[i].data.uppers[2]-superTears[i].data.lowers[2],2)));</span>
<a name="l01872"></a>01872 
<a name="l01873"></a>01873   <span class="comment">// --- calc totals of all super tears - the super duper tear</span>
<a name="l01874"></a>01874 
<a name="l01875"></a>01875   <span class="comment">// only some values are valid to super sum</span>
<a name="l01876"></a>01876   <span class="comment">// and some value have slightly different meaning as total</span>
<a name="l01877"></a>01877   superDuperTear.<a class="code" href="structSuperTear.html#53fb4c150d687560f36482111d247e8a">tearID</a> = -1;
<a name="l01878"></a>01878   superDuperTear.<a class="code" href="structSuperTear.html#ff22693a55db8a8d5a1d95dfd92c468a">numTear</a> = superTears[0].numTear;
<a name="l01879"></a>01879   superDuperTear.<a class="code" href="structSuperTear.html#e7bd683083da627b7b495e249feb29c8">tears</a> = NULL;
<a name="l01880"></a>01880   superDuperTear.<a class="code" href="structSuperTear.html#011937f2c2e78f268ec587d0a737c0f8">data</a> = superTears[0].data;
<a name="l01881"></a>01881   <span class="keywordflow">for</span> (i = 1; i &lt; numSuperTear; i++) {
<a name="l01882"></a>01882     <a class="code" href="structTear__Characterization.html">Tear_Characterization</a> *superTearData = &amp;superTears[i].data;
<a name="l01883"></a>01883     superDuperTear.<a class="code" href="structSuperTear.html#ff22693a55db8a8d5a1d95dfd92c468a">numTear</a> += superTears[i].numTear;
<a name="l01884"></a>01884     superDuperTear.<a class="code" href="structSuperTear.html#011937f2c2e78f268ec587d0a737c0f8">data</a>.<a class="code" href="structTear__Characterization.html#ca099f62147f9a82c9919f327fd67aea">numCell</a> += superTearData-&gt;numCell;
<a name="l01885"></a>01885     superDuperTear.<a class="code" href="structSuperTear.html#011937f2c2e78f268ec587d0a737c0f8">data</a>.<a class="code" href="structTear__Characterization.html#e650cc5f4698f94372ac1a91585d9208">volume</a> += superTearData-&gt;volume;
<a name="l01886"></a>01886     superDuperTear.<a class="code" href="structSuperTear.html#011937f2c2e78f268ec587d0a737c0f8">data</a>.<a class="code" href="structTear__Characterization.html#3dcac12facf10a63033ab58e2bf0ad96">diameter</a> += superTearData-&gt;diameter;
<a name="l01887"></a>01887     superDuperTear.<a class="code" href="structSuperTear.html#011937f2c2e78f268ec587d0a737c0f8">data</a>.<a class="code" href="structTear__Characterization.html#84bb66d1980070f669ea5fa967cc0377">exp_diameter</a> += superTearData-&gt;exp_diameter;
<a name="l01888"></a>01888     superDuperTear.<a class="code" href="structSuperTear.html#011937f2c2e78f268ec587d0a737c0f8">data</a>.<a class="code" href="structTear__Characterization.html#64cf4f755985a2ccd6db4a733eae4a2f">displ_exp_diameter</a> += superTearData-&gt;displ_exp_diameter;
<a name="l01889"></a>01889     <span class="comment">// bounding boxes don't mean anything</span>
<a name="l01890"></a>01890     <span class="keywordflow">if</span> (doDamageWeight) {
<a name="l01891"></a>01891       superDuperTear.<a class="code" href="structSuperTear.html#011937f2c2e78f268ec587d0a737c0f8">data</a>.<a class="code" href="structTear__Characterization.html#81d5650d0b8647e489d34391c5908ea1">dead_numCell</a> += superTearData-&gt;dead_numCell;
<a name="l01892"></a>01892       superDuperTear.<a class="code" href="structSuperTear.html#011937f2c2e78f268ec587d0a737c0f8">data</a>.<a class="code" href="structTear__Characterization.html#d7ba9673f47f5b64e26f9069feea2164">damaged_numCell</a> += superTearData-&gt;damaged_numCell;
<a name="l01893"></a>01893       superDuperTear.<a class="code" href="structSuperTear.html#011937f2c2e78f268ec587d0a737c0f8">data</a>.<a class="code" href="structTear__Characterization.html#ddb6062312d4738e29a7703f6266f103">dead_vol</a> += superTearData-&gt;dead_vol;
<a name="l01894"></a>01894       superDuperTear.<a class="code" href="structSuperTear.html#011937f2c2e78f268ec587d0a737c0f8">data</a>.<a class="code" href="structTear__Characterization.html#83052feab2c05ff60265124170c6da42">dead_logvol</a> += superTearData-&gt;dead_logvol;
<a name="l01895"></a>01895       superDuperTear.<a class="code" href="structSuperTear.html#011937f2c2e78f268ec587d0a737c0f8">data</a>.<a class="code" href="structTear__Characterization.html#45526cd884223a0323c79cec9b4a55b1">damaged_vol</a> += superTearData-&gt;damaged_vol;
<a name="l01896"></a>01896       superDuperTear.<a class="code" href="structSuperTear.html#011937f2c2e78f268ec587d0a737c0f8">data</a>.<a class="code" href="structTear__Characterization.html#b8f85a6d397843bcab7a3abd8f8249bf">damaged_vol_x_damage</a> += superTearData-&gt;damaged_vol_x_damage;
<a name="l01897"></a>01897       superDuperTear.<a class="code" href="structSuperTear.html#011937f2c2e78f268ec587d0a737c0f8">data</a>.<a class="code" href="structTear__Characterization.html#f9a5382459e892efdcbaac28ebae1acc">damaged_vol_x_logdamage</a> += superTearData-&gt;damaged_vol_x_logdamage;
<a name="l01898"></a>01898       superDuperTear.<a class="code" href="structSuperTear.html#011937f2c2e78f268ec587d0a737c0f8">data</a>.<a class="code" href="structTear__Characterization.html#8a2dd6b40b03853643fe3f8483b5407c">damaged_log_vol_x_damage</a> += superTearData-&gt;damaged_log_vol_x_damage;
<a name="l01899"></a>01899     }
<a name="l01900"></a>01900   }
<a name="l01901"></a>01901   
<a name="l01902"></a>01902   <span class="comment">// --- report tears</span>
<a name="l01903"></a>01903 
<a name="l01904"></a>01904   <span class="comment">// print results per super tear</span>
<a name="l01905"></a>01905   <span class="keywordflow">for</span> (i = 0; i &lt; numSuperTear; i++) {
<a name="l01906"></a>01906     SuperTear *superTear = &amp;superTears[i];
<a name="l01907"></a>01907     fprintf(output_file, <span class="stringliteral">"Tear %d:\n"</span>, i);
<a name="l01908"></a>01908     fprintf(output_file, <span class="stringliteral">"  numDeadElementRegions = %d\n"</span>, superTear-&gt;numTear);
<a name="l01909"></a>01909     <span class="comment">// debug</span>
<a name="l01910"></a>01910     <span class="comment">//fprintf(output_file, "  tearIDs = %d", superTear-&gt;tears[0]-&gt;tearID);</span>
<a name="l01911"></a>01911     <span class="comment">//for (j = 1; j &lt; superTear-&gt;numTear; j++)</span>
<a name="l01912"></a>01912     <span class="comment">//fprintf(output_file, ", %d", superTear-&gt;tears[j]-&gt;tearID);</span>
<a name="l01913"></a>01913     <span class="comment">//fprintf(output_file, "\n");</span>
<a name="l01914"></a>01914     fprintf(output_file, <span class="stringliteral">"  meshIDs = %d"</span>, superTear-&gt;tears[0]-&gt;meshID);
<a name="l01915"></a>01915     <span class="keywordflow">for</span> (j = 1; j &lt; superTear-&gt;numTear; j++)
<a name="l01916"></a>01916       fprintf(output_file, <span class="stringliteral">", %d"</span>, superTear-&gt;tears[j]-&gt;meshID);
<a name="l01917"></a>01917     fprintf(output_file, <span class="stringliteral">"\n"</span>);
<a name="l01918"></a>01918     fprintf(output_file, <span class="stringliteral">"  meshNames = '%s'"</span>, 
<a name="l01919"></a>01919          meshNames[superTear-&gt;tears[0]-&gt;meshID]);
<a name="l01920"></a>01920     <span class="keywordflow">for</span> (j = 1; j &lt; superTear-&gt;numTear; j++)
<a name="l01921"></a>01921       fprintf(output_file, <span class="stringliteral">", '%s'"</span>, meshNames[superTear-&gt;tears[j]-&gt;meshID]);
<a name="l01922"></a>01922     fprintf(output_file, <span class="stringliteral">"\n"</span>);
<a name="l01923"></a>01923     <span class="keywordflow">for</span> (j = 0; j &lt; superTear-&gt;numTear; j++){
<a name="l01924"></a>01924       <a class="code" href="tears_8c.html#33fa21d4cc3a95073e8f64ba5d8d7c36">printShapeIntersection</a>(output_file,superTear-&gt;tears[j]-&gt;tearID,
<a name="l01925"></a>01925                     superTear-&gt;tears[j]-&gt;shape_intersection);
<a name="l01926"></a>01926     }
<a name="l01927"></a>01927     <a class="code" href="tears_8c.html#02511beb5129ac60b8e63e5842d751e1">print_tear_characterization</a>(output_file, &amp;superTear-&gt;data, 0,
<a name="l01928"></a>01928                     topoDims[superTear-&gt;tears[0]-&gt;meshID],
<a name="l01929"></a>01929                     doDispl, doDamageWeight, dead_damage);
<a name="l01930"></a>01930     fflush(NULL);
<a name="l01931"></a>01931   }
<a name="l01932"></a>01932 
<a name="l01933"></a>01933   <span class="comment">// --- report totals</span>
<a name="l01934"></a>01934 
<a name="l01935"></a>01935   <span class="comment">// print totals</span>
<a name="l01936"></a>01936   fprintf(output_file, <span class="stringliteral">"Totals:\n"</span>);
<a name="l01937"></a>01937   fprintf(output_file, <span class="stringliteral">"  numDeadElementRegions = %d\n"</span>,
<a name="l01938"></a>01938        superDuperTear.<a class="code" href="structSuperTear.html#ff22693a55db8a8d5a1d95dfd92c468a">numTear</a>);
<a name="l01939"></a>01939   <a class="code" href="tears_8c.html#02511beb5129ac60b8e63e5842d751e1">print_tear_characterization</a>(output_file, &amp;superDuperTear.<a class="code" href="structSuperTear.html#011937f2c2e78f268ec587d0a737c0f8">data</a>, 1,
<a name="l01940"></a>01940                      globalTopoDim, doDispl, doDamageWeight, 
<a name="l01941"></a>01941                      dead_damage);
<a name="l01942"></a>01942   fflush(NULL);
<a name="l01943"></a>01943 
<a name="l01944"></a>01944 
<a name="l01945"></a>01945   <span class="comment">// -- shape centric writeout</span>
<a name="l01946"></a>01946   <span class="keywordflow">if</span> (useShape){
<a name="l01947"></a>01947     <span class="keywordtype">int</span> tot = 0;
<a name="l01948"></a>01948     <span class="keywordtype">int</span> totpits = 0;
<a name="l01949"></a>01949     <span class="keywordtype">int</span> totbreaks = 0;
<a name="l01950"></a>01950     <span class="keywordtype">int</span> tottunnels = 0;
<a name="l01951"></a>01951 
<a name="l01952"></a>01952     fprintf(output_file,<span class="stringliteral">"\nShape intersections:\n"</span>);
<a name="l01953"></a>01953     <span class="keywordflow">for</span> (i = 0; i &lt; numShapes; i++){
<a name="l01954"></a>01954       <span class="keywordtype">int</span> pits = 0;
<a name="l01955"></a>01955       <span class="keywordtype">int</span> tunnels = 0;
<a name="l01956"></a>01956       <span class="keywordtype">int</span> breaks = 0;
<a name="l01957"></a>01957       <span class="keywordtype">int</span> pitsm = 0;
<a name="l01958"></a>01958       <span class="keywordtype">int</span> tunnelsm = 0;
<a name="l01959"></a>01959       <span class="keywordtype">int</span> breaksm = 0;
<a name="l01960"></a>01960       <span class="keywordtype">int</span> total = 0;
<a name="l01961"></a>01961       <a class="code" href="tears_8c.html#e5f4cede39cce84c5ea7aaf6b9dcda91">printShapeOrder</a>(output_file,shapeorder[i]);
<a name="l01962"></a>01962       <span class="keywordflow">for</span> (j = 0; j &lt; numSuperTear; j++){
<a name="l01963"></a>01963      SuperTear *superTear = &amp;superTears[j];
<a name="l01964"></a>01964      <span class="keywordflow">for</span> (k = 0; k &lt; superTear-&gt;numTear; k++){
<a name="l01965"></a>01965        <a class="code" href="structShapeIntersection.html">ShapeIntersection</a> *si = superTear-&gt;tears[k]-&gt;shape_intersection;
<a name="l01966"></a>01966        if (si &amp;&amp; (shapeorder[i]-&gt;meshID == si -&gt;meshID) &amp;&amp;
<a name="l01967"></a>01967            (shapeorder[i]-&gt;shapeID == si-&gt;<a class="code" href="structshape__order.html#78690defc21a48d6d1efcc81c397e647">shapeID</a>)){
<a name="l01968"></a>01968          fprintf(output_file,<span class="stringliteral">"  SuperTear %4d "</span>, superTear-&gt;tearID);
<a name="l01969"></a>01969          <a class="code" href="tears_8c.html#33fa21d4cc3a95073e8f64ba5d8d7c36">printShapeIntersection</a>(output_file,superTear-&gt;tears[k]-&gt;tearID, si);
<a name="l01970"></a>01970          total++;
<a name="l01971"></a>01971          <span class="keywordflow">switch</span>(si-&gt;type){
<a name="l01972"></a>01972          case (<a class="code" href="tears_8c.html#88ffdc39a0c1a9f09f1ff65fb830c2f83d75915a5bc9a648f5dea2b351576ac7">BREAK</a>):
<a name="l01973"></a>01973            breaks++;
<a name="l01974"></a>01974            <span class="keywordflow">if</span> (si-&gt;major) breaksm++;
<a name="l01975"></a>01975            <span class="keywordflow">break</span>;
<a name="l01976"></a>01976          case (<a class="code" href="tears_8c.html#88ffdc39a0c1a9f09f1ff65fb830c2f84b0a94b59b12dbb374bdd372593b5f2e">PIT</a>):
<a name="l01977"></a>01977            pits++;
<a name="l01978"></a>01978            <span class="keywordflow">if</span> (si-&gt;major) pitsm++;
<a name="l01979"></a>01979            <span class="keywordflow">break</span>;
<a name="l01980"></a>01980          case (<a class="code" href="tears_8c.html#88ffdc39a0c1a9f09f1ff65fb830c2f87cb10bbf443f66bd8a054f6fc7e0e867">TUNNEL</a>):
<a name="l01981"></a>01981            tunnels++;
<a name="l01982"></a>01982            <span class="keywordflow">if</span> (si-&gt;major) tunnelsm++;
<a name="l01983"></a>01983            <span class="keywordflow">break</span>;
<a name="l01984"></a>01984          }
<a name="l01985"></a>01985        }
<a name="l01986"></a>01986      }
<a name="l01987"></a>01987       } <span class="comment">//num super tear</span>
<a name="l01988"></a>01988       fprintf(output_file,<span class="stringliteral">"  Shape Tears (%d): BREAKS (%d/%d) TUNNELS (%d/%d) PITS (%d/%d)\n"</span>,
<a name="l01989"></a>01989            total,breaksm,breaks,tunnelsm,tunnels,pitsm,pits);
<a name="l01990"></a>01990       tot+=total;
<a name="l01991"></a>01991       totpits+=pits;
<a name="l01992"></a>01992       totbreaks+=breaks;
<a name="l01993"></a>01993       tottunnels+=tunnels;
<a name="l01994"></a>01994     } <span class="comment">//num shapes</span>
<a name="l01995"></a>01995     fprintf(output_file,<span class="stringliteral">"Total Shape Tears %d: BREAKS (%d) TUNNELS (%d) PITS (%d)\n"</span>,
<a name="l01996"></a>01996            tot,totbreaks,tottunnels,totpits);
<a name="l01997"></a>01997 
<a name="l01998"></a>01998   }
<a name="l01999"></a>01999       
<a name="l02000"></a>02000 
<a name="l02001"></a>02001   <span class="comment">// --- print aux file</span>
<a name="l02002"></a>02002   sprintf(name_buf, <span class="stringliteral">"tears.fcx"</span>);
<a name="l02003"></a>02003   <span class="comment">//printf("Creating aux file '%s':\n", name_buf);</span>
<a name="l02004"></a>02004   aux_file = fopen(name_buf, <span class="stringliteral">"w"</span>);
<a name="l02005"></a>02005   <span class="keywordflow">if</span> (!aux_file)
<a name="l02006"></a>02006     <a class="code" href="error_8h.html#42c09317184affa18e70826cb35f3f04">fc_exitIfErrorPrintf</a>(<a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52e41dd0a2fc17e1c521fa4a96cfd412708">FC_FILE_IO_ERROR</a>, <span class="stringliteral">"Failed to open %s for writing"</span>,
<a name="l02007"></a>02007                 name_buf);
<a name="l02008"></a>02008   _fc_writeAuxFileHeader(aux_file);
<a name="l02009"></a>02009   <span class="keywordflow">for</span> (i = 0; i &lt; numSuperTear; i++) {
<a name="l02010"></a>02010     sprintf(name_buf, <span class="stringliteral">"Tear%d"</span>, i);
<a name="l02011"></a>02011     <span class="keywordtype">char</span>** temp_subsetNames;
<a name="l02012"></a>02012     temp_subsetNames = (<span class="keywordtype">char</span>**)malloc(superTears[i].numTear*<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>*));
<a name="l02013"></a>02013     <span class="keywordflow">for</span> (j = 0; j &lt; superTears[i].numTear; j++) 
<a name="l02014"></a>02014       <a class="code" href="group__Subset.html#gf8d751f06ea68d6944e19816147d35a9">fc_getSubsetName</a>(superTears[i].tears[j]-&gt;region, &amp;temp_subsetNames[j]);
<a name="l02015"></a>02015     _fc_writeAuxFileTear(aux_file, name_buf, superTears[i].numTear,
<a name="l02016"></a>02016                 temp_subsetNames, superTears[i].data.diameter);
<a name="l02017"></a>02017     <span class="keywordflow">for</span> (j = 0; j &lt; superTears[i].numTear; j++)
<a name="l02018"></a>02018       free(temp_subsetNames[j]);
<a name="l02019"></a>02019     free(temp_subsetNames);
<a name="l02020"></a>02020   }
<a name="l02021"></a>02021   <span class="keywordflow">for</span> (i = 0; i &lt; numTear; i++) {
<a name="l02022"></a>02022     _fc_writeAuxFileSubset(aux_file, tears[i].region);
<a name="l02023"></a>02023   }
<a name="l02024"></a>02024   _fc_writeAuxFileFooter(aux_file);
<a name="l02025"></a>02025 
<a name="l02026"></a>02026   <span class="comment">// --- print bounding boxes</span>
<a name="l02027"></a>02027 
<a name="l02028"></a>02028   <span class="comment">// DEBUG</span>
<a name="l02029"></a>02029   <span class="comment">/*</span>
<a name="l02030"></a>02030 <span class="comment">  sprintf(name_buf, "tear-regions-origs.bb");</span>
<a name="l02031"></a>02031 <span class="comment">  printf("Creating bounding box file '%s':\n", name_buf);</span>
<a name="l02032"></a>02032 <span class="comment">  bb_file = fopen(name_buf, "w");</span>
<a name="l02033"></a>02033 <span class="comment">  if (!bb_file)</span>
<a name="l02034"></a>02034 <span class="comment">    fc_exitIfErrorPrintf(FC_FILE_IO_ERROR, "Failed to open %s for writing",</span>
<a name="l02035"></a>02035 <span class="comment">                         name_buf);</span>
<a name="l02036"></a>02036 <span class="comment">  for (i = 0; i &lt; numTear; i++) {</span>
<a name="l02037"></a>02037 <span class="comment">    print_bb_line(bb_file, superTears[i].tears[0]-&gt;stepID,</span>
<a name="l02038"></a>02038 <span class="comment">            tears[i].data.numDim,</span>
<a name="l02039"></a>02039 <span class="comment">            tears[i].data.lowers, tears[i].data.uppers);</span>
<a name="l02040"></a>02040 <span class="comment">  }</span>
<a name="l02041"></a>02041 <span class="comment">  fclose(bb_file);</span>
<a name="l02042"></a>02042 <span class="comment">  */</span>
<a name="l02043"></a>02043 
<a name="l02044"></a>02044   sprintf(name_buf, <span class="stringliteral">"tear-regions.bb"</span>);
<a name="l02045"></a>02045   printf(<span class="stringliteral">"Creating bounding box file '%s':\n"</span>, name_buf);
<a name="l02046"></a>02046   bb_file = fopen(name_buf, <span class="stringliteral">"w"</span>);
<a name="l02047"></a>02047   <span class="keywordflow">if</span> (!bb_file)
<a name="l02048"></a>02048     <a class="code" href="error_8h.html#42c09317184affa18e70826cb35f3f04">fc_exitIfErrorPrintf</a>(<a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52e41dd0a2fc17e1c521fa4a96cfd412708">FC_FILE_IO_ERROR</a>, <span class="stringliteral">"Failed to open %s for writing"</span>, 
<a name="l02049"></a>02049                 name_buf);
<a name="l02050"></a>02050   _fc_writeBBFileHeader(bb_file);
<a name="l02051"></a>02051   <span class="keywordflow">for</span> (i = 0; i &lt; numSuperTear; i++) {
<a name="l02052"></a>02052     <span class="keywordtype">char</span> comment_buf[1028];
<a name="l02053"></a>02053     sprintf(comment_buf, <span class="stringliteral">"Diameter=%g"</span>, superTears[i].data.diameter);
<a name="l02054"></a>02054     sprintf(name_buf, <span class="stringliteral">"Tear%d"</span>, i);
<a name="l02055"></a>02055     _fc_writeBBFileBoundingBox(bb_file, name_buf, superTears[i].tears[0]-&gt;stepID,
<a name="l02056"></a>02056             comment_buf, superTears[i].data.numDim,
<a name="l02057"></a>02057             superTears[i].data.lowers, superTears[i].data.uppers);
<a name="l02058"></a>02058   }
<a name="l02059"></a>02059   _fc_writeBBFileFooter(bb_file);
<a name="l02060"></a>02060   fclose(bb_file);
<a name="l02061"></a>02061 
<a name="l02062"></a>02062   sprintf(name_buf, <span class="stringliteral">"tear-exposeds.bb"</span>);
<a name="l02063"></a>02063   printf(<span class="stringliteral">"Creating bounding box file '%s':\n"</span>, name_buf);
<a name="l02064"></a>02064   bb_file = fopen(name_buf, <span class="stringliteral">"w"</span>);
<a name="l02065"></a>02065   <span class="keywordflow">if</span> (!bb_file)
<a name="l02066"></a>02066     <a class="code" href="error_8h.html#42c09317184affa18e70826cb35f3f04">fc_exitIfErrorPrintf</a>(<a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52e41dd0a2fc17e1c521fa4a96cfd412708">FC_FILE_IO_ERROR</a>, <span class="stringliteral">"Failed to open %sfor writing"</span>,
<a name="l02067"></a>02067                 name_buf);
<a name="l02068"></a>02068   _fc_writeBBFileHeader(bb_file);
<a name="l02069"></a>02069   <span class="keywordflow">for</span> (i = 0; i &lt; numSuperTear; i++) {
<a name="l02070"></a>02070     <span class="keywordtype">char</span> comment_buf[1028];
<a name="l02071"></a>02071     sprintf(name_buf, <span class="stringliteral">"Tear%d"</span>, i);
<a name="l02072"></a>02072     sprintf(comment_buf, <span class="stringliteral">"Diameter=%g"</span>, superTears[i].data.diameter);
<a name="l02073"></a>02073     _fc_writeBBFileBoundingBox(bb_file, name_buf, superTears[i].tears[0]-&gt;stepID,
<a name="l02074"></a>02074             comment_buf, superTears[i].data.numDim,
<a name="l02075"></a>02075             superTears[i].data.exp_lowers, 
<a name="l02076"></a>02076             superTears[i].data.exp_uppers);
<a name="l02077"></a>02077   }
<a name="l02078"></a>02078   _fc_writeBBFileFooter(bb_file);
<a name="l02079"></a>02079   fclose(bb_file);
<a name="l02080"></a>02080 
<a name="l02081"></a>02081   <span class="keywordflow">if</span> (doDispl) {
<a name="l02082"></a>02082     sprintf(name_buf, <span class="stringliteral">"displ-tear-exposeds.bb"</span>);
<a name="l02083"></a>02083     printf(<span class="stringliteral">"Creating displaced bounding box file '%s':\n"</span>, name_buf);
<a name="l02084"></a>02084     bb_file = fopen(name_buf, <span class="stringliteral">"w"</span>);
<a name="l02085"></a>02085     <span class="keywordflow">if</span> (!bb_file)
<a name="l02086"></a>02086       <a class="code" href="error_8h.html#42c09317184affa18e70826cb35f3f04">fc_exitIfErrorPrintf</a>(<a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52e41dd0a2fc17e1c521fa4a96cfd412708">FC_FILE_IO_ERROR</a>, <span class="stringliteral">"Failed to open %s for writing"</span>,
<a name="l02087"></a>02087                   name_buf);
<a name="l02088"></a>02088     _fc_writeBBFileHeader(bb_file);
<a name="l02089"></a>02089     <span class="keywordflow">for</span> (i = 0; i &lt; numSuperTear; i++) {
<a name="l02090"></a>02090       <span class="keywordtype">char</span> comment_buf[1028];
<a name="l02091"></a>02091       sprintf(name_buf, <span class="stringliteral">"Tear%d"</span>, i);
<a name="l02092"></a>02092       sprintf(comment_buf, <span class="stringliteral">"Diameter=%g DisplDiameter=%g"</span>, 
<a name="l02093"></a>02093            superTears[i].data.diameter,
<a name="l02094"></a>02094            superTears[i].data.displ_exp_diameter);
<a name="l02095"></a>02095       _fc_writeBBFileBoundingBox(bb_file, name_buf, superTears[i].tears[0]-&gt;stepID,
<a name="l02096"></a>02096                  comment_buf, superTears[i].data.numDim,
<a name="l02097"></a>02097                  superTears[i].data.displ_exp_lowers,
<a name="l02098"></a>02098                  superTears[i].data.displ_exp_uppers);
<a name="l02099"></a>02099     }
<a name="l02100"></a>02100     _fc_writeBBFileFooter(bb_file);
<a name="l02101"></a>02101     fclose(bb_file);
<a name="l02102"></a>02102   }
<a name="l02103"></a>02103 
<a name="l02104"></a>02104   <span class="comment">// --- cleanup</span>
<a name="l02105"></a>02105 
<a name="l02106"></a>02106   <span class="comment">//clean up shape orders</span>
<a name="l02107"></a>02107   <span class="keywordflow">for</span> (j = 0; j &lt; numShapes; j++){
<a name="l02108"></a>02108     <a class="code" href="tears_8c.html#cf082d8718ee140cd7f361083cd54ac6">freeShapeOrder</a>(shapeorder[j]);
<a name="l02109"></a>02109   }
<a name="l02110"></a>02110   free(shapeorder); <span class="comment">//free the array</span>
<a name="l02111"></a>02111 
<a name="l02112"></a>02112   <span class="comment">// shut down output file</span>
<a name="l02113"></a>02113   <span class="keywordflow">if</span> (output_file_name)
<a name="l02114"></a>02114     fclose(output_file);
<a name="l02115"></a>02115 
<a name="l02116"></a>02116   <span class="comment">// cleanup memory</span>
<a name="l02117"></a>02117   <span class="keywordflow">for</span> (i = 0; i &lt; numMesh; i++)
<a name="l02118"></a>02118     free(meshNames[i]);
<a name="l02119"></a>02119   free(meshNames);
<a name="l02120"></a>02120   <span class="keywordflow">for</span> (i = 0; i &lt; numSuperTear; i++){
<a name="l02121"></a>02121     <span class="keywordflow">for</span> (j = 0; j &lt; superTears[i].numTear; j++){
<a name="l02122"></a>02122       <a class="code" href="tears_8c.html#0c2892755ed9736d0189b21849646bd1">freeShapeIntersection</a>(superTears[i].tears[j]-&gt;shape_intersection);
<a name="l02123"></a>02123       superTears[i].tears[j]-&gt;shape_intersection = NULL;
<a name="l02124"></a>02124     }
<a name="l02125"></a>02125     free(superTears[i].tears);
<a name="l02126"></a>02126   }
<a name="l02127"></a>02127   free(superTears);
<a name="l02128"></a>02128   free(tears);
<a name="l02129"></a>02129   <a class="code" href="group__Dataset.html#gbcd9a9a1b5ca718ac61d0707836703a7">fc_deleteDataset</a>(dataset);
<a name="l02130"></a>02130   <a class="code" href="group__Library.html#g68cec1422dde03b636cf039faafa7baa">fc_finalLibrary</a>();
<a name="l02131"></a>02131 
<a name="l02132"></a>02132   exit(0);
<a name="l02133"></a>02133 
<a name="l02134"></a>02134 }
<a name="l02135"></a>02135 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Oct 31 11:09:59 2007 for FCLib by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1 </small></address>
</body>
</html>
