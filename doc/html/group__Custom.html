<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>FCLib: Custom</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="classes.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<h1>Custom<br>
<small>
[<a class="el" href="group__API.html">FCLib API</a>]</small>
</h1>
<p>
Collaboration diagram for Custom:<hr><a name="_details"></a><h2>Detailed Description</h2>
Sandbox for trying out new stuff. 
<p>
<b>Description:</b> <p>
This is a sandbox (i.e. playground) for custom characterizations that may someday be incorporated into the fc library.<p>
<b>Modifications:</b> <ul>
<li>2003 W Koegler Created. </li></ul>

<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Custom.html#ge4b7a083462f1f5d66150a2f05b9d469">_fc_generateCombination</a> (int numElement, int ithCombination, int *comb)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">helper function, generates combinations  <a href="#ge4b7a083462f1f5d66150a2f05b9d469"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DataTypes.html#g2a816f8eddef0c2d8c2e3a0393b1f52e">FC_ReturnCode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Custom.html#ga02d49d382c7b6e05c7679cac2f5c1a7">fc_computeBestMatchNumOverlapScore</a> (int numPrev, <a class="el" href="structFC__Subset.html">FC_Subset</a> *prevLists, int numNew, <a class="el" href="structFC__Subset.html">FC_Subset</a> *newLists, double ***scores_p)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute Score Matrix based on relative amount of overlap.  <a href="#ga02d49d382c7b6e05c7679cac2f5c1a7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DataTypes.html#g2a816f8eddef0c2d8c2e3a0393b1f52e">FC_ReturnCode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Custom.html#g24b0f9f44306daea5bb44423b688cb1c">fc_computeBestMatchCorrespond</a> (int numPrev, int numNew, double **scores, int ***matrix_p)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute correspondence matrix based on best match.  <a href="#g24b0f9f44306daea5bb44423b688cb1c"></a><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="ge4b7a083462f1f5d66150a2f05b9d469"></a><!-- doxytag: member="custom.c::_fc_generateCombination" ref="ge4b7a083462f1f5d66150a2f05b9d469" args="(int numElement, int ithCombination, int *comb)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _fc_generateCombination           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numElement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ithCombination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>comb</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
helper function, generates combinations 
<p>

<p>
Definition at line <a class="el" href="custom_8c-source.html#l00090">90</a> of file <a class="el" href="custom_8c-source.html">custom.c</a>.
<p>
Referenced by <a class="el" href="custom_8c-source.html#l00131">fc_computeBestMatchNumOverlapScore()</a>.<div class="fragment"><pre class="fragment"><a name="l00090"></a>00090                                                                             {
<a name="l00091"></a>00091   <span class="keywordtype">int</span> i, j;
<a name="l00092"></a>00092   <span class="keywordflow">for</span> (j = 0; j &lt; numElement; j++)
<a name="l00093"></a>00093     comb[j] = 0;
<a name="l00094"></a>00094  
<a name="l00095"></a>00095   j = 0;
<a name="l00096"></a>00096   i = ithCombination;
<a name="l00097"></a>00097   <span class="keywordflow">while</span> (i &gt; 0) {
<a name="l00098"></a>00098     comb[j] = i % 2;
<a name="l00099"></a>00099     i /= 2;
<a name="l00100"></a>00100     j++;
<a name="l00101"></a>00101   }
<a name="l00102"></a>00102 
<a name="l00103"></a>00103   <span class="keywordflow">return</span>;
<a name="l00104"></a>00104 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="g24b0f9f44306daea5bb44423b688cb1c"></a><!-- doxytag: member="custom.c::fc_computeBestMatchCorrespond" ref="g24b0f9f44306daea5bb44423b688cb1c" args="(int numPrev, int numNew, double **scores, int ***matrix_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DataTypes.html#g2a816f8eddef0c2d8c2e3a0393b1f52e">FC_ReturnCode</a> fc_computeBestMatchCorrespond           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numPrev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numNew</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&nbsp;</td>
          <td class="paramname"> <em>scores</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int ***&nbsp;</td>
          <td class="paramname"> <em>matrix_p</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute correspondence matrix based on best match. 
<p>
<b>Description:</b> <p>
Given the score matrix, create the correspondence matrix which has the information for assigning ROIs to Features. Chooses best match based on highest scores where ties are permissible.<p>
The caller is responsible for freeing the dynamically allocated matrix.<p>
Note that if numPrev or numNew are 0, no matrix will be generated.<p>
<b>Modifications:</b> <ul>
<li>03/04/05 WSK Created </li></ul>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>numPrev</em>&nbsp;</td><td>
input - number of segments in previous step </td></tr>
<tr><td valign="top"><em>numNew</em>&nbsp;</td><td>
input - number of segments in new step </td></tr>
<tr><td valign="top"><em>scores</em>&nbsp;</td><td>
input - the score matrix, numPrev x numNew </td></tr>
<tr><td valign="top"><em>matrix_p</em>&nbsp;</td><td>
output - pointer to correspd. matrix, numPrev x numNew </td></tr>
</table>
</dl>
<p>
Definition at line <a class="el" href="custom_8c-source.html#l00322">322</a> of file <a class="el" href="custom_8c-source.html">custom.c</a>.
<p>
References <a class="el" href="util_8h-source.html#l00136">FC_DBL_EQUIV</a>, <a class="el" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52e51d318f8c97c8b094cf9820b51e4fa83">FC_ERROR</a>, <a class="el" href="base_8c-source.html#l00354">fc_getReturnCodeText()</a>, <a class="el" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52e4905abab801292d8b6338a89462b8e22">FC_INPUT_ERROR</a>, <a class="el" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52ee4bf428a2cdead5d4e3e3391a2cdab0d">FC_MEMORY_ERROR</a>, <a class="el" href="library_8h-source.html#l00096">fc_printfErrorMessage</a>, <a class="el" href="library_8h-source.html#l00162">fc_printfLogMessage</a>, and <a class="el" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52e27738acee5b8b2ef61be6e9b14a26613">FC_SUCCESS</a>.<div class="fragment"><pre class="fragment"><a name="l00327"></a>00327   {
<a name="l00328"></a>00328   <span class="keywordtype">int</span> i, j, k;
<a name="l00329"></a>00329 
<a name="l00330"></a>00330   <span class="comment">// default return</span>
<a name="l00331"></a>00331   <span class="keywordflow">if</span> (matrix_p)
<a name="l00332"></a>00332     *matrix_p = NULL;
<a name="l00333"></a>00333 
<a name="l00334"></a>00334   <span class="comment">// check input</span>
<a name="l00335"></a>00335   <span class="keywordflow">if</span> (numPrev &lt; 0 || numNew &lt; 0 || (numPrev &gt; 0 &amp;&amp; numNew &gt; 0 &amp;&amp; !scores) ||
<a name="l00336"></a>00336       !matrix_p)  {
<a name="l00337"></a>00337       <a class="code" href="group__Library.html#gb41a63cb101314fb41df98cef504a556">fc_printfErrorMessage</a>(<span class="stringliteral">"%s"</span>, <a class="code" href="group__DataTypes.html#g97ca6452d8a5b6625a2c02166dc87bb7">fc_getReturnCodeText</a>(<a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52e4905abab801292d8b6338a89462b8e22">FC_INPUT_ERROR</a>));
<a name="l00338"></a>00338       <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52e4905abab801292d8b6338a89462b8e22">FC_INPUT_ERROR</a>;
<a name="l00339"></a>00339   }
<a name="l00340"></a>00340   <span class="keywordflow">if</span> (scores) {
<a name="l00341"></a>00341     <span class="keywordflow">for</span> (i = 0; i &lt; numPrev; i++) {
<a name="l00342"></a>00342       <span class="keywordflow">if</span> (!scores[i]) {
<a name="l00343"></a>00343      <a class="code" href="group__Library.html#gb41a63cb101314fb41df98cef504a556">fc_printfErrorMessage</a>(<span class="stringliteral">"%s"</span>, <a class="code" href="group__DataTypes.html#g97ca6452d8a5b6625a2c02166dc87bb7">fc_getReturnCodeText</a>(<a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52e4905abab801292d8b6338a89462b8e22">FC_INPUT_ERROR</a>)); 
<a name="l00344"></a>00344      <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52e51d318f8c97c8b094cf9820b51e4fa83">FC_ERROR</a>;
<a name="l00345"></a>00345       }
<a name="l00346"></a>00346     }
<a name="l00347"></a>00347   }
<a name="l00348"></a>00348 
<a name="l00349"></a>00349   <span class="comment">// log message</span>
<a name="l00350"></a>00350   <a class="code" href="group__Library.html#g523b10264df36531b23de2260393db30">fc_printfLogMessage</a>(<span class="stringliteral">"Computing Best Match correspondence matrix."</span>);
<a name="l00351"></a>00351 
<a name="l00352"></a>00352   <span class="comment">// early return if no overlaps to compute</span>
<a name="l00353"></a>00353   <span class="keywordflow">if</span> (numPrev == 0 || numNew == 0) { 
<a name="l00354"></a>00354     *matrix_p = NULL;
<a name="l00355"></a>00355     <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52e27738acee5b8b2ef61be6e9b14a26613">FC_SUCCESS</a>;
<a name="l00356"></a>00356   }
<a name="l00357"></a>00357 
<a name="l00358"></a>00358   <span class="comment">// create space for the overlap array</span>
<a name="l00359"></a>00359   (*matrix_p) = calloc(numPrev, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>*));
<a name="l00360"></a>00360   <span class="keywordflow">if</span> (*matrix_p == NULL) {
<a name="l00361"></a>00361     <a class="code" href="group__Library.html#gb41a63cb101314fb41df98cef504a556">fc_printfErrorMessage</a>(<span class="stringliteral">"%s"</span>, <a class="code" href="group__DataTypes.html#g97ca6452d8a5b6625a2c02166dc87bb7">fc_getReturnCodeText</a>(<a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52ee4bf428a2cdead5d4e3e3391a2cdab0d">FC_MEMORY_ERROR</a>));
<a name="l00362"></a>00362     <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52ee4bf428a2cdead5d4e3e3391a2cdab0d">FC_MEMORY_ERROR</a>;
<a name="l00363"></a>00363   }
<a name="l00364"></a>00364   <span class="keywordflow">for</span> (i = 0; i &lt; numPrev; i++) {
<a name="l00365"></a>00365     (*matrix_p)[i] = calloc(numNew, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
<a name="l00366"></a>00366     <span class="keywordflow">if</span> ( (*matrix_p)[i] == NULL) {
<a name="l00367"></a>00367       <a class="code" href="group__Library.html#gb41a63cb101314fb41df98cef504a556">fc_printfErrorMessage</a>(<span class="stringliteral">"%s"</span>, <a class="code" href="group__DataTypes.html#g97ca6452d8a5b6625a2c02166dc87bb7">fc_getReturnCodeText</a>(<a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52ee4bf428a2cdead5d4e3e3391a2cdab0d">FC_MEMORY_ERROR</a>));
<a name="l00368"></a>00368       <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52ee4bf428a2cdead5d4e3e3391a2cdab0d">FC_MEMORY_ERROR</a>;
<a name="l00369"></a>00369     }
<a name="l00370"></a>00370   }
<a name="l00371"></a>00371 
<a name="l00372"></a>00372   <span class="comment">// for each entry, convert to an int</span>
<a name="l00373"></a>00373   <span class="keywordflow">for</span> (i = 0; i &lt; numPrev; i++) {
<a name="l00374"></a>00374     <span class="keywordflow">for</span> (j = 0; j &lt; numNew; j++) {
<a name="l00375"></a>00375       <span class="comment">// if this is the max value in this row &amp; column, keep</span>
<a name="l00376"></a>00376       <span class="keywordtype">int</span> maxScore = scores[i][j];
<a name="l00377"></a>00377       <span class="keywordflow">for</span> (k = 0; k &lt; numPrev; k++) {
<a name="l00378"></a>00378      <span class="keywordflow">if</span> (scores[k][j] &gt; maxScore)
<a name="l00379"></a>00379        maxScore = scores[k][j];
<a name="l00380"></a>00380       }
<a name="l00381"></a>00381       <span class="keywordflow">for</span> (k = 0; k &lt; numNew; k++) {
<a name="l00382"></a>00382      <span class="keywordflow">if</span> (scores[i][k] &gt; maxScore)
<a name="l00383"></a>00383        maxScore = scores[i][k];
<a name="l00384"></a>00384       }
<a name="l00385"></a>00385       <span class="keywordflow">if</span> (<a class="code" href="group__PublicFloatingPoint.html#gef9a2ac5984a93f3daf980de76ab1456">FC_DBL_EQUIV</a>(scores[i][j], maxScore)) {
<a name="l00386"></a>00386      (*matrix_p)[i][j] = 1;
<a name="l00387"></a>00387       }
<a name="l00388"></a>00388     }
<a name="l00389"></a>00389   }
<a name="l00390"></a>00390 
<a name="l00391"></a>00391   <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52e27738acee5b8b2ef61be6e9b14a26613">FC_SUCCESS</a>;
<a name="l00392"></a>00392 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="ga02d49d382c7b6e05c7679cac2f5c1a7"></a><!-- doxytag: member="custom.c::fc_computeBestMatchNumOverlapScore" ref="ga02d49d382c7b6e05c7679cac2f5c1a7" args="(int numPrev, FC_Subset *prevLists, int numNew, FC_Subset *newLists, double ***scores_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DataTypes.html#g2a816f8eddef0c2d8c2e3a0393b1f52e">FC_ReturnCode</a> fc_computeBestMatchNumOverlapScore           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numPrev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structFC__Subset.html">FC_Subset</a> *&nbsp;</td>
          <td class="paramname"> <em>prevLists</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numNew</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structFC__Subset.html">FC_Subset</a> *&nbsp;</td>
          <td class="paramname"> <em>newLists</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double ***&nbsp;</td>
          <td class="paramname"> <em>scores_p</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute Score Matrix based on relative amount of overlap. 
<p>
<b>Description:</b> <p>
Given a list of previous ROIs and a list of new ROIs, this routine computes the score matrix used to decide which ROIs belong in the same features. This uses the number of overlapping entities, not actually entity size.<p>
The caller is responsible for freeing the dynamically allocated matrix.<p>
Note that if numPrev or numNew are 0, no matrix will be generated.<p>
<dl compact><dt><b><a class="el" href="todo.html#_todo000003">Todo:</a></b></dt><dd>Should we enforce matching of entity types?</dd></dl>
BestMatch Tracking algorithm Copyright (c) 1999-2000 Laboratory of Visiometrics and Modeling, Rutgers University. All rights reserved.<p>
<b>Modifications:</b> <ul>
<li>APR-14-2003 W Koegler Documented </li></ul>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>numPrev</em>&nbsp;</td><td>
input - number of segments in previous step </td></tr>
<tr><td valign="top"><em>prevLists</em>&nbsp;</td><td>
input - previous ROIs </td></tr>
<tr><td valign="top"><em>numNew</em>&nbsp;</td><td>
input - number of segments in new step </td></tr>
<tr><td valign="top"><em>newLists</em>&nbsp;</td><td>
input - new ROIs </td></tr>
<tr><td valign="top"><em>scores_p</em>&nbsp;</td><td>
output - pointer to a numPrev x numNew matrix </td></tr>
</table>
</dl>
<p>
Definition at line <a class="el" href="custom_8c-source.html#l00131">131</a> of file <a class="el" href="custom_8c-source.html">custom.c</a>.
<p>
References <a class="el" href="custom_8c-source.html#l00090">_fc_generateCombination()</a>, <a class="el" href="track_8c-source.html#l00351">fc_computeNumOverlapScore()</a>, <a class="el" href="base_8c-source.html#l00354">fc_getReturnCodeText()</a>, <a class="el" href="subset_8c-source.html#l01800">fc_getSubsetNumMember()</a>, <a class="el" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52e4905abab801292d8b6338a89462b8e22">FC_INPUT_ERROR</a>, <a class="el" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52ee4bf428a2cdead5d4e3e3391a2cdab0d">FC_MEMORY_ERROR</a>, <a class="el" href="library_8h-source.html#l00096">fc_printfErrorMessage</a>, <a class="el" href="library_8h-source.html#l00162">fc_printfLogMessage</a>, and <a class="el" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52e27738acee5b8b2ef61be6e9b14a26613">FC_SUCCESS</a>.<div class="fragment"><pre class="fragment"><a name="l00137"></a>00137   {
<a name="l00138"></a>00138   <span class="comment">// assumes unchanging geometry &amp; sorted arrays</span>
<a name="l00139"></a>00139   <span class="comment">// returns number of entities in common</span>
<a name="l00140"></a>00140   <a class="code" href="group__DataTypes.html#g2a816f8eddef0c2d8c2e3a0393b1f52e">FC_ReturnCode</a> rc; 
<a name="l00141"></a>00141   <span class="keywordtype">int</span> i, j, k;
<a name="l00142"></a>00142   <span class="keywordtype">double</span> **scores;
<a name="l00143"></a>00143   <span class="keywordtype">int</span>* newNums;          <span class="comment">// number of entities in each new ROI </span>
<a name="l00144"></a>00144   <span class="keywordtype">int</span>* prevNums;         <span class="comment">// number of entities in each prev ROI</span>
<a name="l00145"></a>00145   <span class="keywordtype">double</span>** numOverlaps;  
<a name="l00146"></a>00146 
<a name="l00147"></a>00147   <span class="comment">// default return</span>
<a name="l00148"></a>00148   <span class="keywordflow">if</span> (scores_p)
<a name="l00149"></a>00149     *scores_p = NULL;
<a name="l00150"></a>00150 
<a name="l00151"></a>00151   <span class="comment">// check input</span>
<a name="l00152"></a>00152   <span class="keywordflow">if</span> (numPrev &lt; 0 || (numPrev &gt; 0 &amp;&amp; ! prevLists) || numNew &lt; 0 ||
<a name="l00153"></a>00153       (numNew &gt; 0 &amp;&amp; !newLists) || !scores_p)  {
<a name="l00154"></a>00154     <a class="code" href="group__Library.html#gb41a63cb101314fb41df98cef504a556">fc_printfErrorMessage</a>(<span class="stringliteral">"%s"</span>, <a class="code" href="group__DataTypes.html#g97ca6452d8a5b6625a2c02166dc87bb7">fc_getReturnCodeText</a>(<a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52e4905abab801292d8b6338a89462b8e22">FC_INPUT_ERROR</a>));
<a name="l00155"></a>00155     <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52e4905abab801292d8b6338a89462b8e22">FC_INPUT_ERROR</a>;
<a name="l00156"></a>00156   }
<a name="l00157"></a>00157 
<a name="l00158"></a>00158   <span class="comment">// log message</span>
<a name="l00159"></a>00159   <a class="code" href="group__Library.html#g523b10264df36531b23de2260393db30">fc_printfLogMessage</a>(<span class="stringliteral">"Computing Relative NumOverlap Score Matrix."</span>);
<a name="l00160"></a>00160 
<a name="l00161"></a>00161   <span class="comment">// early return if no overlaps to compute</span>
<a name="l00162"></a>00162   <span class="keywordflow">if</span> (numPrev == 0 || numNew == 0) 
<a name="l00163"></a>00163     <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52e27738acee5b8b2ef61be6e9b14a26613">FC_SUCCESS</a>;
<a name="l00164"></a>00164 
<a name="l00165"></a>00165   <span class="comment">// Get the number of overlaps for all combinations of ROIs</span>
<a name="l00166"></a>00166   rc = <a class="code" href="group__FeatureTracking.html#gc788121946db01840e3241e420a5c3fd">fc_computeNumOverlapScore</a>(numPrev, prevLists, numNew, newLists,
<a name="l00167"></a>00167                      &amp;numOverlaps);
<a name="l00168"></a>00168   <span class="keywordflow">if</span> (rc != <a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52e27738acee5b8b2ef61be6e9b14a26613">FC_SUCCESS</a>)
<a name="l00169"></a>00169     <span class="keywordflow">return</span> rc;
<a name="l00170"></a>00170 
<a name="l00171"></a>00171   <span class="comment">// Get sizes of all ROIs</span>
<a name="l00172"></a>00172   newNums = malloc(numNew*<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
<a name="l00173"></a>00173   prevNums = malloc(numPrev*<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
<a name="l00174"></a>00174   <span class="keywordflow">if</span> (newNums == NULL || prevNums == NULL) {
<a name="l00175"></a>00175     <a class="code" href="group__Library.html#gb41a63cb101314fb41df98cef504a556">fc_printfErrorMessage</a>(<span class="stringliteral">"%s"</span>, <a class="code" href="group__DataTypes.html#g97ca6452d8a5b6625a2c02166dc87bb7">fc_getReturnCodeText</a>(<a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52ee4bf428a2cdead5d4e3e3391a2cdab0d">FC_MEMORY_ERROR</a>));
<a name="l00176"></a>00176     <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52ee4bf428a2cdead5d4e3e3391a2cdab0d">FC_MEMORY_ERROR</a>;
<a name="l00177"></a>00177   }
<a name="l00178"></a>00178   <span class="keywordflow">for</span> (i = 0; i &lt; numPrev; i++) {
<a name="l00179"></a>00179     rc = <a class="code" href="group__Subset.html#g8b932d306fb8f41ef49677f803fd9fd1">fc_getSubsetNumMember</a>(prevLists[i], &amp;prevNums[i]);
<a name="l00180"></a>00180     <span class="keywordflow">if</span> (rc != <a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52e27738acee5b8b2ef61be6e9b14a26613">FC_SUCCESS</a>)
<a name="l00181"></a>00181       <span class="keywordflow">return</span> rc;
<a name="l00182"></a>00182   }
<a name="l00183"></a>00183   <span class="keywordflow">for</span> (i = 0; i &lt; numNew; i++) {
<a name="l00184"></a>00184     rc = <a class="code" href="group__Subset.html#g8b932d306fb8f41ef49677f803fd9fd1">fc_getSubsetNumMember</a>(newLists[i], &amp;newNums[i]);
<a name="l00185"></a>00185     <span class="keywordflow">if</span> (rc != <a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52e27738acee5b8b2ef61be6e9b14a26613">FC_SUCCESS</a>)
<a name="l00186"></a>00186       <span class="keywordflow">return</span> rc;
<a name="l00187"></a>00187   }
<a name="l00188"></a>00188 
<a name="l00189"></a>00189   <span class="comment">// create space for the overlap array, initialize to zero</span>
<a name="l00190"></a>00190   scores = calloc(numPrev, <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>*));
<a name="l00191"></a>00191   <span class="keywordflow">if</span> (scores == NULL) {
<a name="l00192"></a>00192     <a class="code" href="group__Library.html#gb41a63cb101314fb41df98cef504a556">fc_printfErrorMessage</a>(<span class="stringliteral">"%s"</span>, <a class="code" href="group__DataTypes.html#g97ca6452d8a5b6625a2c02166dc87bb7">fc_getReturnCodeText</a>(<a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52ee4bf428a2cdead5d4e3e3391a2cdab0d">FC_MEMORY_ERROR</a>));
<a name="l00193"></a>00193     <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52ee4bf428a2cdead5d4e3e3391a2cdab0d">FC_MEMORY_ERROR</a>;
<a name="l00194"></a>00194   }
<a name="l00195"></a>00195   <span class="keywordflow">for</span> (i = 0; i &lt; numPrev; i++) {
<a name="l00196"></a>00196     scores[i] = calloc(numNew, <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l00197"></a>00197     <span class="keywordflow">if</span> (scores[i] == NULL) {
<a name="l00198"></a>00198       <a class="code" href="group__Library.html#gb41a63cb101314fb41df98cef504a556">fc_printfErrorMessage</a>(<span class="stringliteral">"%s"</span>, <a class="code" href="group__DataTypes.html#g97ca6452d8a5b6625a2c02166dc87bb7">fc_getReturnCodeText</a>(<a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52ee4bf428a2cdead5d4e3e3391a2cdab0d">FC_MEMORY_ERROR</a>));
<a name="l00199"></a>00199       <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52ee4bf428a2cdead5d4e3e3391a2cdab0d">FC_MEMORY_ERROR</a>;
<a name="l00200"></a>00200     }
<a name="l00201"></a>00201   }
<a name="l00202"></a>00202 
<a name="l00203"></a>00203   <span class="comment">// compute forward scores for each previous ROI</span>
<a name="l00204"></a>00204   <span class="keywordflow">for</span> (i = 0; i &lt; numPrev; i++) {
<a name="l00205"></a>00205     <span class="comment">// find the new ROIs that this previous ROI overlaps with &amp; keep ids</span>
<a name="l00206"></a>00206     <span class="keywordtype">int</span> numOverlap = 0;
<a name="l00207"></a>00207     <span class="keywordtype">int</span> numCombo;
<a name="l00208"></a>00208     <span class="keywordtype">int</span>* overlapIDs = malloc(numNew*<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
<a name="l00209"></a>00209     <span class="keywordflow">for</span> (j = 0; j &lt; numNew; j++) {
<a name="l00210"></a>00210       <span class="keywordflow">if</span> (numOverlaps[i][j] &gt; 0) {
<a name="l00211"></a>00211      overlapIDs[numOverlap] = j;
<a name="l00212"></a>00212      numOverlap++;
<a name="l00213"></a>00213       }
<a name="l00214"></a>00214     }
<a name="l00215"></a>00215 
<a name="l00216"></a>00216     <span class="comment">// iterate through all possible combinations of overlaps</span>
<a name="l00217"></a>00217     numCombo = (int) pow(2.0, (<span class="keywordtype">double</span>)numOverlap);
<a name="l00218"></a>00218     <span class="keywordflow">for</span> (k = 1; k &lt; numCombo; k++) { <span class="comment">// skip 1st comb which is all 0's</span>
<a name="l00219"></a>00219       <span class="keywordtype">double</span> numIntersect = 0;
<a name="l00220"></a>00220       <span class="keywordtype">double</span> totalNum = 0;
<a name="l00221"></a>00221       <span class="keywordtype">double</span> meanNum;
<a name="l00222"></a>00222       <span class="keywordtype">int</span> cost;
<a name="l00223"></a>00223       <span class="keywordtype">int</span>* comboMatrix = malloc(numOverlap*<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
<a name="l00224"></a>00224       <a class="code" href="group__Custom.html#ge4b7a083462f1f5d66150a2f05b9d469">_fc_generateCombination</a>(numOverlap, k, comboMatrix);
<a name="l00225"></a>00225       <span class="keywordflow">for</span> (j = 0; j &lt; numOverlap; j++) {
<a name="l00226"></a>00226      <span class="keywordflow">if</span> (comboMatrix[j]) {
<a name="l00227"></a>00227        numIntersect += numOverlaps[i][overlapIDs[j]];
<a name="l00228"></a>00228        totalNum += newNums[overlapIDs[j]];
<a name="l00229"></a>00229      }
<a name="l00230"></a>00230       }
<a name="l00231"></a>00231       meanNum = sqrt(prevNums[i]*totalNum);
<a name="l00232"></a>00232       <span class="comment">//?? cast to int -- just setting arbitrary significant digs</span>
<a name="l00233"></a>00233       cost = (int) (numIntersect/meanNum*1000.);
<a name="l00234"></a>00234       <span class="comment">// for each ROI in this combination, update scores</span>
<a name="l00235"></a>00235       <span class="keywordflow">for</span> (j = 0; j &lt; numOverlap; j++) {
<a name="l00236"></a>00236      <span class="keywordflow">if</span> (comboMatrix[j]) {
<a name="l00237"></a>00237        <span class="keywordflow">if</span> (cost &gt; scores[i][overlapIDs[j]])
<a name="l00238"></a>00238          scores[i][overlapIDs[j]] = cost;
<a name="l00239"></a>00239      }
<a name="l00240"></a>00240       }
<a name="l00241"></a>00241       free(comboMatrix);
<a name="l00242"></a>00242     }
<a name="l00243"></a>00243     free(overlapIDs);
<a name="l00244"></a>00244   }
<a name="l00245"></a>00245 
<a name="l00246"></a>00246   <span class="comment">// compute backward scores for each new ROI</span>
<a name="l00247"></a>00247   <span class="keywordflow">for</span> (j = 0; j &lt; numNew; j++) {
<a name="l00248"></a>00248     <span class="comment">// find the prev ROIs that this new ROI overlaps with</span>
<a name="l00249"></a>00249     <span class="keywordtype">int</span> numOverlap = 0;
<a name="l00250"></a>00250     <span class="keywordtype">int</span> numCombo;
<a name="l00251"></a>00251     <span class="keywordtype">int</span>* overlapIDs = malloc(numPrev*<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
<a name="l00252"></a>00252     <span class="keywordflow">for</span> (i = 0; i &lt; numPrev; i++) {
<a name="l00253"></a>00253       <span class="keywordflow">if</span> (numOverlaps[i][j] &gt; 0) {
<a name="l00254"></a>00254      overlapIDs[numOverlap] = i;
<a name="l00255"></a>00255      numOverlap++;
<a name="l00256"></a>00256       }
<a name="l00257"></a>00257     }
<a name="l00258"></a>00258 
<a name="l00259"></a>00259     <span class="comment">// iterate through all possible combinations of overlaps</span>
<a name="l00260"></a>00260     numCombo = (int) pow(2.0, (<span class="keywordtype">double</span>)numOverlap);
<a name="l00261"></a>00261     <span class="keywordflow">for</span> (k = 1; k &lt; numCombo; k++) { <span class="comment">// skip 1st comb which is all 0's</span>
<a name="l00262"></a>00262       <span class="keywordtype">double</span> numIntersect = 0;
<a name="l00263"></a>00263       <span class="keywordtype">double</span> totalNum = 0;
<a name="l00264"></a>00264       <span class="keywordtype">double</span> meanNum;
<a name="l00265"></a>00265       <span class="keywordtype">int</span> cost;
<a name="l00266"></a>00266       <span class="keywordtype">int</span>* comboMatrix = malloc(numOverlap*<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
<a name="l00267"></a>00267       <a class="code" href="group__Custom.html#ge4b7a083462f1f5d66150a2f05b9d469">_fc_generateCombination</a>(numOverlap, k, comboMatrix);
<a name="l00268"></a>00268       <span class="keywordflow">for</span> (i = 0; i &lt; numOverlap; i++) {
<a name="l00269"></a>00269      <span class="keywordflow">if</span> (comboMatrix[i]) {
<a name="l00270"></a>00270        numIntersect += numOverlaps[overlapIDs[i]][j];
<a name="l00271"></a>00271        totalNum += prevNums[overlapIDs[i]];
<a name="l00272"></a>00272      }
<a name="l00273"></a>00273       }
<a name="l00274"></a>00274       meanNum = sqrt(newNums[j]*totalNum);
<a name="l00275"></a>00275       <span class="comment">//?? cast to int -- just setting arbitrary significant digs</span>
<a name="l00276"></a>00276       cost = (int) (numIntersect/meanNum*1000.);
<a name="l00277"></a>00277       <span class="comment">// for each ROI in this combination, update scores</span>
<a name="l00278"></a>00278       <span class="keywordflow">for</span> (i = 0; i &lt; numOverlap; i++) {
<a name="l00279"></a>00279      <span class="keywordflow">if</span> (comboMatrix[i]) {
<a name="l00280"></a>00280        <span class="keywordflow">if</span> (cost &gt; scores[overlapIDs[i]][j])
<a name="l00281"></a>00281          scores[overlapIDs[i]][j] = cost;
<a name="l00282"></a>00282      }
<a name="l00283"></a>00283       }
<a name="l00284"></a>00284       free(comboMatrix);
<a name="l00285"></a>00285     }
<a name="l00286"></a>00286     free(overlapIDs);
<a name="l00287"></a>00287   }
<a name="l00288"></a>00288 
<a name="l00289"></a>00289   <span class="comment">// cleanup</span>
<a name="l00290"></a>00290   free(prevNums);
<a name="l00291"></a>00291   free(newNums);
<a name="l00292"></a>00292 
<a name="l00293"></a>00293   <span class="comment">// debug</span>
<a name="l00294"></a>00294   <span class="comment">//printf("Score Matrix\n");</span>
<a name="l00295"></a>00295   <span class="comment">//for (i = 0; i &lt; numPrev; i++) {</span>
<a name="l00296"></a>00296   <span class="comment">//for (j = 0; j &lt; numNew; j++)</span>
<a name="l00297"></a>00297   <span class="comment">//  printf("%f ", scores[i][j]);</span>
<a name="l00298"></a>00298   <span class="comment">//printf("\n");</span>
<a name="l00299"></a>00299   <span class="comment">//}</span>
<a name="l00300"></a>00300 
<a name="l00301"></a>00301   *scores_p = scores;
<a name="l00302"></a>00302   <span class="keywordflow">return</span> <a class="code" href="group__DataTypes.html#gg2a816f8eddef0c2d8c2e3a0393b1f52e27738acee5b8b2ef61be6e9b14a26613">FC_SUCCESS</a>;
<a name="l00303"></a>00303 }
</pre></div>
<p>

</div>
</div><p>
<hr size="1"><address style="align: right;"><small>Generated on Wed Oct 31 11:10:02 2007 for FCLib by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1 </small></address>
</body>
</html>
