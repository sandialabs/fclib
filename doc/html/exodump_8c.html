<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>FCLib: tools/exodump.c File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="classes.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>tools/exodump.c File Reference</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
Exodus file explorer. 
<p>
Copyright (2000) Sandia Corporation. Under the terms of Contract DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains certain rights in this software.<p>
Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:<p>
* Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.<p>
* Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.<p>
* Neither the name of Sandia nor the names of any contributors may be used to endorse or promote products derived from this software without specific prior written permission.<p>
* Modified source versions must be plainly marked as such, and must not be misrepresented as being the original software.<p>
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<p>
<dl class="rcs" compact><dt><b>Source</b></dt><dd>/usr/local/Repositories/fcdmf/fclib/tools/exodump.c,v </dd></dl>
<dl class="rcs" compact><dt><b>Revision</b></dt><dd>1.29 </dd></dl>
<dl class="rcs" compact><dt><b>Date</b></dt><dd>2007/08/02 06:58:44 </dd></dl>
<p>
<b>Description:</b> Program to write metadats from an Exodus II file out to stdout. This is to help developers to see underlying Exodus data model. It is not a comprehesive writeout.<p>
Usage: exodump [-options] filename<p>
In the writeout numbers that are exodus ids are indicated with (ID = numberhere), as opposed to non-exodus numbers that are written out as a convenience -- e.g., numbering lists of records, and lists of connectivities for an entity where the id of the entity is not returned as part of the call (e.g., block conns call return an array of all conns/enttiy in sequential order but without explict return for the entity id (just explict conn id)) -- are indicated with numberhere. In the latter case, these mostly start with 0, as they are iterations through a loop, however in the case of node,face,edge,elems in a list, they start with 1 since the exodus numbering for those will start with 1.<p>
<dl compact><dt><b><a class="el" href="todo.html#_todo000119">Todo:</a></b></dt><dd><ul>
<li>documentation says there is no edge order map. is there a face order map?</li><li>could rewrite this to use the new interface entirely</li><li>is there anyway to know if there is a set extra list or not</li><li>waiting for elem set prop to be fixed</li></ul>
</dd></dl>
<b>Modifications:</b> <ul>
<li>08/02/2005 WSD Created.</li><li>04/16/2007 ACG adding nodeset and sideset variable and truth table writeout</li><li>04/18/2007 ACG commencing adding optional 4.46 items</li><li>07/17-18/2007 ACG elem order map out and back in. error behavior may have changed at some point along the line but it is consistent with the exodus test reader</li><li>07/17/2007 ACG adding nodal attributes (but no set ones).</li><li>10/04/2007 ACG adding element subsets</li><li>10/04/2007 ACG exodus 4.58 API calls are no longer conditional </li></ul>

<p>Definition in file <a class="el" href="exodump_8c-source.html">exodump.c</a>.</p>

<p>
<code>#include &lt;stdio.h&gt;</code><br>
<code>#include &lt;stdlib.h&gt;</code><br>
<code>#include &lt;string.h&gt;</code><br>
<code>#include &quot;netcdf.h&quot;</code><br>
<code>#include &quot;exodusII.h&quot;</code><br>
<code>#include &quot;exodusII_ext.h&quot;</code><br>

<p>
<div class="dynheader">
Include dependency graph for exodump.c:</div>
<div class="dynsection">
<p><center><img src="exodump_8c__incl.gif" border="0" usemap="#tools/exodump.c_map" alt=""></center>
</div>

<p>
<a href="exodump_8c-source.html">Go to the source code of this file.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="exodump_8c.html#1226766ad4576d71aaf2d0c05999d519">NUMSETTYPES</a>&nbsp;&nbsp;&nbsp;5</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="exodump_8c.html#80c6cfa79435e942330b6f7ab6512362">NUMBLKTYPES</a>&nbsp;&nbsp;&nbsp;3</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="exodump_8c.html#ddfd719a2b6d9f020deb4fda446cd18e">NUMTYPES</a>&nbsp;&nbsp;&nbsp;4</td></tr>

<tr><td colspan="2"><br><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <br>
&nbsp;&nbsp;<a class="el" href="exodump_8c.html#06fc87d81c62e9abb8790b6e5713c55b7b4c0e5ae1385e1224a6e59abf47ecc0">NODESET</a> = 0, 
<br>
&nbsp;&nbsp;<a class="el" href="exodump_8c.html#06fc87d81c62e9abb8790b6e5713c55bf2cc6d0bdf89f64e022a1dd3ac9bf31e">ELEMSET</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="exodump_8c.html#06fc87d81c62e9abb8790b6e5713c55bf03e67951597561f7910379848050552">FACESET</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="exodump_8c.html#06fc87d81c62e9abb8790b6e5713c55b0f9cb4d6eb49d02851626be8b5b9bf01">EDGESET</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="exodump_8c.html#06fc87d81c62e9abb8790b6e5713c55b86c05035d6a2fbc5762f39215d6a8a22">SIDESET</a>
<br>
 }</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <br>
&nbsp;&nbsp;<a class="el" href="exodump_8c.html#df764cbdea00d65edcd07bb9953ad2b70db96ed158ef1efb317e4db5fe0acee5">ELEMBLK</a> = 0, 
<br>
&nbsp;&nbsp;<a class="el" href="exodump_8c.html#df764cbdea00d65edcd07bb9953ad2b7ea53c3565ed51a2f2b2a22c1e24f3258">FACEBLK</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="exodump_8c.html#df764cbdea00d65edcd07bb9953ad2b70032e1b185783e3dc3eb4c744e836b2c">EDGEBLK</a>
<br>
 }</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <br>
&nbsp;&nbsp;<a class="el" href="exodump_8c.html#99fb83031ce9923c84392b4e92f956b559a889456a2d742fdca191dccb3e871d">NODE</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="exodump_8c.html#99fb83031ce9923c84392b4e92f956b5b2cc30231b3e7e8bca714c8750523660">ELEM</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="exodump_8c.html#99fb83031ce9923c84392b4e92f956b55cfae78048cf95359061c2e812e7d691">FACE</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="exodump_8c.html#99fb83031ce9923c84392b4e92f956b5a622cbc12b78e3e883dd7b3217088a66">EDGE</a>
<br>
 }</td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="exodump_8c.html#3c04138a5bfe5d72780bb7e82a18e627">main</a> (int argc, char **argv)</td></tr>

</table>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="80c6cfa79435e942330b6f7ab6512362"></a><!-- doxytag: member="exodump.c::NUMBLKTYPES" ref="80c6cfa79435e942330b6f7ab6512362" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NUMBLKTYPES&nbsp;&nbsp;&nbsp;3          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="exodump_8c-source.html#l00095">95</a> of file <a class="el" href="exodump_8c-source.html">exodump.c</a>.</p>

<p>Referenced by <a class="el" href="exodump_8c-source.html#l00098">main()</a>.</p>

</div>
</div><p>
<a class="anchor" name="1226766ad4576d71aaf2d0c05999d519"></a><!-- doxytag: member="exodump.c::NUMSETTYPES" ref="1226766ad4576d71aaf2d0c05999d519" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NUMSETTYPES&nbsp;&nbsp;&nbsp;5          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="exodump_8c-source.html#l00094">94</a> of file <a class="el" href="exodump_8c-source.html">exodump.c</a>.</p>

<p>Referenced by <a class="el" href="exodump_8c-source.html#l00098">main()</a>.</p>

</div>
</div><p>
<a class="anchor" name="ddfd719a2b6d9f020deb4fda446cd18e"></a><!-- doxytag: member="exodump.c::NUMTYPES" ref="ddfd719a2b6d9f020deb4fda446cd18e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NUMTYPES&nbsp;&nbsp;&nbsp;4          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="exodump_8c-source.html#l00096">96</a> of file <a class="el" href="exodump_8c-source.html">exodump.c</a>.</p>

<p>Referenced by <a class="el" href="exodump_8c-source.html#l00098">main()</a>.</p>

</div>
</div><p>
<hr><h2>Enumeration Type Documentation</h2>
<a class="anchor" name="06fc87d81c62e9abb8790b6e5713c55b"></a><!-- doxytag: member="exodump.c::@0" ref="06fc87d81c62e9abb8790b6e5713c55b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="06fc87d81c62e9abb8790b6e5713c55b7b4c0e5ae1385e1224a6e59abf47ecc0"></a><!-- doxytag: member="NODESET" ref="06fc87d81c62e9abb8790b6e5713c55b7b4c0e5ae1385e1224a6e59abf47ecc0" args="" -->NODESET</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="06fc87d81c62e9abb8790b6e5713c55bf2cc6d0bdf89f64e022a1dd3ac9bf31e"></a><!-- doxytag: member="ELEMSET" ref="06fc87d81c62e9abb8790b6e5713c55bf2cc6d0bdf89f64e022a1dd3ac9bf31e" args="" -->ELEMSET</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="06fc87d81c62e9abb8790b6e5713c55bf03e67951597561f7910379848050552"></a><!-- doxytag: member="FACESET" ref="06fc87d81c62e9abb8790b6e5713c55bf03e67951597561f7910379848050552" args="" -->FACESET</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="06fc87d81c62e9abb8790b6e5713c55b0f9cb4d6eb49d02851626be8b5b9bf01"></a><!-- doxytag: member="EDGESET" ref="06fc87d81c62e9abb8790b6e5713c55b0f9cb4d6eb49d02851626be8b5b9bf01" args="" -->EDGESET</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="06fc87d81c62e9abb8790b6e5713c55b86c05035d6a2fbc5762f39215d6a8a22"></a><!-- doxytag: member="SIDESET" ref="06fc87d81c62e9abb8790b6e5713c55b86c05035d6a2fbc5762f39215d6a8a22" args="" -->SIDESET</em>&nbsp;</td><td>
</td></tr>
</table>
</dl>

<p>Definition at line <a class="el" href="exodump_8c-source.html#l00091">91</a> of file <a class="el" href="exodump_8c-source.html">exodump.c</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00091"></a>00091 {<a class="code" href="exodump_8c.html#06fc87d81c62e9abb8790b6e5713c55b7b4c0e5ae1385e1224a6e59abf47ecc0">NODESET</a>=0, <a class="code" href="exodump_8c.html#06fc87d81c62e9abb8790b6e5713c55bf2cc6d0bdf89f64e022a1dd3ac9bf31e">ELEMSET</a>, <a class="code" href="exodump_8c.html#06fc87d81c62e9abb8790b6e5713c55bf03e67951597561f7910379848050552">FACESET</a>, <a class="code" href="exodump_8c.html#06fc87d81c62e9abb8790b6e5713c55b0f9cb4d6eb49d02851626be8b5b9bf01">EDGESET</a>, <a class="code" href="exodump_8c.html#06fc87d81c62e9abb8790b6e5713c55b86c05035d6a2fbc5762f39215d6a8a22">SIDESET</a>};
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="df764cbdea00d65edcd07bb9953ad2b7"></a><!-- doxytag: member="exodump.c::@1" ref="df764cbdea00d65edcd07bb9953ad2b7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="df764cbdea00d65edcd07bb9953ad2b70db96ed158ef1efb317e4db5fe0acee5"></a><!-- doxytag: member="ELEMBLK" ref="df764cbdea00d65edcd07bb9953ad2b70db96ed158ef1efb317e4db5fe0acee5" args="" -->ELEMBLK</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="df764cbdea00d65edcd07bb9953ad2b7ea53c3565ed51a2f2b2a22c1e24f3258"></a><!-- doxytag: member="FACEBLK" ref="df764cbdea00d65edcd07bb9953ad2b7ea53c3565ed51a2f2b2a22c1e24f3258" args="" -->FACEBLK</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="df764cbdea00d65edcd07bb9953ad2b70032e1b185783e3dc3eb4c744e836b2c"></a><!-- doxytag: member="EDGEBLK" ref="df764cbdea00d65edcd07bb9953ad2b70032e1b185783e3dc3eb4c744e836b2c" args="" -->EDGEBLK</em>&nbsp;</td><td>
</td></tr>
</table>
</dl>

<p>Definition at line <a class="el" href="exodump_8c-source.html#l00092">92</a> of file <a class="el" href="exodump_8c-source.html">exodump.c</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00092"></a>00092 {<a class="code" href="exodump_8c.html#df764cbdea00d65edcd07bb9953ad2b70db96ed158ef1efb317e4db5fe0acee5">ELEMBLK</a>=0, <a class="code" href="exodump_8c.html#df764cbdea00d65edcd07bb9953ad2b7ea53c3565ed51a2f2b2a22c1e24f3258">FACEBLK</a>, <a class="code" href="exodump_8c.html#df764cbdea00d65edcd07bb9953ad2b70032e1b185783e3dc3eb4c744e836b2c">EDGEBLK</a>};
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="99fb83031ce9923c84392b4e92f956b5"></a><!-- doxytag: member="exodump.c::@2" ref="99fb83031ce9923c84392b4e92f956b5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="99fb83031ce9923c84392b4e92f956b559a889456a2d742fdca191dccb3e871d"></a><!-- doxytag: member="NODE" ref="99fb83031ce9923c84392b4e92f956b559a889456a2d742fdca191dccb3e871d" args="" -->NODE</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="99fb83031ce9923c84392b4e92f956b5b2cc30231b3e7e8bca714c8750523660"></a><!-- doxytag: member="ELEM" ref="99fb83031ce9923c84392b4e92f956b5b2cc30231b3e7e8bca714c8750523660" args="" -->ELEM</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="99fb83031ce9923c84392b4e92f956b55cfae78048cf95359061c2e812e7d691"></a><!-- doxytag: member="FACE" ref="99fb83031ce9923c84392b4e92f956b55cfae78048cf95359061c2e812e7d691" args="" -->FACE</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="99fb83031ce9923c84392b4e92f956b5a622cbc12b78e3e883dd7b3217088a66"></a><!-- doxytag: member="EDGE" ref="99fb83031ce9923c84392b4e92f956b5a622cbc12b78e3e883dd7b3217088a66" args="" -->EDGE</em>&nbsp;</td><td>
</td></tr>
</table>
</dl>

<p>Definition at line <a class="el" href="exodump_8c-source.html#l00093">93</a> of file <a class="el" href="exodump_8c-source.html">exodump.c</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00093"></a>00093 {<a class="code" href="exodump_8c.html#99fb83031ce9923c84392b4e92f956b559a889456a2d742fdca191dccb3e871d">NODE</a>, <a class="code" href="exodump_8c.html#99fb83031ce9923c84392b4e92f956b5b2cc30231b3e7e8bca714c8750523660">ELEM</a>, <a class="code" href="exodump_8c.html#99fb83031ce9923c84392b4e92f956b55cfae78048cf95359061c2e812e7d691">FACE</a>, <a class="code" href="exodump_8c.html#99fb83031ce9923c84392b4e92f956b5a622cbc12b78e3e883dd7b3217088a66">EDGE</a>}; <span class="comment">//generic types (for maps)</span>
</pre></div>
<p>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="3c04138a5bfe5d72780bb7e82a18e627"></a><!-- doxytag: member="exodump.c::main" ref="3c04138a5bfe5d72780bb7e82a18e627" args="(int argc, char **argv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int main           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>argv</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="exodump_8c-source.html#l00098">98</a> of file <a class="el" href="exodump_8c-source.html">exodump.c</a>.</p>

<p>References <a class="el" href="exodump_8c-source.html#l00093">EDGE</a>, <a class="el" href="exodump_8c-source.html#l00092">EDGEBLK</a>, <a class="el" href="exodump_8c-source.html#l00091">EDGESET</a>, <a class="el" href="exodump_8c-source.html#l00093">ELEM</a>, <a class="el" href="exodump_8c-source.html#l00092">ELEMBLK</a>, <a class="el" href="exodump_8c-source.html#l00091">ELEMSET</a>, <a class="el" href="exodump_8c-source.html#l00093">FACE</a>, <a class="el" href="exodump_8c-source.html#l00092">FACEBLK</a>, <a class="el" href="exodump_8c-source.html#l00091">FACESET</a>, <a class="el" href="exodump_8c-source.html#l00093">NODE</a>, <a class="el" href="exodump_8c-source.html#l00091">NODESET</a>, <a class="el" href="exodump_8c-source.html#l00095">NUMBLKTYPES</a>, <a class="el" href="exodump_8c-source.html#l00094">NUMSETTYPES</a>, <a class="el" href="exodump_8c-source.html#l00096">NUMTYPES</a>, and <a class="el" href="exodump_8c-source.html#l00091">SIDESET</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00099"></a>00099 {
<a name="l00100"></a>00100   <span class="keywordtype">char</span>* filename;
<a name="l00101"></a>00101   <span class="keywordtype">int</span> exoid, error;
<a name="l00102"></a>00102   <span class="keywordtype">int</span> num_dim, num_time_step;
<a name="l00103"></a>00103   <span class="keywordtype">int</span> num_node, num_elem, num_face, num_edge;
<a name="l00104"></a>00104   <span class="keywordtype">int</span> num_blk[<a class="code" href="exodump_8c.html#80c6cfa79435e942330b6f7ab6512362">NUMBLKTYPES</a>];
<a name="l00105"></a>00105   <span class="keywordtype">int</span> num_set[<a class="code" href="exodump_8c.html#1226766ad4576d71aaf2d0c05999d519">NUMSETTYPES</a>];
<a name="l00106"></a>00106   <span class="keywordtype">int</span> num_blk_prop[<a class="code" href="exodump_8c.html#80c6cfa79435e942330b6f7ab6512362">NUMBLKTYPES</a>];
<a name="l00107"></a>00107   <span class="keywordtype">int</span> num_set_prop[<a class="code" href="exodump_8c.html#1226766ad4576d71aaf2d0c05999d519">NUMSETTYPES</a>];
<a name="l00108"></a>00108   <span class="keywordtype">int</span> num_glob_var, num_nodal_var;
<a name="l00109"></a>00109   <span class="keywordtype">int</span> num_blk_var[<a class="code" href="exodump_8c.html#80c6cfa79435e942330b6f7ab6512362">NUMBLKTYPES</a>];
<a name="l00110"></a>00110   <span class="keywordtype">int</span> num_set_var[<a class="code" href="exodump_8c.html#1226766ad4576d71aaf2d0c05999d519">NUMSETTYPES</a>];
<a name="l00111"></a>00111   <span class="keywordtype">int</span> num_map[4]; 
<a name="l00112"></a>00112   <span class="keywordtype">int</span> i, j, k, ii, kk;
<a name="l00113"></a>00113   <span class="keywordtype">int</span> CPU_word_size, IO_word_size;
<a name="l00114"></a>00114   <span class="keywordtype">int</span>* ids;
<a name="l00115"></a>00115   <span class="keywordtype">float</span> version;
<a name="l00116"></a>00116   <span class="keywordtype">char</span> title[MAX_LINE_LENGTH+1], *coord_names[3], **prop_names;
<a name="l00117"></a>00117   <span class="keywordtype">char</span> namebuf[MAX_STR_LENGTH+1];
<a name="l00118"></a>00118   <span class="keywordtype">char</span> *qa_records[100][4], **infos, **var_names;
<a name="l00119"></a>00119   <span class="keywordtype">int</span> num_qa_rec, num_info;
<a name="l00120"></a>00120 
<a name="l00121"></a>00121   <span class="keywordtype">float</span> fdum;
<a name="l00122"></a>00122   <span class="keywordtype">char</span>* cdum;
<a name="l00123"></a>00123   <span class="keywordtype">int</span>* map;
<a name="l00124"></a>00124   <span class="keywordtype">int</span>* truth_tab;
<a name="l00125"></a>00125   <span class="keywordtype">int</span> getconns = 0;
<a name="l00126"></a>00126 
<a name="l00127"></a>00127   ex_init_params ex_params;
<a name="l00128"></a>00128 
<a name="l00129"></a>00129   (void) kk; <span class="comment">//for compilation of pre-446</span>
<a name="l00130"></a>00130 
<a name="l00131"></a>00131   <span class="comment">// handle arguments</span>
<a name="l00132"></a>00132   <span class="keywordflow">if</span> (argc &lt; 2 || argc &gt; 3 || (argc == 3 &amp;&amp; (strcmp(argv[1],<span class="stringliteral">"-a"</span>)))) {
<a name="l00133"></a>00133     printf(<span class="stringliteral">"Usage: %s [-options] &lt;exodus file&gt;\n"</span>, argv[0]);
<a name="l00134"></a>00134     printf(<span class="stringliteral">"   -a         : print all block connectivities, EB attributes,\n"</span>);
<a name="l00135"></a>00135     printf(<span class="stringliteral">"                set entity lists, orientation arrays\n"</span>);
<a name="l00136"></a>00136     fflush(NULL);
<a name="l00137"></a>00137     exit(-1);
<a name="l00138"></a>00138   }
<a name="l00139"></a>00139   getconns = 0;
<a name="l00140"></a>00140   <span class="keywordflow">if</span> (argc == 2){ 
<a name="l00141"></a>00141     filename = argv[1];
<a name="l00142"></a>00142   } <span class="keywordflow">else</span> {
<a name="l00143"></a>00143     filename = argv[2];
<a name="l00144"></a>00144     getconns = 1;    
<a name="l00145"></a>00145   }
<a name="l00146"></a>00146 
<a name="l00147"></a>00147   <span class="comment">//init</span>
<a name="l00148"></a>00148   num_dim = 0;
<a name="l00149"></a>00149   num_node = 0;
<a name="l00150"></a>00150   num_elem = 0;
<a name="l00151"></a>00151   num_face = 0;
<a name="l00152"></a>00152   num_edge = 0;
<a name="l00153"></a>00153   <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="exodump_8c.html#ddfd719a2b6d9f020deb4fda446cd18e">NUMTYPES</a>; i++){
<a name="l00154"></a>00154     num_map[i] = 0;
<a name="l00155"></a>00155   }
<a name="l00156"></a>00156   <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="exodump_8c.html#80c6cfa79435e942330b6f7ab6512362">NUMBLKTYPES</a>; i++){
<a name="l00157"></a>00157     num_blk[i] = 0;
<a name="l00158"></a>00158     num_blk_prop[i] = 0;
<a name="l00159"></a>00159     num_blk_var[i] = 0;
<a name="l00160"></a>00160   }
<a name="l00161"></a>00161   <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="exodump_8c.html#1226766ad4576d71aaf2d0c05999d519">NUMSETTYPES</a>; i++){
<a name="l00162"></a>00162     num_set[i] = 0;
<a name="l00163"></a>00163     num_set_prop[i] = 0;
<a name="l00164"></a>00164     num_set_var[i] = 0;
<a name="l00165"></a>00165   }
<a name="l00166"></a>00166   num_nodal_var = 0;
<a name="l00167"></a>00167   num_glob_var = 0;
<a name="l00168"></a>00168 
<a name="l00169"></a>00169   <span class="comment">// ** init exodus</span>
<a name="l00170"></a>00170 
<a name="l00171"></a>00171   ex_opts(EX_VERBOSE);
<a name="l00172"></a>00172 
<a name="l00173"></a>00173   <span class="comment">// ** open Exodus II file</span>
<a name="l00174"></a>00174 
<a name="l00175"></a>00175   <span class="comment">// open file</span>
<a name="l00176"></a>00176   <span class="comment">//  CPU_word_size = 0;</span>
<a name="l00177"></a>00177   CPU_word_size = 8;
<a name="l00178"></a>00178   IO_word_size = 0;
<a name="l00179"></a>00179   exoid = ex_open(filename, EX_READ, &amp;CPU_word_size, &amp;IO_word_size, &amp;version);
<a name="l00180"></a>00180   <span class="keywordflow">if</span> (exoid &lt; 0) {
<a name="l00181"></a>00181     fprintf(stderr, <span class="stringliteral">"Error: failed to open file '%s'\n"</span>, filename);
<a name="l00182"></a>00182     fflush(NULL);
<a name="l00183"></a>00183     exit(-1);
<a name="l00184"></a>00184   }
<a name="l00185"></a>00185   <span class="comment">//print results</span>
<a name="l00186"></a>00186   printf(<span class="stringliteral">"Database: '%s'\n"</span>, filename);
<a name="l00187"></a>00187   printf(<span class="stringliteral">"  CPU_word_size = %d, IO_word_size = %d, version = %f\n"</span>,
<a name="l00188"></a>00188          CPU_word_size, IO_word_size, version);
<a name="l00189"></a>00189   fflush(NULL);
<a name="l00190"></a>00190 
<a name="l00191"></a>00191   <span class="comment">// ** Read database parameters</span>
<a name="l00192"></a>00192 
<a name="l00193"></a>00193   <span class="comment">// Get info  </span>
<a name="l00194"></a>00194   error = ex_get_init_ext(exoid,&amp;ex_params);
<a name="l00195"></a>00195   <span class="keywordflow">if</span> (error != 0) {
<a name="l00196"></a>00196     fprintf(stderr, <span class="stringliteral">"Error: failed to read database parameters\n"</span>);
<a name="l00197"></a>00197     fflush(NULL);
<a name="l00198"></a>00198     exit(-1);
<a name="l00199"></a>00199   }
<a name="l00200"></a>00200 
<a name="l00201"></a>00201   strncpy(title,ex_params.title,MAX_LINE_LENGTH+1);
<a name="l00202"></a>00202   num_dim = ex_params.num_dim;
<a name="l00203"></a>00203   num_node = ex_params.num_nodes;
<a name="l00204"></a>00204   num_elem = ex_params.num_elem;
<a name="l00205"></a>00205   num_face = ex_params.num_face;
<a name="l00206"></a>00206   num_edge = ex_params.num_edge;
<a name="l00207"></a>00207   num_map[<a class="code" href="exodump_8c.html#99fb83031ce9923c84392b4e92f956b559a889456a2d742fdca191dccb3e871d">NODE</a>] = ex_params.num_node_maps;
<a name="l00208"></a>00208   num_map[<a class="code" href="exodump_8c.html#99fb83031ce9923c84392b4e92f956b5b2cc30231b3e7e8bca714c8750523660">ELEM</a>] = ex_params.num_elem_maps;
<a name="l00209"></a>00209   num_map[<a class="code" href="exodump_8c.html#99fb83031ce9923c84392b4e92f956b55cfae78048cf95359061c2e812e7d691">FACE</a>] = ex_params.num_face_maps;
<a name="l00210"></a>00210   num_map[<a class="code" href="exodump_8c.html#99fb83031ce9923c84392b4e92f956b5a622cbc12b78e3e883dd7b3217088a66">EDGE</a>] = ex_params.num_edge_maps;
<a name="l00211"></a>00211   num_blk[<a class="code" href="exodump_8c.html#df764cbdea00d65edcd07bb9953ad2b70db96ed158ef1efb317e4db5fe0acee5">ELEMBLK</a>] = ex_params.num_elem_blk;
<a name="l00212"></a>00212   num_blk[<a class="code" href="exodump_8c.html#df764cbdea00d65edcd07bb9953ad2b7ea53c3565ed51a2f2b2a22c1e24f3258">FACEBLK</a>] = ex_params.num_face_blk;
<a name="l00213"></a>00213   num_blk[<a class="code" href="exodump_8c.html#df764cbdea00d65edcd07bb9953ad2b70032e1b185783e3dc3eb4c744e836b2c">EDGEBLK</a>] = ex_params.num_edge_blk;
<a name="l00214"></a>00214   num_set[<a class="code" href="exodump_8c.html#06fc87d81c62e9abb8790b6e5713c55b7b4c0e5ae1385e1224a6e59abf47ecc0">NODESET</a>] = ex_params.num_node_sets;
<a name="l00215"></a>00215   num_set[<a class="code" href="exodump_8c.html#06fc87d81c62e9abb8790b6e5713c55bf2cc6d0bdf89f64e022a1dd3ac9bf31e">ELEMSET</a>] = ex_params.num_elem_sets;
<a name="l00216"></a>00216   num_set[<a class="code" href="exodump_8c.html#06fc87d81c62e9abb8790b6e5713c55bf03e67951597561f7910379848050552">FACESET</a>] = ex_params.num_face_sets;
<a name="l00217"></a>00217   num_set[<a class="code" href="exodump_8c.html#06fc87d81c62e9abb8790b6e5713c55b0f9cb4d6eb49d02851626be8b5b9bf01">EDGESET</a>] = ex_params.num_edge_sets;
<a name="l00218"></a>00218   num_set[<a class="code" href="exodump_8c.html#06fc87d81c62e9abb8790b6e5713c55b86c05035d6a2fbc5762f39215d6a8a22">SIDESET</a>] = ex_params.num_side_sets;
<a name="l00219"></a>00219 
<a name="l00220"></a>00220   error = ex_inquire(exoid, EX_INQ_QA, &amp;num_qa_rec, &amp;fdum, cdum);
<a name="l00221"></a>00221   <span class="keywordflow">if</span> (error != 0) {
<a name="l00222"></a>00222     fprintf(stderr, <span class="stringliteral">"Error: failed to read # of QA records\n"</span>);
<a name="l00223"></a>00223     fflush(NULL);
<a name="l00224"></a>00224     exit(-1);
<a name="l00225"></a>00225   }
<a name="l00226"></a>00226   error = ex_inquire(exoid, EX_INQ_INFO, &amp;num_info, &amp;fdum, cdum);
<a name="l00227"></a>00227   <span class="keywordflow">if</span> (error != 0) {
<a name="l00228"></a>00228     fprintf(stderr, <span class="stringliteral">"Error: failed to read # of info records\n"</span>);
<a name="l00229"></a>00229     fflush(NULL);
<a name="l00230"></a>00230     exit(-1);
<a name="l00231"></a>00231   }
<a name="l00232"></a>00232 
<a name="l00233"></a>00233   <span class="keywordflow">for</span> (i = 0; i &lt; NUMBLKTYPES; i++){
<a name="l00234"></a>00234     <span class="keywordtype">int</span> propinq = 0;
<a name="l00235"></a>00235     <span class="keywordtype">char</span>* paraminq;
<a name="l00236"></a>00236 
<a name="l00237"></a>00237     <span class="keywordflow">if</span> (i != <a class="code" href="exodump_8c.html#df764cbdea00d65edcd07bb9953ad2b70db96ed158ef1efb317e4db5fe0acee5">ELEMBLK</a>) <span class="keywordflow">continue</span>;
<a name="l00238"></a>00238 
<a name="l00239"></a>00239     <span class="keywordflow">switch</span> (i){
<a name="l00240"></a>00240     <span class="keywordflow">case</span> <a class="code" href="exodump_8c.html#df764cbdea00d65edcd07bb9953ad2b70db96ed158ef1efb317e4db5fe0acee5">ELEMBLK</a>:
<a name="l00241"></a>00241       propinq = EX_INQ_EB_PROP;
<a name="l00242"></a>00242       paraminq = <span class="stringliteral">"e"</span>;
<a name="l00243"></a>00243       <span class="keywordflow">break</span>;
<a name="l00244"></a>00244     <span class="keywordflow">case</span> <a class="code" href="exodump_8c.html#df764cbdea00d65edcd07bb9953ad2b7ea53c3565ed51a2f2b2a22c1e24f3258">FACEBLK</a>:
<a name="l00245"></a>00245       propinq = EX_INQ_FACE_PROP;
<a name="l00246"></a>00246       paraminq = <span class="stringliteral">"f"</span>;
<a name="l00247"></a>00247       <span class="keywordflow">break</span>;
<a name="l00248"></a>00248     <span class="keywordflow">case</span> <a class="code" href="exodump_8c.html#df764cbdea00d65edcd07bb9953ad2b70032e1b185783e3dc3eb4c744e836b2c">EDGEBLK</a>:
<a name="l00249"></a>00249       propinq = EX_INQ_EDGE_PROP;
<a name="l00250"></a>00250       paraminq = <span class="stringliteral">"l"</span>;
<a name="l00251"></a>00251       <span class="keywordflow">break</span>;
<a name="l00252"></a>00252     <span class="keywordflow">default</span>:
<a name="l00253"></a>00253       fprintf(stderr, <span class="stringliteral">"Error: bad block type\n"</span>);
<a name="l00254"></a>00254       fflush(NULL);
<a name="l00255"></a>00255       exit(-1);
<a name="l00256"></a>00256     }
<a name="l00257"></a>00257 
<a name="l00258"></a>00258     error = ex_inquire(exoid, propinq, &amp;num_blk_prop[i], &amp;fdum, cdum);
<a name="l00259"></a>00259     <span class="keywordflow">if</span> (error != 0) {
<a name="l00260"></a>00260       fprintf(stderr, <span class="stringliteral">"Error: failed to read # of block properties\n"</span>);
<a name="l00261"></a>00261       fflush(NULL);
<a name="l00262"></a>00262       exit(-1);
<a name="l00263"></a>00263     }
<a name="l00264"></a>00264     error = ex_get_var_param(exoid, paraminq, &amp;num_blk_var[i]);
<a name="l00265"></a>00265     <span class="keywordflow">if</span> (error != 0) {
<a name="l00266"></a>00266       fprintf(stderr, <span class="stringliteral">"Error: failed to get # of blk vars\n"</span>);
<a name="l00267"></a>00267       fflush(NULL);
<a name="l00268"></a>00268       exit(-1);
<a name="l00269"></a>00269     }
<a name="l00270"></a>00270   }
<a name="l00271"></a>00271 
<a name="l00272"></a>00272 
<a name="l00273"></a>00273   <span class="keywordflow">for</span> (i = 0; i &lt; NUMSETTYPES; i++){
<a name="l00274"></a>00274     <span class="keywordtype">int</span> propinq = 0;
<a name="l00275"></a>00275     <span class="keywordtype">char</span> *paraminq;
<a name="l00276"></a>00276     <span class="keywordflow">switch</span> (i){
<a name="l00277"></a>00277     <span class="keywordflow">case</span> <a class="code" href="exodump_8c.html#06fc87d81c62e9abb8790b6e5713c55b7b4c0e5ae1385e1224a6e59abf47ecc0">NODESET</a>:
<a name="l00278"></a>00278       propinq = EX_INQ_NS_PROP;
<a name="l00279"></a>00279       paraminq = <span class="stringliteral">"m"</span>;
<a name="l00280"></a>00280       <span class="keywordflow">break</span>;
<a name="l00281"></a>00281     <span class="keywordflow">case</span> <a class="code" href="exodump_8c.html#06fc87d81c62e9abb8790b6e5713c55bf2cc6d0bdf89f64e022a1dd3ac9bf31e">ELEMSET</a>:
<a name="l00282"></a>00282       propinq = EX_INQ_ELS_PROP;
<a name="l00283"></a>00283       paraminq = <span class="stringliteral">"t"</span>;
<a name="l00284"></a>00284       <span class="keywordflow">break</span>;
<a name="l00285"></a>00285     <span class="keywordflow">case</span> <a class="code" href="exodump_8c.html#06fc87d81c62e9abb8790b6e5713c55bf03e67951597561f7910379848050552">FACESET</a>:
<a name="l00286"></a>00286       propinq = EX_INQ_FS_PROP;
<a name="l00287"></a>00287       paraminq = <span class="stringliteral">"a"</span>;
<a name="l00288"></a>00288       <span class="keywordflow">break</span>;
<a name="l00289"></a>00289     <span class="keywordflow">case</span> <a class="code" href="exodump_8c.html#06fc87d81c62e9abb8790b6e5713c55b0f9cb4d6eb49d02851626be8b5b9bf01">EDGESET</a>:
<a name="l00290"></a>00290       propinq = EX_INQ_ES_PROP;
<a name="l00291"></a>00291       paraminq = <span class="stringliteral">"d"</span>;
<a name="l00292"></a>00292       <span class="keywordflow">break</span>;
<a name="l00293"></a>00293     <span class="keywordflow">case</span> <a class="code" href="exodump_8c.html#06fc87d81c62e9abb8790b6e5713c55b86c05035d6a2fbc5762f39215d6a8a22">SIDESET</a>:
<a name="l00294"></a>00294       propinq = EX_INQ_SS_PROP;
<a name="l00295"></a>00295       paraminq = <span class="stringliteral">"s"</span>;
<a name="l00296"></a>00296       <span class="keywordflow">break</span>;
<a name="l00297"></a>00297     <span class="keywordflow">default</span>:
<a name="l00298"></a>00298       fprintf(stderr, <span class="stringliteral">"Error: bad set type\n"</span>);
<a name="l00299"></a>00299       fflush(NULL);
<a name="l00300"></a>00300       exit(-1);
<a name="l00301"></a>00301     }
<a name="l00302"></a>00302 
<a name="l00303"></a>00303     error = ex_inquire(exoid, propinq, &amp;num_set_prop[i], &amp;fdum, cdum);
<a name="l00304"></a>00304     <span class="keywordflow">if</span> (error != 0) {
<a name="l00305"></a>00305       fprintf(stderr, <span class="stringliteral">"Error: failed to read # of set properties\n"</span>);
<a name="l00306"></a>00306       fflush(NULL);
<a name="l00307"></a>00307       exit(-1);
<a name="l00308"></a>00308     }
<a name="l00309"></a>00309     error = ex_get_var_param(exoid, paraminq, &amp;num_set_var[i]);
<a name="l00310"></a>00310     <span class="keywordflow">if</span> (error != 0) {
<a name="l00311"></a>00311       fprintf(stderr, <span class="stringliteral">"Error: failed to get # of blk vars\n"</span>);
<a name="l00312"></a>00312       fflush(NULL);
<a name="l00313"></a>00313       exit(-1);
<a name="l00314"></a>00314     }
<a name="l00315"></a>00315   }
<a name="l00316"></a>00316       
<a name="l00317"></a>00317 
<a name="l00318"></a>00318   error = ex_get_var_param(exoid, <span class="stringliteral">"g"</span>, &amp;num_glob_var);
<a name="l00319"></a>00319   <span class="keywordflow">if</span> (error != 0) {
<a name="l00320"></a>00320     fprintf(stderr, <span class="stringliteral">"Error: failed to get # of global vars\n"</span>);
<a name="l00321"></a>00321     fflush(NULL);
<a name="l00322"></a>00322     exit(-1);
<a name="l00323"></a>00323   }
<a name="l00324"></a>00324   error = ex_get_var_param(exoid, <span class="stringliteral">"n"</span>, &amp;num_nodal_var);
<a name="l00325"></a>00325   <span class="keywordflow">if</span> (error != 0) {
<a name="l00326"></a>00326     fprintf(stderr, <span class="stringliteral">"Error: failed to get # of nodal vars\n"</span>);
<a name="l00327"></a>00327     fflush(NULL);
<a name="l00328"></a>00328     exit(-1);
<a name="l00329"></a>00329   }
<a name="l00330"></a>00330   error = ex_inquire(exoid, EX_INQ_TIME, &amp;num_time_step, &amp;fdum, cdum);
<a name="l00331"></a>00331   <span class="keywordflow">if</span> (error != 0) {
<a name="l00332"></a>00332     fprintf(stderr, <span class="stringliteral">"Error: failed to get # of time steps\n"</span>);
<a name="l00333"></a>00333     fflush(NULL);
<a name="l00334"></a>00334     exit(-1);
<a name="l00335"></a>00335   }
<a name="l00336"></a>00336 
<a name="l00337"></a>00337   <span class="comment">// Print it</span>
<a name="l00338"></a>00338   printf(<span class="stringliteral">"  Title = '%s'\n"</span>, title);
<a name="l00339"></a>00339   printf(<span class="stringliteral">"  num_dim = %d\n"</span>, num_dim);
<a name="l00340"></a>00340   printf(<span class="stringliteral">"  num_node = %d, num_elem = %d, num_face = %d, num_edge = %d\n"</span>,
<a name="l00341"></a>00341          num_node, num_elem, num_face, num_edge);
<a name="l00342"></a>00342   printf(<span class="stringliteral">"  num_node_map = %d, num_elem_map = %d, num_face_map = %d, num_edge_map = %d\n"</span>,
<a name="l00343"></a>00343          num_map[<a class="code" href="exodump_8c.html#99fb83031ce9923c84392b4e92f956b559a889456a2d742fdca191dccb3e871d">NODE</a>], num_map[<a class="code" href="exodump_8c.html#99fb83031ce9923c84392b4e92f956b5b2cc30231b3e7e8bca714c8750523660">ELEM</a>], num_map[<a class="code" href="exodump_8c.html#99fb83031ce9923c84392b4e92f956b55cfae78048cf95359061c2e812e7d691">FACE</a>], num_map[<a class="code" href="exodump_8c.html#99fb83031ce9923c84392b4e92f956b5a622cbc12b78e3e883dd7b3217088a66">EDGE</a>]);
<a name="l00344"></a>00344   printf(<span class="stringliteral">"  num_elem_blk = %d, num_face_blk = %d, num_edge_blk = %d\n"</span>, 
<a name="l00345"></a>00345       num_blk[<a class="code" href="exodump_8c.html#df764cbdea00d65edcd07bb9953ad2b70db96ed158ef1efb317e4db5fe0acee5">ELEMBLK</a>], num_blk[<a class="code" href="exodump_8c.html#df764cbdea00d65edcd07bb9953ad2b7ea53c3565ed51a2f2b2a22c1e24f3258">FACEBLK</a>], num_blk[<a class="code" href="exodump_8c.html#df764cbdea00d65edcd07bb9953ad2b70032e1b185783e3dc3eb4c744e836b2c">EDGEBLK</a>]);
<a name="l00346"></a>00346   printf(<span class="stringliteral">"  num_elem_blk_prop = %d, num_face_blk_prop = %d, num_edge_blk_prop = %d\n"</span>, 
<a name="l00347"></a>00347       num_blk_prop[<a class="code" href="exodump_8c.html#df764cbdea00d65edcd07bb9953ad2b70db96ed158ef1efb317e4db5fe0acee5">ELEMBLK</a>], num_blk_prop[<a class="code" href="exodump_8c.html#df764cbdea00d65edcd07bb9953ad2b7ea53c3565ed51a2f2b2a22c1e24f3258">FACEBLK</a>], num_blk_prop[<a class="code" href="exodump_8c.html#df764cbdea00d65edcd07bb9953ad2b70032e1b185783e3dc3eb4c744e836b2c">EDGEBLK</a>]);
<a name="l00348"></a>00348   printf(<span class="stringliteral">"  num_node_set = %d, num_elem_set = %d, num_face_set = %d, num_edge_set = %d, num_side_set = %d\n"</span>, 
<a name="l00349"></a>00349       num_set[<a class="code" href="exodump_8c.html#06fc87d81c62e9abb8790b6e5713c55b7b4c0e5ae1385e1224a6e59abf47ecc0">NODESET</a>], num_set[<a class="code" href="exodump_8c.html#06fc87d81c62e9abb8790b6e5713c55bf2cc6d0bdf89f64e022a1dd3ac9bf31e">ELEMSET</a>], num_set[<a class="code" href="exodump_8c.html#06fc87d81c62e9abb8790b6e5713c55bf03e67951597561f7910379848050552">FACESET</a>], num_set[<a class="code" href="exodump_8c.html#06fc87d81c62e9abb8790b6e5713c55b0f9cb4d6eb49d02851626be8b5b9bf01">EDGESET</a>], num_set[<a class="code" href="exodump_8c.html#06fc87d81c62e9abb8790b6e5713c55b86c05035d6a2fbc5762f39215d6a8a22">SIDESET</a>]);
<a name="l00350"></a>00350   printf(<span class="stringliteral">"  num_node_set_prop = %d, num_elem_set_prop = %d, num_face_set_prop = %d, num_edge_set_prop = %d, num_side_set_prop = %d\n"</span>, 
<a name="l00351"></a>00351       num_set_prop[<a class="code" href="exodump_8c.html#06fc87d81c62e9abb8790b6e5713c55b7b4c0e5ae1385e1224a6e59abf47ecc0">NODESET</a>], num_set_prop[<a class="code" href="exodump_8c.html#06fc87d81c62e9abb8790b6e5713c55bf2cc6d0bdf89f64e022a1dd3ac9bf31e">ELEMSET</a>], num_set_prop[<a class="code" href="exodump_8c.html#06fc87d81c62e9abb8790b6e5713c55bf03e67951597561f7910379848050552">FACESET</a>], num_set_prop[<a class="code" href="exodump_8c.html#06fc87d81c62e9abb8790b6e5713c55b0f9cb4d6eb49d02851626be8b5b9bf01">EDGESET</a>], num_set_prop[<a class="code" href="exodump_8c.html#06fc87d81c62e9abb8790b6e5713c55b86c05035d6a2fbc5762f39215d6a8a22">SIDESET</a>]);
<a name="l00352"></a>00352   printf(<span class="stringliteral">"  num_glob_var = %d, num_nodal_var = %d\n"</span>,
<a name="l00353"></a>00353          num_glob_var, num_nodal_var)
<a name="l00354"></a>00354 ;  printf(<span class="stringliteral">"  num_elem_blk_var = %d, num_face_blk_var = %d, num_edge_blk_var = %d\n"</span>, 
<a name="l00355"></a>00355       num_blk_var[<a class="code" href="exodump_8c.html#df764cbdea00d65edcd07bb9953ad2b70db96ed158ef1efb317e4db5fe0acee5">ELEMBLK</a>], num_blk_var[<a class="code" href="exodump_8c.html#df764cbdea00d65edcd07bb9953ad2b7ea53c3565ed51a2f2b2a22c1e24f3258">FACEBLK</a>], num_blk_var[<a class="code" href="exodump_8c.html#df764cbdea00d65edcd07bb9953ad2b70032e1b185783e3dc3eb4c744e836b2c">EDGEBLK</a>]);
<a name="l00356"></a>00356   printf(<span class="stringliteral">"  num_node_set_var = %d, num_elem_set_var = %d, num_face_set_var = %d, num_edge_set_var = %d, num_side_set_var = %d\n"</span>, 
<a name="l00357"></a>00357       num_set_var[<a class="code" href="exodump_8c.html#06fc87d81c62e9abb8790b6e5713c55b7b4c0e5ae1385e1224a6e59abf47ecc0">NODESET</a>], num_set_var[<a class="code" href="exodump_8c.html#06fc87d81c62e9abb8790b6e5713c55bf2cc6d0bdf89f64e022a1dd3ac9bf31e">ELEMSET</a>], num_set_var[<a class="code" href="exodump_8c.html#06fc87d81c62e9abb8790b6e5713c55bf03e67951597561f7910379848050552">FACESET</a>], num_set_var[<a class="code" href="exodump_8c.html#06fc87d81c62e9abb8790b6e5713c55b0f9cb4d6eb49d02851626be8b5b9bf01">EDGESET</a>], num_set_var[<a class="code" href="exodump_8c.html#06fc87d81c62e9abb8790b6e5713c55b86c05035d6a2fbc5762f39215d6a8a22">SIDESET</a>]);
<a name="l00358"></a>00358   printf(<span class="stringliteral">"  num_time_step = %d\n"</span>, num_time_step);
<a name="l00359"></a>00359   printf(<span class="stringliteral">"  num_qa_rec = %d, num_info = %d\n"</span>, num_qa_rec, num_info);
<a name="l00360"></a>00360 
<a name="l00361"></a>00361   printf(<span class="stringliteral">"\n"</span>);
<a name="l00362"></a>00362   fflush(NULL);
<a name="l00363"></a>00363 
<a name="l00364"></a>00364   <span class="comment">// ** Look at QA records</span>
<a name="l00365"></a>00365 
<a name="l00366"></a>00366   <span class="keywordflow">if</span> (num_qa_rec &gt; 0) {
<a name="l00367"></a>00367     <span class="keywordflow">for</span> (i = 0; i &lt; num_qa_rec; i++) 
<a name="l00368"></a>00368       <span class="keywordflow">for</span> (j = 0; j &lt; 4; j++)
<a name="l00369"></a>00369         qa_records[i][j] = (<span class="keywordtype">char</span>*)malloc((MAX_LINE_LENGTH+1)*<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));
<a name="l00370"></a>00370     error = ex_get_qa(exoid, qa_records);
<a name="l00371"></a>00371     <span class="keywordflow">if</span> (error != 0) {
<a name="l00372"></a>00372       fprintf(stderr, <span class="stringliteral">"Error: failed to read qa records\n"</span>);
<a name="l00373"></a>00373       fflush(NULL);
<a name="l00374"></a>00374       exit(-1);
<a name="l00375"></a>00375     }
<a name="l00376"></a>00376     <span class="keywordflow">for</span> (i = 0; i &lt; num_qa_rec; i++) {
<a name="l00377"></a>00377       printf(<span class="stringliteral">"QA Record #%d:\n"</span>, i);
<a name="l00378"></a>00378       <span class="keywordflow">for</span> (j = 0; j &lt; 4; j++)
<a name="l00379"></a>00379         printf(<span class="stringliteral">"  %s\n"</span>, qa_records[i][j]);
<a name="l00380"></a>00380       printf(<span class="stringliteral">"\n"</span>);
<a name="l00381"></a>00381       fflush(NULL);
<a name="l00382"></a>00382     }
<a name="l00383"></a>00383     <span class="keywordflow">for</span> (i = 0; i &lt; num_qa_rec; i++) 
<a name="l00384"></a>00384       <span class="keywordflow">for</span> (j = 0; j &lt; 4; j++)
<a name="l00385"></a>00385         free(qa_records[i][j]);
<a name="l00386"></a>00386   }
<a name="l00387"></a>00387 
<a name="l00388"></a>00388   <span class="comment">// ** Look at info records</span>
<a name="l00389"></a>00389 
<a name="l00390"></a>00390   <span class="keywordflow">if</span> (num_info &gt; 0) {
<a name="l00391"></a>00391     infos = (<span class="keywordtype">char</span>**)malloc(num_info*<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>*));
<a name="l00392"></a>00392     <span class="keywordflow">for</span> (i = 0; i &lt; num_info; i++)
<a name="l00393"></a>00393       infos[i] = (<span class="keywordtype">char</span>*)malloc((MAX_LINE_LENGTH+1)*<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));
<a name="l00394"></a>00394     error = ex_get_info(exoid, infos);
<a name="l00395"></a>00395     <span class="keywordflow">if</span> (error != 0) {
<a name="l00396"></a>00396       fprintf(stderr, <span class="stringliteral">"Error: failed to read info records\n"</span>);
<a name="l00397"></a>00397     fflush(NULL);
<a name="l00398"></a>00398     exit(-1);
<a name="l00399"></a>00399     }
<a name="l00400"></a>00400     <span class="keywordflow">for</span> (i = 0; i &lt; num_info; i++) {
<a name="l00401"></a>00401       printf(<span class="stringliteral">"Info Record #%d:\n"</span>, i);
<a name="l00402"></a>00402       printf(<span class="stringliteral">" %s\n"</span>, infos[i]);
<a name="l00403"></a>00403       printf(<span class="stringliteral">"\n"</span>);
<a name="l00404"></a>00404       fflush(NULL);
<a name="l00405"></a>00405     }
<a name="l00406"></a>00406     <span class="keywordflow">for</span> (i = 0; i &lt; num_info; i++)
<a name="l00407"></a>00407       free(infos[i]);
<a name="l00408"></a>00408     free(infos);
<a name="l00409"></a>00409   }
<a name="l00410"></a>00410 
<a name="l00411"></a>00411   <span class="comment">// ** Look at the coords</span>
<a name="l00412"></a>00412 
<a name="l00413"></a>00413   <span class="keywordflow">for</span> (i = 0; i &lt; num_dim; i++)
<a name="l00414"></a>00414     coord_names[i] = (<span class="keywordtype">char</span>*)malloc((MAX_STR_LENGTH+1)*<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));
<a name="l00415"></a>00415   error = ex_get_coord_names(exoid, coord_names);
<a name="l00416"></a>00416   <span class="keywordflow">if</span> (error != 0) {
<a name="l00417"></a>00417     fprintf(stderr, <span class="stringliteral">"Error: failed to read coord names\n"</span>);
<a name="l00418"></a>00418     fflush(NULL);
<a name="l00419"></a>00419     exit(-1);
<a name="l00420"></a>00420   }
<a name="l00421"></a>00421   printf(<span class="stringliteral">"Coordinate names:\n"</span>);
<a name="l00422"></a>00422   <span class="keywordflow">for</span> (i = 0; i &lt; num_dim; i++)
<a name="l00423"></a>00423     printf(<span class="stringliteral">"  %s\n"</span>, coord_names[i]);
<a name="l00424"></a>00424   printf(<span class="stringliteral">"\n"</span>);
<a name="l00425"></a>00425   fflush(NULL);
<a name="l00426"></a>00426   <span class="keywordflow">for</span> (i = 0; i &lt; num_dim; i++)
<a name="l00427"></a>00427     free(coord_names[i]);
<a name="l00428"></a>00428 
<a name="l00429"></a>00429   <span class="comment">//node, elem, face, and edge maps</span>
<a name="l00430"></a>00430   <span class="keywordflow">for</span> (i = 0; i &lt; NUMTYPES; i++){
<a name="l00431"></a>00431     <span class="keywordtype">int</span> obj_type;
<a name="l00432"></a>00432     <span class="keywordtype">char</span>* str;
<a name="l00433"></a>00433     <span class="keywordflow">switch</span> (i){
<a name="l00434"></a>00434     <span class="keywordflow">case</span> <a class="code" href="exodump_8c.html#99fb83031ce9923c84392b4e92f956b559a889456a2d742fdca191dccb3e871d">NODE</a>:
<a name="l00435"></a>00435       obj_type = EX_NODE_MAP;
<a name="l00436"></a>00436       str = <span class="stringliteral">"Node Number"</span>;
<a name="l00437"></a>00437       <span class="keywordflow">break</span>;
<a name="l00438"></a>00438     <span class="keywordflow">case</span> <a class="code" href="exodump_8c.html#99fb83031ce9923c84392b4e92f956b5b2cc30231b3e7e8bca714c8750523660">ELEM</a>:
<a name="l00439"></a>00439       obj_type = EX_ELEM_MAP;
<a name="l00440"></a>00440       str = <span class="stringliteral">"Elem Number"</span>;
<a name="l00441"></a>00441       <span class="keywordflow">break</span>;
<a name="l00442"></a>00442     <span class="keywordflow">case</span> <a class="code" href="exodump_8c.html#99fb83031ce9923c84392b4e92f956b55cfae78048cf95359061c2e812e7d691">FACE</a>:
<a name="l00443"></a>00443       obj_type = EX_FACE_MAP;
<a name="l00444"></a>00444       str = <span class="stringliteral">"Face Number"</span>;
<a name="l00445"></a>00445       <span class="keywordflow">break</span>;
<a name="l00446"></a>00446     <span class="keywordflow">case</span> <a class="code" href="exodump_8c.html#99fb83031ce9923c84392b4e92f956b5a622cbc12b78e3e883dd7b3217088a66">EDGE</a>:
<a name="l00447"></a>00447       obj_type = EX_EDGE_MAP;
<a name="l00448"></a>00448       str = <span class="stringliteral">"Edge Number"</span>;
<a name="l00449"></a>00449       <span class="keywordflow">break</span>;
<a name="l00450"></a>00450     <span class="keywordflow">default</span>:
<a name="l00451"></a>00451       fprintf(stderr, <span class="stringliteral">"Error: bad type for map\n"</span>);
<a name="l00452"></a>00452       fflush(NULL);
<a name="l00453"></a>00453       exit(-1);
<a name="l00454"></a>00454     }
<a name="l00455"></a>00455 
<a name="l00456"></a>00456     <span class="keywordflow">if</span> (num_map[i] != 0){
<a name="l00457"></a>00457       ids = (<span class="keywordtype">int</span>*)malloc(num_map[i]*<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
<a name="l00458"></a>00458       error = ex_get_ids(exoid, obj_type, ids);
<a name="l00459"></a>00459       <span class="keywordflow">if</span> (error != 0) {
<a name="l00460"></a>00460      fprintf(stderr, <span class="stringliteral">"Error: failed to read map ids\n"</span>);
<a name="l00461"></a>00461      fflush(NULL);
<a name="l00462"></a>00462      exit(-1);
<a name="l00463"></a>00463       }
<a name="l00464"></a>00464       
<a name="l00465"></a>00465       <span class="keywordflow">for</span> (j = 0; j &lt; num_map[i]; j++){
<a name="l00466"></a>00466      error = ex_get_num_map(exoid, obj_type, ids[j], map);
<a name="l00467"></a>00467      free(map);
<a name="l00468"></a>00468      <span class="keywordflow">if</span> (error &lt; 0) {
<a name="l00469"></a>00469        fprintf(stderr, <span class="stringliteral">"Error: failed to read %s map %d \n"</span>,str,j);
<a name="l00470"></a>00470        fflush(NULL);
<a name="l00471"></a>00471        exit(-1);
<a name="l00472"></a>00472      }
<a name="l00473"></a>00473      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (error &gt; 0)
<a name="l00474"></a>00474        printf(<span class="stringliteral">"%s map (ID = %d) does not exist\n"</span>,str,ids[j]);
<a name="l00475"></a>00475      <span class="keywordflow">else</span> 
<a name="l00476"></a>00476        printf(<span class="stringliteral">"%s map (ID = %d) exists\n"</span>,str,ids[j]);
<a name="l00477"></a>00477      printf(<span class="stringliteral">"\n"</span>);
<a name="l00478"></a>00478      fflush(NULL);
<a name="l00479"></a>00479       }
<a name="l00480"></a>00480     }
<a name="l00481"></a>00481 
<a name="l00482"></a>00482     <span class="comment">//only look at the order map if its elements - can have this w/o a number map</span>
<a name="l00483"></a>00483     <span class="keywordflow">if</span> (i == <a class="code" href="exodump_8c.html#99fb83031ce9923c84392b4e92f956b5b2cc30231b3e7e8bca714c8750523660">ELEM</a>){
<a name="l00484"></a>00484       map = (<span class="keywordtype">int</span>*)malloc(num_elem*<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
<a name="l00485"></a>00485       error = ex_get_map(exoid, map);
<a name="l00486"></a>00486       <span class="comment">//      printf ("\nafter ex_get_map, error = %3d\n", error);</span>
<a name="l00487"></a>00487       <span class="keywordflow">if</span> (error &lt; 0) {
<a name="l00488"></a>00488      fprintf(stderr, <span class="stringliteral">"Error: failed to read elem order map\n"</span>);
<a name="l00489"></a>00489      fflush(NULL);
<a name="l00490"></a>00490      exit(-1);
<a name="l00491"></a>00491       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (error &gt; 0){
<a name="l00492"></a>00492      printf(<span class="stringliteral">"Warning reading elem order map\n"</span>);
<a name="l00493"></a>00493       } <span class="keywordflow">else</span> {
<a name="l00494"></a>00494      printf(<span class="stringliteral">"Elem order map exists\n"</span>);
<a name="l00495"></a>00495      <span class="comment">//FCLib does nothing with the order map</span>
<a name="l00496"></a>00496      <span class="comment">//    for (i=0; i&lt; num_elem; i++){</span>
<a name="l00497"></a>00497      <span class="comment">//      printf ("elem_map(%d) = %d \n", i, map[i]);</span>
<a name="l00498"></a>00498      <span class="comment">//    }</span>
<a name="l00499"></a>00499      printf(<span class="stringliteral">"\n"</span>);
<a name="l00500"></a>00500       }
<a name="l00501"></a>00501       fflush(NULL);
<a name="l00502"></a>00502       free(map);
<a name="l00503"></a>00503     }
<a name="l00504"></a>00504   } <span class="comment">// numtypes</span>
<a name="l00505"></a>00505 
<a name="l00506"></a>00506 
<a name="l00507"></a>00507   <span class="keywordflow">for</span> (i = 0; i &lt; NUMBLKTYPES; i++){
<a name="l00508"></a>00508     <span class="keywordtype">int</span> obj_type;
<a name="l00509"></a>00509     <span class="keywordtype">char</span>* str;
<a name="l00510"></a>00510     <span class="keywordflow">switch</span> (i){
<a name="l00511"></a>00511     <span class="keywordflow">case</span> <a class="code" href="exodump_8c.html#df764cbdea00d65edcd07bb9953ad2b70db96ed158ef1efb317e4db5fe0acee5">ELEMBLK</a>:
<a name="l00512"></a>00512       obj_type = EX_ELEM_BLOCK;
<a name="l00513"></a>00513       str = <span class="stringliteral">"ElemBlk"</span>;
<a name="l00514"></a>00514       <span class="keywordflow">break</span>;
<a name="l00515"></a>00515     <span class="keywordflow">case</span> <a class="code" href="exodump_8c.html#df764cbdea00d65edcd07bb9953ad2b7ea53c3565ed51a2f2b2a22c1e24f3258">FACEBLK</a>:
<a name="l00516"></a>00516       obj_type = EX_FACE_BLOCK;
<a name="l00517"></a>00517       str = <span class="stringliteral">"FaceBlk"</span>;
<a name="l00518"></a>00518       <span class="keywordflow">break</span>;
<a name="l00519"></a>00519     <span class="keywordflow">case</span> <a class="code" href="exodump_8c.html#df764cbdea00d65edcd07bb9953ad2b70032e1b185783e3dc3eb4c744e836b2c">EDGEBLK</a>:
<a name="l00520"></a>00520       obj_type = EX_EDGE_BLOCK;
<a name="l00521"></a>00521       str = <span class="stringliteral">"EdgeBlk"</span>;
<a name="l00522"></a>00522       <span class="keywordflow">break</span>;
<a name="l00523"></a>00523     <span class="keywordflow">default</span>:
<a name="l00524"></a>00524       fprintf(stderr, <span class="stringliteral">"Error: bad block type\n"</span>);
<a name="l00525"></a>00525       fflush(NULL);
<a name="l00526"></a>00526       exit(-1);
<a name="l00527"></a>00527     }
<a name="l00528"></a>00528 
<a name="l00529"></a>00529     <span class="keywordflow">if</span> (num_blk[i] == 0){
<a name="l00530"></a>00530       <span class="keywordflow">continue</span>;
<a name="l00531"></a>00531     }
<a name="l00532"></a>00532 
<a name="l00533"></a>00533     ids = (<span class="keywordtype">int</span>*)malloc(num_blk[i]*<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
<a name="l00534"></a>00534     error = ex_get_ids(exoid, obj_type, ids);
<a name="l00535"></a>00535     <span class="keywordflow">if</span> (error != 0) {
<a name="l00536"></a>00536       fprintf(stderr, <span class="stringliteral">"Error: failed to read block ids\n"</span>);
<a name="l00537"></a>00537       fflush(NULL);
<a name="l00538"></a>00538       exit(-1);
<a name="l00539"></a>00539     }
<a name="l00540"></a>00540     <span class="keywordflow">for</span> (j = 0; j &lt; num_blk[i]; j++) {
<a name="l00541"></a>00541       <span class="keywordtype">int</span> num_entries_in_blk, num_nodes_per_entry, num_attr_per_entry;
<a name="l00542"></a>00542       <span class="keywordtype">int</span> num_edges_per_entry, num_faces_per_entry;
<a name="l00543"></a>00543       <span class="keywordtype">char</span> blk_type_name[MAX_STR_LENGTH+1];
<a name="l00544"></a>00544 
<a name="l00545"></a>00545       error = ex_get_block(exoid, obj_type, ids[j], blk_type_name, &amp;num_entries_in_blk,
<a name="l00546"></a>00546                   &amp;num_nodes_per_entry, &amp;num_edges_per_entry,
<a name="l00547"></a>00547                   &amp;num_faces_per_entry, &amp;num_attr_per_entry);
<a name="l00548"></a>00548       <span class="keywordflow">if</span> (error != 0) {
<a name="l00549"></a>00549      fprintf(stderr, <span class="stringliteral">"Error: failed to read block\n"</span>);
<a name="l00550"></a>00550      fflush(NULL);
<a name="l00551"></a>00551      exit(-1);
<a name="l00552"></a>00552       }
<a name="l00553"></a>00553       namebuf[0] = <span class="charliteral">'\0'</span>;
<a name="l00554"></a>00554 
<a name="l00555"></a>00555       error = ex_get_name(exoid, obj_type, ids[j], namebuf);
<a name="l00556"></a>00556       <span class="keywordflow">if</span> (error != 0) {
<a name="l00557"></a>00557      fprintf(stderr, <span class="stringliteral">"Error: failed to get block name\n"</span>);
<a name="l00558"></a>00558      fflush(NULL);
<a name="l00559"></a>00559      exit(-1);
<a name="l00560"></a>00560       }
<a name="l00561"></a>00561 
<a name="l00562"></a>00562       printf(<span class="stringliteral">"%s (ID = %d): '%s'\n"</span>, str, ids[j], namebuf);
<a name="l00563"></a>00563       <span class="keywordflow">switch</span>(i){
<a name="l00564"></a>00564       <span class="keywordflow">case</span> <a class="code" href="exodump_8c.html#df764cbdea00d65edcd07bb9953ad2b70db96ed158ef1efb317e4db5fe0acee5">ELEMBLK</a>:
<a name="l00565"></a>00565      printf(<span class="stringliteral">"  num_elem_in_blk = %d, num_nodes_per_elem = %d, num_faces_per_elem = % d, num_edges_per_elem = % d, elem_type = %s\n"</span>,
<a name="l00566"></a>00566             num_entries_in_blk, num_nodes_per_entry, num_faces_per_entry, num_edges_per_entry, blk_type_name);
<a name="l00567"></a>00567      <span class="keywordflow">break</span>;
<a name="l00568"></a>00568       <span class="keywordflow">case</span> <a class="code" href="exodump_8c.html#df764cbdea00d65edcd07bb9953ad2b7ea53c3565ed51a2f2b2a22c1e24f3258">FACEBLK</a>:
<a name="l00569"></a>00569      printf(<span class="stringliteral">"  num_faces_in_blk = %d, num_nodes_per_face = %d, face_type = %s\n"</span>,
<a name="l00570"></a>00570             num_entries_in_blk, num_nodes_per_entry, blk_type_name);
<a name="l00571"></a>00571      <span class="keywordflow">break</span>;
<a name="l00572"></a>00572       <span class="keywordflow">case</span> <a class="code" href="exodump_8c.html#df764cbdea00d65edcd07bb9953ad2b70032e1b185783e3dc3eb4c744e836b2c">EDGEBLK</a>:
<a name="l00573"></a>00573      printf(<span class="stringliteral">"  num_edges_in_blk = %d, num_nodes_per_edge = %d, edge_type = %s\n"</span>,
<a name="l00574"></a>00574             num_entries_in_blk, num_nodes_per_entry, blk_type_name);
<a name="l00575"></a>00575      <span class="keywordflow">break</span>;
<a name="l00576"></a>00576       <span class="keywordflow">default</span>:
<a name="l00577"></a>00577      fprintf(stderr, <span class="stringliteral">"Error: bad block type\n"</span>);
<a name="l00578"></a>00578      fflush(NULL);
<a name="l00579"></a>00579      exit(-1);
<a name="l00580"></a>00580       }
<a name="l00581"></a>00581 
<a name="l00582"></a>00582       printf(<span class="stringliteral">"  Attributes: %d:\n"</span>, num_attr_per_entry);
<a name="l00583"></a>00583       fflush(NULL);
<a name="l00584"></a>00584 
<a name="l00585"></a>00585       <span class="keywordflow">if</span> (num_attr_per_entry &gt; 0) {
<a name="l00586"></a>00586      <span class="keywordtype">char</span>** attr_names = (<span class="keywordtype">char</span>**)malloc(num_attr_per_entry*<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>*));
<a name="l00587"></a>00587      <span class="keywordtype">double</span>* attr_vals = (<span class="keywordtype">double</span>*)malloc(num_entries_in_blk*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l00588"></a>00588      <span class="keywordflow">if</span> (!attr_names || !attr_vals){
<a name="l00589"></a>00589        exit(-1);
<a name="l00590"></a>00590      }
<a name="l00591"></a>00591      <span class="keywordflow">for</span> (k = 0; k &lt; num_attr_per_entry; k++){
<a name="l00592"></a>00592        attr_names[k] = (<span class="keywordtype">char</span>*)malloc((MAX_STR_LENGTH+1)*<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>*));
<a name="l00593"></a>00593        <span class="keywordflow">if</span> (!attr_names[k]){
<a name="l00594"></a>00594          exit(-1);
<a name="l00595"></a>00595        }
<a name="l00596"></a>00596      }
<a name="l00597"></a>00597      error = ex_get_attr_names(exoid, obj_type, ids[j], attr_names);
<a name="l00598"></a>00598      <span class="keywordflow">if</span> (error != 0) {
<a name="l00599"></a>00599        fprintf(stderr, <span class="stringliteral">"Error: failed to get blk attr names\n"</span>);
<a name="l00600"></a>00600        fflush(NULL);
<a name="l00601"></a>00601        exit(-1);
<a name="l00602"></a>00602      }
<a name="l00603"></a>00603      <span class="keywordflow">for</span> (k = 0; k &lt; num_attr_per_entry; k++) {
<a name="l00604"></a>00604        printf(<span class="stringliteral">"   #%d: '%s'\n"</span>, k, attr_names[k]);
<a name="l00605"></a>00605        <span class="keywordflow">if</span> (getconns){
<a name="l00606"></a>00606          error = ex_get_one_attr(exoid, obj_type, ids[j], k+1, attr_vals);
<a name="l00607"></a>00607          <span class="keywordflow">if</span> (error != 0) {
<a name="l00608"></a>00608            fprintf(stderr, <span class="stringliteral">"Error: failed to get blk attr\n"</span>);
<a name="l00609"></a>00609            fflush(NULL);
<a name="l00610"></a>00610            exit(-1);
<a name="l00611"></a>00611          }
<a name="l00612"></a>00612          <span class="keywordflow">for</span> (kk = 0; kk &lt; num_entries_in_blk; kk++){
<a name="l00613"></a>00613            printf(<span class="stringliteral">"\t %d: %g\n"</span>, kk, attr_vals[kk]);
<a name="l00614"></a>00614            fflush(NULL);
<a name="l00615"></a>00615          }
<a name="l00616"></a>00616        } <span class="comment">//getconns</span>
<a name="l00617"></a>00617      } <span class="comment">//numattr</span>
<a name="l00618"></a>00618      <span class="keywordflow">for</span> (k = 0 ; k &lt; num_attr_per_entry; k++){
<a name="l00619"></a>00619        free(attr_names[k]);
<a name="l00620"></a>00620      }
<a name="l00621"></a>00621      free(attr_names);
<a name="l00622"></a>00622      free(attr_vals);
<a name="l00623"></a>00623       }
<a name="l00624"></a>00624       printf(<span class="stringliteral">"\n"</span>);
<a name="l00625"></a>00625       fflush(NULL);
<a name="l00626"></a>00626 
<a name="l00627"></a>00627       <span class="comment">// ** block conns (internal ids, so the full sequential numbering is represented)</span>
<a name="l00628"></a>00628       <span class="keywordflow">if</span> (getconns){      
<a name="l00629"></a>00629      <span class="keywordtype">int</span> *node_connect;
<a name="l00630"></a>00630      <span class="keywordtype">int</span> *face_connect;
<a name="l00631"></a>00631         <span class="keywordtype">int</span> *edge_connect;
<a name="l00632"></a>00632      node_connect = (<span class="keywordtype">int</span>*) malloc(num_entries_in_blk*num_nodes_per_entry*<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
<a name="l00633"></a>00633      face_connect = NULL;
<a name="l00634"></a>00634      edge_connect = NULL;
<a name="l00635"></a>00635      <span class="keywordflow">if</span> (i == <a class="code" href="exodump_8c.html#df764cbdea00d65edcd07bb9953ad2b70db96ed158ef1efb317e4db5fe0acee5">ELEMBLK</a>){
<a name="l00636"></a>00636        face_connect = (<span class="keywordtype">int</span>*) malloc(num_entries_in_blk*num_faces_per_entry*<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
<a name="l00637"></a>00637        edge_connect = (<span class="keywordtype">int</span>*) malloc(num_entries_in_blk*num_edges_per_entry*<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));  
<a name="l00638"></a>00638      }
<a name="l00639"></a>00639      error = ex_get_conn(exoid, obj_type, ids[j], node_connect, edge_connect, face_connect);
<a name="l00640"></a>00640      <span class="keywordflow">if</span> (error != 0) {
<a name="l00641"></a>00641        fprintf(stderr, <span class="stringliteral">"Error: failed to get block conns\n"</span>);
<a name="l00642"></a>00642        fflush(NULL);
<a name="l00643"></a>00643        exit(-1);
<a name="l00644"></a>00644      }
<a name="l00645"></a>00645      printf(<span class="stringliteral">" node conns:\n"</span>);
<a name="l00646"></a>00646      <span class="keywordflow">for</span> (k = 0; k &lt; num_entries_in_blk; k++){
<a name="l00647"></a>00647        printf(<span class="stringliteral">"  Entry #%d ("</span>, k+1); <span class="comment">//exodus numbering starts with 1 </span>
<a name="l00648"></a>00648        <span class="keywordflow">for</span> (kk = 0; kk &lt; num_nodes_per_entry; kk++){
<a name="l00649"></a>00649          printf(<span class="stringliteral">"%d "</span>, node_connect[k*num_nodes_per_entry+kk]);
<a name="l00650"></a>00650        }
<a name="l00651"></a>00651        printf(<span class="stringliteral">")\n"</span>);
<a name="l00652"></a>00652      }
<a name="l00653"></a>00653      fflush(NULL);
<a name="l00654"></a>00654      <span class="keywordflow">if</span> ( i == <a class="code" href="exodump_8c.html#df764cbdea00d65edcd07bb9953ad2b70db96ed158ef1efb317e4db5fe0acee5">ELEMBLK</a> ){
<a name="l00655"></a>00655        <span class="keywordflow">if</span> (num_faces_per_entry &gt; 0){
<a name="l00656"></a>00656          printf(<span class="stringliteral">" face conns:\n"</span>);
<a name="l00657"></a>00657          <span class="keywordflow">for</span> (k = 0; k &lt; num_entries_in_blk; k++){ <span class="comment">//elems</span>
<a name="l00658"></a>00658            printf(<span class="stringliteral">"  Entry #%d ("</span>, k+1); <span class="comment">//exodus numbering starts with 1</span>
<a name="l00659"></a>00659            <span class="keywordflow">for</span> (kk = 0; kk &lt; num_faces_per_entry; kk++){
<a name="l00660"></a>00660           printf(<span class="stringliteral">"%d "</span>, face_connect[k*num_faces_per_entry+kk]);
<a name="l00661"></a>00661            }
<a name="l00662"></a>00662            printf(<span class="stringliteral">")\n"</span>);
<a name="l00663"></a>00663          }
<a name="l00664"></a>00664        } <span class="keywordflow">else</span> {
<a name="l00665"></a>00665          printf(<span class="stringliteral">" no face conns\n"</span>);
<a name="l00666"></a>00666        } 
<a name="l00667"></a>00667        fflush(NULL);
<a name="l00668"></a>00668        <span class="keywordflow">if</span> (num_edges_per_entry &gt; 0){
<a name="l00669"></a>00669          printf(<span class="stringliteral">" edge conns:\n"</span>);
<a name="l00670"></a>00670          <span class="keywordflow">for</span> (k = 0; k &lt; num_entries_in_blk; k++){ <span class="comment">//elems</span>
<a name="l00671"></a>00671            printf(<span class="stringliteral">"  Entry #%d ("</span>, k+1); <span class="comment">//exodus numbering starts with 1</span>
<a name="l00672"></a>00672            <span class="keywordflow">for</span> (kk = 0; kk &lt; num_edges_per_entry; kk++){
<a name="l00673"></a>00673           printf(<span class="stringliteral">"%d "</span>, edge_connect[k*num_edges_per_entry+kk]);
<a name="l00674"></a>00674            }
<a name="l00675"></a>00675            printf(<span class="stringliteral">")\n"</span>);
<a name="l00676"></a>00676          }
<a name="l00677"></a>00677        } <span class="keywordflow">else</span> {
<a name="l00678"></a>00678          printf(<span class="stringliteral">" no edge conns\n"</span>);
<a name="l00679"></a>00679        } 
<a name="l00680"></a>00680        fflush(NULL);
<a name="l00681"></a>00681      }
<a name="l00682"></a>00682      <span class="keywordflow">if</span> (edge_connect) free(edge_connect);
<a name="l00683"></a>00683      <span class="keywordflow">if</span> (face_connect) free(face_connect);
<a name="l00684"></a>00684      <span class="keywordflow">if</span> (node_connect) free(node_connect);
<a name="l00685"></a>00685       }
<a name="l00686"></a>00686       printf(<span class="stringliteral">"\n"</span>);
<a name="l00687"></a>00687     }
<a name="l00688"></a>00688 
<a name="l00689"></a>00689     <span class="comment">// ** block properties</span>
<a name="l00690"></a>00690 
<a name="l00691"></a>00691     <span class="keywordflow">if</span> (num_blk_prop[i] &gt; 0) {
<a name="l00692"></a>00692       prop_names = (<span class="keywordtype">char</span>**)malloc(num_blk_prop[i]*<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>*));
<a name="l00693"></a>00693       <span class="keywordflow">for</span> (j = 0; j &lt; num_blk_prop[i]; j++)
<a name="l00694"></a>00694      prop_names[j] = (<span class="keywordtype">char</span>*)malloc((MAX_STR_LENGTH+1)*<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));
<a name="l00695"></a>00695       error = ex_get_prop_names(exoid, obj_type, prop_names);
<a name="l00696"></a>00696       <span class="keywordflow">if</span> (error != 0) {
<a name="l00697"></a>00697      fprintf(stderr, <span class="stringliteral">"Error: failed to get blk prop names\n"</span>);
<a name="l00698"></a>00698      fflush(NULL);
<a name="l00699"></a>00699      exit(-1);
<a name="l00700"></a>00700       }
<a name="l00701"></a>00701       <span class="keywordflow">for</span> (j = 0; j &lt; num_blk_prop[i]; j++) {
<a name="l00702"></a>00702      printf(<span class="stringliteral">"%s Property  #%d: '%s'\n"</span>, str, j, prop_names[j]);
<a name="l00703"></a>00703      <span class="keywordflow">for</span> (k = 0; k &lt; num_blk[i]; k++) {
<a name="l00704"></a>00704        <span class="keywordtype">int</span> prop_value;
<a name="l00705"></a>00705        error = ex_get_prop(exoid, obj_type, ids[k], prop_names[j],
<a name="l00706"></a>00706                      &amp;prop_value);
<a name="l00707"></a>00707        <span class="keywordflow">if</span> (error != 0) {
<a name="l00708"></a>00708          fprintf(stderr, <span class="stringliteral">"Error: failed to get blk prop\n"</span>);
<a name="l00709"></a>00709          exit(-1);
<a name="l00710"></a>00710        }
<a name="l00711"></a>00711        printf(<span class="stringliteral">"  %s (ID = %d): %d\n"</span>, str, ids[k], prop_value);
<a name="l00712"></a>00712      }
<a name="l00713"></a>00713      printf(<span class="stringliteral">"\n"</span>);
<a name="l00714"></a>00714      fflush(NULL);
<a name="l00715"></a>00715       }
<a name="l00716"></a>00716 
<a name="l00717"></a>00717       <span class="keywordflow">for</span> (j = 0; j &lt; num_blk_prop[i]; j++)
<a name="l00718"></a>00718      free(prop_names[j]);
<a name="l00719"></a>00719       free(prop_names);
<a name="l00720"></a>00720     }
<a name="l00721"></a>00721 
<a name="l00722"></a>00722     <span class="comment">// done with block ids</span>
<a name="l00723"></a>00723     free(ids);
<a name="l00724"></a>00724   }
<a name="l00725"></a>00725 
<a name="l00726"></a>00726 
<a name="l00727"></a>00727   <span class="keywordflow">for</span> (i = 0; i &lt; NUMSETTYPES; i++){
<a name="l00728"></a>00728     <span class="keywordtype">int</span> obj_type;
<a name="l00729"></a>00729     <span class="keywordtype">char</span>* str;
<a name="l00730"></a>00730     <span class="keywordflow">switch</span> (i){
<a name="l00731"></a>00731     <span class="keywordflow">case</span> <a class="code" href="exodump_8c.html#06fc87d81c62e9abb8790b6e5713c55b7b4c0e5ae1385e1224a6e59abf47ecc0">NODESET</a>:
<a name="l00732"></a>00732       str = <span class="stringliteral">"NodeSet"</span>;
<a name="l00733"></a>00733       obj_type = EX_NODE_SET;
<a name="l00734"></a>00734       <span class="keywordflow">break</span>;
<a name="l00735"></a>00735     <span class="keywordflow">case</span> <a class="code" href="exodump_8c.html#06fc87d81c62e9abb8790b6e5713c55bf2cc6d0bdf89f64e022a1dd3ac9bf31e">ELEMSET</a>:
<a name="l00736"></a>00736       str = <span class="stringliteral">"ElemSet"</span>;
<a name="l00737"></a>00737       obj_type = EX_ELEM_SET;
<a name="l00738"></a>00738       <span class="keywordflow">break</span>;
<a name="l00739"></a>00739     <span class="keywordflow">case</span> <a class="code" href="exodump_8c.html#06fc87d81c62e9abb8790b6e5713c55bf03e67951597561f7910379848050552">FACESET</a>:
<a name="l00740"></a>00740       str = <span class="stringliteral">"FaceSet"</span>;
<a name="l00741"></a>00741       obj_type = EX_FACE_SET;
<a name="l00742"></a>00742       <span class="keywordflow">break</span>;
<a name="l00743"></a>00743     <span class="keywordflow">case</span> <a class="code" href="exodump_8c.html#06fc87d81c62e9abb8790b6e5713c55b0f9cb4d6eb49d02851626be8b5b9bf01">EDGESET</a>:
<a name="l00744"></a>00744       str = <span class="stringliteral">"EdgeSet"</span>;
<a name="l00745"></a>00745       obj_type = EX_EDGE_SET;
<a name="l00746"></a>00746       <span class="keywordflow">break</span>;
<a name="l00747"></a>00747     <span class="keywordflow">case</span> <a class="code" href="exodump_8c.html#06fc87d81c62e9abb8790b6e5713c55b86c05035d6a2fbc5762f39215d6a8a22">SIDESET</a>:
<a name="l00748"></a>00748       str = <span class="stringliteral">"SideSet"</span>;
<a name="l00749"></a>00749       obj_type = EX_SIDE_SET;
<a name="l00750"></a>00750       <span class="keywordflow">break</span>;
<a name="l00751"></a>00751     <span class="keywordflow">default</span>:
<a name="l00752"></a>00752       fprintf(stderr, <span class="stringliteral">"Error: bad set type\n"</span>);
<a name="l00753"></a>00753       fflush(NULL);
<a name="l00754"></a>00754       exit(-1);
<a name="l00755"></a>00755     }
<a name="l00756"></a>00756 
<a name="l00757"></a>00757     <span class="keywordflow">if</span> (num_set[i] == 0){
<a name="l00758"></a>00758       <span class="keywordflow">continue</span>;
<a name="l00759"></a>00759     }
<a name="l00760"></a>00760 
<a name="l00761"></a>00761     ids = (<span class="keywordtype">int</span>*)malloc(num_set[i]*<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
<a name="l00762"></a>00762     error = ex_get_ids(exoid, obj_type, ids);
<a name="l00763"></a>00763     <span class="keywordflow">if</span> (error != 0) {
<a name="l00764"></a>00764       fprintf(stderr, <span class="stringliteral">"Error: failed to read set ids\n"</span>);
<a name="l00765"></a>00765       fflush(NULL);
<a name="l00766"></a>00766       exit(-1);
<a name="l00767"></a>00767     }
<a name="l00768"></a>00768     <span class="keywordflow">for</span> (j = 0; j &lt; num_set[i]; j++) {
<a name="l00769"></a>00769       <span class="keywordtype">int</span> num_entries_in_set, num_df_in_set;
<a name="l00770"></a>00770       <span class="keywordtype">int</span> *set_entity_list, *set_extra_list;
<a name="l00771"></a>00771       error = ex_get_set_param(exoid, obj_type, ids[j], &amp;num_entries_in_set,
<a name="l00772"></a>00772                                     &amp;num_df_in_set);
<a name="l00773"></a>00773       <span class="keywordflow">if</span> (error != 0) {
<a name="l00774"></a>00774         fprintf(stderr, <span class="stringliteral">"Error: failed to get set params\n"</span>);
<a name="l00775"></a>00775         exit(-1);
<a name="l00776"></a>00776       }
<a name="l00777"></a>00777       namebuf[0] = <span class="charliteral">'\0'</span>;
<a name="l00778"></a>00778       error = ex_get_name(exoid, obj_type, ids[j], namebuf);
<a name="l00779"></a>00779       <span class="keywordflow">if</span> (error != 0) {
<a name="l00780"></a>00780         fprintf(stderr, <span class="stringliteral">"Error: failed to get set name\n"</span>);
<a name="l00781"></a>00781         fflush(NULL);
<a name="l00782"></a>00782         exit(-1);
<a name="l00783"></a>00783       }
<a name="l00784"></a>00784       printf(<span class="stringliteral">"%s (ID = %d): '%s'\n"</span>, str, ids[j], namebuf);
<a name="l00785"></a>00785       printf(<span class="stringliteral">"  num_entries_in_set = %d, num_df_in_set = %d\n"</span>,
<a name="l00786"></a>00786              num_entries_in_set, num_df_in_set);
<a name="l00787"></a>00787       printf(<span class="stringliteral">"\n"</span>);
<a name="l00788"></a>00788       fflush(NULL);
<a name="l00789"></a>00789 
<a name="l00790"></a>00790       <span class="keywordflow">if</span> (getconns){
<a name="l00791"></a>00791      set_entity_list = (<span class="keywordtype">int</span>*)malloc(num_entries_in_set*<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
<a name="l00792"></a>00792      <span class="keywordflow">if</span> (i != <a class="code" href="exodump_8c.html#06fc87d81c62e9abb8790b6e5713c55b7b4c0e5ae1385e1224a6e59abf47ecc0">NODESET</a> &amp;&amp; i!= <a class="code" href="exodump_8c.html#06fc87d81c62e9abb8790b6e5713c55bf2cc6d0bdf89f64e022a1dd3ac9bf31e">ELEMSET</a>){
<a name="l00793"></a>00793        <span class="comment">//FIXME - is there anyway to know if there is an extra list or not?</span>
<a name="l00794"></a>00794        set_extra_list = (<span class="keywordtype">int</span>*)malloc(num_entries_in_set*<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
<a name="l00795"></a>00795      } <span class="keywordflow">else</span> {
<a name="l00796"></a>00796        set_extra_list = NULL;
<a name="l00797"></a>00797      }
<a name="l00798"></a>00798      error = ex_get_set(exoid, obj_type, ids[j], set_entity_list, set_extra_list);
<a name="l00799"></a>00799      <span class="keywordflow">if</span> (error &lt; 0 ) { 
<a name="l00800"></a>00800        fprintf(stderr, <span class="stringliteral">"Error: failed to get set entities\n"</span>);
<a name="l00801"></a>00801        fflush(NULL);
<a name="l00802"></a>00802        exit(-1);
<a name="l00803"></a>00803      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (error &gt; 0){
<a name="l00804"></a>00804        fprintf(stderr, <span class="stringliteral">"Warning: failed to get set entities\n"</span>);
<a name="l00805"></a>00805        fflush(NULL);
<a name="l00806"></a>00806      } <span class="keywordflow">else</span> {
<a name="l00807"></a>00807        <span class="keywordflow">switch</span> (i){
<a name="l00808"></a>00808        <span class="keywordflow">case</span> <a class="code" href="exodump_8c.html#06fc87d81c62e9abb8790b6e5713c55b7b4c0e5ae1385e1224a6e59abf47ecc0">NODESET</a>:
<a name="l00809"></a>00809          printf(<span class="stringliteral">"  node_id:\n"</span>);
<a name="l00810"></a>00810          <span class="keywordflow">for</span> (k = 0; k &lt; num_entries_in_set; k++){
<a name="l00811"></a>00811            printf(<span class="stringliteral">"    %d\n"</span>, set_entity_list[k]);
<a name="l00812"></a>00812          }
<a name="l00813"></a>00813          <span class="keywordflow">break</span>;
<a name="l00814"></a>00814        <span class="keywordflow">case</span> <a class="code" href="exodump_8c.html#06fc87d81c62e9abb8790b6e5713c55bf2cc6d0bdf89f64e022a1dd3ac9bf31e">ELEMSET</a>:
<a name="l00815"></a>00815          printf(<span class="stringliteral">"  elem_id:\n"</span>);
<a name="l00816"></a>00816          <span class="keywordflow">for</span> (k = 0; k &lt; num_entries_in_set; k++){
<a name="l00817"></a>00817            printf(<span class="stringliteral">"    %d\n"</span>, set_entity_list[k]);
<a name="l00818"></a>00818          }
<a name="l00819"></a>00819          <span class="keywordflow">break</span>;
<a name="l00820"></a>00820        <span class="keywordflow">case</span> <a class="code" href="exodump_8c.html#06fc87d81c62e9abb8790b6e5713c55b86c05035d6a2fbc5762f39215d6a8a22">SIDESET</a>:
<a name="l00821"></a>00821          printf(<span class="stringliteral">"  elem_id     side_index:\n"</span>);
<a name="l00822"></a>00822          <span class="keywordflow">for</span> (k = 0; k &lt; num_entries_in_set; k++){
<a name="l00823"></a>00823            printf(<span class="stringliteral">"    %d            %d\n"</span>, set_entity_list[k],
<a name="l00824"></a>00824                set_extra_list[k]);
<a name="l00825"></a>00825          }
<a name="l00826"></a>00826          <span class="keywordflow">break</span>;
<a name="l00827"></a>00827        <span class="keywordflow">default</span>:
<a name="l00828"></a>00828          printf(<span class="stringliteral">"  entity_id   orientation:\n"</span>);
<a name="l00829"></a>00829          <span class="keywordflow">for</span> (k = 0; k &lt; num_entries_in_set; k++){
<a name="l00830"></a>00830            printf(<span class="stringliteral">"    %d            %d\n"</span>, set_entity_list[k],
<a name="l00831"></a>00831                set_extra_list[k]);
<a name="l00832"></a>00832          }
<a name="l00833"></a>00833        }
<a name="l00834"></a>00834      }
<a name="l00835"></a>00835      <span class="keywordflow">if</span> (set_entity_list) free(set_entity_list);
<a name="l00836"></a>00836      <span class="keywordflow">if</span> (set_extra_list) free(set_extra_list);
<a name="l00837"></a>00837       }
<a name="l00838"></a>00838       printf(<span class="stringliteral">"\n"</span>);
<a name="l00839"></a>00839       fflush(NULL);
<a name="l00840"></a>00840     }
<a name="l00841"></a>00841 
<a name="l00842"></a>00842     
<a name="l00843"></a>00843     <span class="comment">// ** set properties</span>
<a name="l00844"></a>00844 
<a name="l00845"></a>00845     <span class="keywordflow">if</span> (num_set_prop[i] &gt; 0){
<a name="l00846"></a>00846       <span class="comment">//FIXME: commented out for elem_set until that gets fixed.</span>
<a name="l00847"></a>00847       <span class="keywordflow">if</span> (i == <a class="code" href="exodump_8c.html#06fc87d81c62e9abb8790b6e5713c55bf2cc6d0bdf89f64e022a1dd3ac9bf31e">ELEMSET</a>) {
<a name="l00848"></a>00848           printf(<span class="stringliteral">"Not printing out elemset prop at this time\n"</span>);
<a name="l00849"></a>00849           <span class="keywordflow">break</span>;
<a name="l00850"></a>00850       }
<a name="l00851"></a>00851 
<a name="l00852"></a>00852       prop_names = (<span class="keywordtype">char</span>**)malloc(num_set_prop[i]*<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>*));
<a name="l00853"></a>00853       <span class="keywordflow">for</span> (j = 0; j &lt; num_set_prop[i]; j++)
<a name="l00854"></a>00854         prop_names[j] = (<span class="keywordtype">char</span>*)malloc((MAX_STR_LENGTH+1)*<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));
<a name="l00855"></a>00855       error = ex_get_prop_names(exoid, obj_type, prop_names);
<a name="l00856"></a>00856       <span class="keywordflow">if</span> (error != 0) {
<a name="l00857"></a>00857         fprintf(stderr, <span class="stringliteral">"Error: failed to get set prop names %d\n"</span>,i);
<a name="l00858"></a>00858         fflush(NULL);
<a name="l00859"></a>00859      exit(-1);
<a name="l00860"></a>00860       } 
<a name="l00861"></a>00861       <span class="keywordflow">for</span> (j = 0; j &lt; num_set_prop[i]; j++) {
<a name="l00862"></a>00862      printf(<span class="stringliteral">"%s Property #%d: '%s'\n"</span>, str, j, prop_names[j]);
<a name="l00863"></a>00863      <span class="keywordflow">for</span> (k = 0; k &lt; num_set[i]; k++) {
<a name="l00864"></a>00864        <span class="keywordtype">int</span> prop_value;
<a name="l00865"></a>00865        <span class="comment">//this will return with EX_WARN if the set is empty.</span>
<a name="l00866"></a>00866        <span class="comment">//that is defined in exodusII_int.h</span>
<a name="l00867"></a>00867        error = ex_get_prop(exoid, obj_type, ids[k], prop_names[j],
<a name="l00868"></a>00868                      &amp;prop_value);
<a name="l00869"></a>00869        <span class="keywordflow">if</span> (error &lt; 0) {
<a name="l00870"></a>00870          fprintf(stderr, <span class="stringliteral">"Error: failed to get set props\n"</span>);
<a name="l00871"></a>00871          fflush(NULL);
<a name="l00872"></a>00872          exit(-1);
<a name="l00873"></a>00873        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (error &gt; 0 ){
<a name="l00874"></a>00874          fprintf(stderr, <span class="stringliteral">"Warning: failed to get set props"</span>);
<a name="l00875"></a>00875        } <span class="keywordflow">else</span> {
<a name="l00876"></a>00876          printf(<span class="stringliteral">"  %s (ID = %d): %d\n"</span>, str, ids[k], prop_value);
<a name="l00877"></a>00877        }
<a name="l00878"></a>00878      }
<a name="l00879"></a>00879      printf(<span class="stringliteral">"\n"</span>);
<a name="l00880"></a>00880      fflush(NULL);
<a name="l00881"></a>00881       }
<a name="l00882"></a>00882       <span class="keywordflow">for</span> (j = 0; j &lt; num_set_prop[i]; j++)
<a name="l00883"></a>00883      free(prop_names[j]);
<a name="l00884"></a>00884       free(prop_names);
<a name="l00885"></a>00885     }
<a name="l00886"></a>00886 
<a name="l00887"></a>00887     <span class="comment">// done with set ids</span>
<a name="l00888"></a>00888     free(ids);
<a name="l00889"></a>00889   }
<a name="l00890"></a>00890 
<a name="l00891"></a>00891 
<a name="l00892"></a>00892   <span class="comment">//get nodal attr </span>
<a name="l00893"></a>00893   {
<a name="l00894"></a>00894     <span class="keywordtype">int</span> num_attrs = 0;
<a name="l00895"></a>00895     error = ex_get_attr_param(exoid, EX_NODAL, 0, &amp;num_attrs);
<a name="l00896"></a>00896     printf (<span class="stringliteral">"NODAL Attributes: %d\n"</span>, num_attrs);
<a name="l00897"></a>00897     <span class="keywordflow">if</span> (num_attrs &gt; 0) {
<a name="l00898"></a>00898       <span class="keywordtype">char</span>** attr_names = (<span class="keywordtype">char</span>**)malloc(num_attrs*<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>*));
<a name="l00899"></a>00899       <span class="keywordtype">double</span>* attr_vals = (<span class="keywordtype">double</span>*)malloc(num_node*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l00900"></a>00900       <span class="keywordflow">for</span> (j=0; j&lt; num_attrs; j++) {
<a name="l00901"></a>00901      attr_names[j] = (<span class="keywordtype">char</span> *)calloc ((MAX_STR_LENGTH+1), <span class="keyword">sizeof</span>(char));
<a name="l00902"></a>00902       }
<a name="l00903"></a>00903       error = ex_get_attr_names (exoid, EX_NODAL, 0, attr_names);
<a name="l00904"></a>00904       <span class="keywordflow">if</span> (error != 0) {
<a name="l00905"></a>00905      fprintf(stderr, <span class="stringliteral">"Error: failed to get nodal attr names\n"</span>);
<a name="l00906"></a>00906      fflush(NULL);
<a name="l00907"></a>00907      exit(-1);
<a name="l00908"></a>00908       }
<a name="l00909"></a>00909       <span class="keywordflow">for</span> (j = 0; j &lt; num_attrs; j++) {
<a name="l00910"></a>00910      printf(<span class="stringliteral">"   #%d: '%s'\n"</span>, j, attr_names[j]);
<a name="l00911"></a>00911      <span class="keywordflow">if</span> (getconns){
<a name="l00912"></a>00912        error = ex_get_one_attr(exoid, EX_NODAL, 0, j+1, attr_vals);
<a name="l00913"></a>00913        <span class="keywordflow">if</span> (error != 0) {
<a name="l00914"></a>00914          fprintf(stderr, <span class="stringliteral">"Error: failed to get blk attr\n"</span>);
<a name="l00915"></a>00915          fflush(NULL);
<a name="l00916"></a>00916          exit(-1);
<a name="l00917"></a>00917        }
<a name="l00918"></a>00918        <span class="keywordflow">for</span> (k = 0; k &lt; num_node; k++){
<a name="l00919"></a>00919          printf(<span class="stringliteral">"\t %d: %g\n"</span>, k, attr_vals[k]);
<a name="l00920"></a>00920          fflush(NULL);
<a name="l00921"></a>00921        }
<a name="l00922"></a>00922      } <span class="comment">//getconns</span>
<a name="l00923"></a>00923       } <span class="comment">//numattr</span>
<a name="l00924"></a>00924       <span class="keywordflow">for</span> (k = 0 ; k &lt; num_attrs; k++){
<a name="l00925"></a>00925      free(attr_names[k]);
<a name="l00926"></a>00926       }
<a name="l00927"></a>00927       free(attr_names);
<a name="l00928"></a>00928       free(attr_vals);
<a name="l00929"></a>00929     }
<a name="l00930"></a>00930     printf(<span class="stringliteral">"\n"</span>);
<a name="l00931"></a>00931     fflush(NULL);
<a name="l00932"></a>00932   }
<a name="l00933"></a>00933 
<a name="l00934"></a>00934   <span class="comment">// ** global variable names</span>
<a name="l00935"></a>00935   
<a name="l00936"></a>00936   <span class="keywordflow">if</span> (num_glob_var &gt; 0) {
<a name="l00937"></a>00937     var_names = (<span class="keywordtype">char</span>**)malloc(num_glob_var*<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>*));
<a name="l00938"></a>00938     <span class="keywordflow">for</span> (i = 0; i &lt; num_glob_var; i++)
<a name="l00939"></a>00939       var_names[i] = (<span class="keywordtype">char</span>*)malloc((MAX_STR_LENGTH+1)*<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));
<a name="l00940"></a>00940     error = ex_get_var_names(exoid, <span class="stringliteral">"g"</span>, num_glob_var, var_names);
<a name="l00941"></a>00941     <span class="keywordflow">if</span> (error != 0) {
<a name="l00942"></a>00942       fprintf(stderr, <span class="stringliteral">"Error: Failed to get global var names\n"</span>);
<a name="l00943"></a>00943       fflush(NULL);
<a name="l00944"></a>00944       exit(-1);
<a name="l00945"></a>00945     }
<a name="l00946"></a>00946     printf(<span class="stringliteral">"Global Variables:\n"</span>);
<a name="l00947"></a>00947     <span class="keywordflow">for</span> (i = 0; i &lt; num_glob_var; i++)
<a name="l00948"></a>00948       printf(<span class="stringliteral">" #%d: %s\n"</span>, i, var_names[i]);
<a name="l00949"></a>00949     <span class="keywordflow">for</span> (i = 0; i &lt; num_glob_var; i++)
<a name="l00950"></a>00950       free(var_names[i]);
<a name="l00951"></a>00951     free(var_names);
<a name="l00952"></a>00952     printf(<span class="stringliteral">"\n"</span>);
<a name="l00953"></a>00953     fflush(NULL);
<a name="l00954"></a>00954   }
<a name="l00955"></a>00955 
<a name="l00956"></a>00956   <span class="comment">// ** nodal variable names</span>
<a name="l00957"></a>00957   
<a name="l00958"></a>00958   <span class="keywordflow">if</span> (num_nodal_var &gt; 0) {
<a name="l00959"></a>00959     var_names = (<span class="keywordtype">char</span>**)malloc(num_nodal_var*<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>*));
<a name="l00960"></a>00960     <span class="keywordflow">for</span> (i = 0; i &lt; num_nodal_var; i++)
<a name="l00961"></a>00961       var_names[i] = (<span class="keywordtype">char</span>*)malloc((MAX_STR_LENGTH+1)*<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));
<a name="l00962"></a>00962     error = ex_get_var_names(exoid, <span class="stringliteral">"n"</span>, num_nodal_var, var_names);
<a name="l00963"></a>00963     <span class="keywordflow">if</span> (error != 0) {
<a name="l00964"></a>00964       fprintf(stderr, <span class="stringliteral">"Error: Failed to get nodal var names\n"</span>);
<a name="l00965"></a>00965       fflush(NULL);
<a name="l00966"></a>00966       exit(-1);
<a name="l00967"></a>00967     }
<a name="l00968"></a>00968     printf(<span class="stringliteral">"Nodal Variables:\n"</span>);
<a name="l00969"></a>00969     <span class="keywordflow">for</span> (i = 0; i &lt; num_nodal_var; i++)
<a name="l00970"></a>00970       printf(<span class="stringliteral">" #%d: %s\n"</span>, i, var_names[i]);
<a name="l00971"></a>00971     <span class="keywordflow">for</span> (i = 0; i &lt; num_nodal_var; i++)
<a name="l00972"></a>00972       free(var_names[i]);
<a name="l00973"></a>00973     free(var_names);
<a name="l00974"></a>00974     printf(<span class="stringliteral">"\n"</span>);
<a name="l00975"></a>00975     fflush(NULL);
<a name="l00976"></a>00976   }
<a name="l00977"></a>00977 
<a name="l00978"></a>00978   <span class="comment">// ** blk vars</span>
<a name="l00979"></a>00979   <span class="keywordflow">for</span> (ii = 0; ii &lt; NUMBLKTYPES; ii++){
<a name="l00980"></a>00980     <span class="keywordtype">char</span>* varinq;
<a name="l00981"></a>00981     <span class="keywordtype">char</span>* str;
<a name="l00982"></a>00982     <span class="keywordflow">switch</span> (ii){
<a name="l00983"></a>00983     <span class="keywordflow">case</span> <a class="code" href="exodump_8c.html#df764cbdea00d65edcd07bb9953ad2b70db96ed158ef1efb317e4db5fe0acee5">ELEMBLK</a>:
<a name="l00984"></a>00984       varinq = <span class="stringliteral">"e"</span>;
<a name="l00985"></a>00985       str = <span class="stringliteral">"ElemBlk"</span>;
<a name="l00986"></a>00986       <span class="keywordflow">break</span>;
<a name="l00987"></a>00987     <span class="keywordflow">case</span> <a class="code" href="exodump_8c.html#df764cbdea00d65edcd07bb9953ad2b7ea53c3565ed51a2f2b2a22c1e24f3258">FACEBLK</a>:
<a name="l00988"></a>00988       varinq = <span class="stringliteral">"f"</span>;
<a name="l00989"></a>00989       str = <span class="stringliteral">"FaceBlk"</span>;
<a name="l00990"></a>00990       <span class="keywordflow">break</span>;
<a name="l00991"></a>00991     <span class="keywordflow">case</span> <a class="code" href="exodump_8c.html#df764cbdea00d65edcd07bb9953ad2b70032e1b185783e3dc3eb4c744e836b2c">EDGEBLK</a>:
<a name="l00992"></a>00992       varinq = <span class="stringliteral">"l"</span>;
<a name="l00993"></a>00993       str = <span class="stringliteral">"EdgeBlk"</span>;
<a name="l00994"></a>00994       <span class="keywordflow">break</span>;
<a name="l00995"></a>00995     <span class="keywordflow">default</span>:
<a name="l00996"></a>00996       fprintf(stderr, <span class="stringliteral">"Error: bad block type\n"</span>);
<a name="l00997"></a>00997       fflush(NULL);
<a name="l00998"></a>00998       exit(-1);
<a name="l00999"></a>00999     }
<a name="l01000"></a>01000 
<a name="l01001"></a>01001 
<a name="l01002"></a>01002     <span class="comment">// blk variable names</span>
<a name="l01003"></a>01003     <span class="keywordflow">if</span> (num_blk_var[ii] &gt; 0) {
<a name="l01004"></a>01004       var_names = (<span class="keywordtype">char</span>**)malloc(num_blk_var[ii]*<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>*));
<a name="l01005"></a>01005       <span class="keywordflow">for</span> (i = 0; i &lt; num_blk_var[ii]; i++)
<a name="l01006"></a>01006      var_names[i] = (<span class="keywordtype">char</span>*)malloc((MAX_STR_LENGTH+1)*<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));
<a name="l01007"></a>01007       error = ex_get_var_names(exoid, varinq, num_blk_var[ii], var_names);
<a name="l01008"></a>01008       <span class="keywordflow">if</span> (error != 0) {
<a name="l01009"></a>01009      fprintf(stderr, <span class="stringliteral">"Error: Failed to get  blk var names\n"</span>);
<a name="l01010"></a>01010      fflush(NULL);
<a name="l01011"></a>01011      exit(-1);
<a name="l01012"></a>01012       }
<a name="l01013"></a>01013       printf(<span class="stringliteral">"%s Variables:\n"</span>,str);
<a name="l01014"></a>01014       <span class="keywordflow">for</span> (i = 0; i &lt; num_blk_var[ii]; i++)
<a name="l01015"></a>01015      printf(<span class="stringliteral">" #%d: %s\n"</span>, i, var_names[i]);
<a name="l01016"></a>01016       <span class="keywordflow">for</span> (i = 0; i &lt; num_blk_var[ii]; i++)
<a name="l01017"></a>01017      free(var_names[i]);
<a name="l01018"></a>01018       free(var_names);
<a name="l01019"></a>01019       printf(<span class="stringliteral">"\n"</span>);
<a name="l01020"></a>01020       fflush(NULL);
<a name="l01021"></a>01021     }
<a name="l01022"></a>01022 
<a name="l01023"></a>01023     <span class="comment">// ** blk var truth table</span>
<a name="l01024"></a>01024     <span class="keywordflow">if</span> (num_blk_var[ii] &gt; 0) {
<a name="l01025"></a>01025       truth_tab = (<span class="keywordtype">int</span>*)malloc(num_blk[ii]*num_blk_var[ii]*<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
<a name="l01026"></a>01026       error = ex_get_var_tab(exoid, varinq, num_blk[ii], num_blk_var[ii], truth_tab);
<a name="l01027"></a>01027       <span class="keywordflow">if</span> (error != 0) {
<a name="l01028"></a>01028      fprintf(stderr, <span class="stringliteral">"Error: Failed to get blk truth table\n"</span>);
<a name="l01029"></a>01029      fflush(NULL);
<a name="l01030"></a>01030      exit(-1);
<a name="l01031"></a>01031       }
<a name="l01032"></a>01032 
<a name="l01033"></a>01033       <span class="comment">// note cols can get off here if num blocks is very large</span>
<a name="l01034"></a>01034       printf(<span class="stringliteral">"%s Variable Truth Table:\n"</span>,str);
<a name="l01035"></a>01035       printf(<span class="stringliteral">"  %14s"</span>,<span class="stringliteral">" "</span>);
<a name="l01036"></a>01036       <span class="keywordflow">for</span> (i = 0; i &lt; num_blk[ii]; i++)
<a name="l01037"></a>01037      printf(<span class="stringliteral">"%8s#%d "</span>, str, i+1); <span class="comment">//exodus numbering starts with 1</span>
<a name="l01038"></a>01038       printf(<span class="stringliteral">"\n"</span>);
<a name="l01039"></a>01039       <span class="keywordflow">for</span> (i = 0; i &lt; num_blk_var[ii]; i++) {
<a name="l01040"></a>01040      printf(<span class="stringliteral">"  %8sVar#%d "</span>, str, i);
<a name="l01041"></a>01041      <span class="keywordflow">for</span> (j = 0; j &lt; num_blk[ii]; j++)
<a name="l01042"></a>01042        printf(<span class="stringliteral">" %4s%2d%3s "</span>, <span class="stringliteral">" "</span>, truth_tab[j*num_blk_var[ii]+i], <span class="stringliteral">" "</span>);
<a name="l01043"></a>01043      printf(<span class="stringliteral">"\n"</span>);
<a name="l01044"></a>01044       }
<a name="l01045"></a>01045       fflush(NULL);
<a name="l01046"></a>01046       free(truth_tab);
<a name="l01047"></a>01047     }
<a name="l01048"></a>01048     printf(<span class="stringliteral">"\n"</span>);
<a name="l01049"></a>01049   }
<a name="l01050"></a>01050 
<a name="l01051"></a>01051 
<a name="l01052"></a>01052   <span class="comment">// **set vars</span>
<a name="l01053"></a>01053   <span class="keywordflow">for</span> (ii = 0; ii &lt; NUMSETTYPES; ii++){
<a name="l01054"></a>01054     <span class="keywordtype">char</span>* varinq;
<a name="l01055"></a>01055     <span class="keywordtype">char</span>* str;
<a name="l01056"></a>01056     <span class="keywordflow">switch</span> (ii){
<a name="l01057"></a>01057     <span class="keywordflow">case</span> <a class="code" href="exodump_8c.html#06fc87d81c62e9abb8790b6e5713c55b7b4c0e5ae1385e1224a6e59abf47ecc0">NODESET</a>:
<a name="l01058"></a>01058       str = <span class="stringliteral">"NodeSet"</span>;
<a name="l01059"></a>01059       varinq = <span class="stringliteral">"m"</span>;
<a name="l01060"></a>01060       <span class="keywordflow">break</span>;
<a name="l01061"></a>01061     <span class="keywordflow">case</span> <a class="code" href="exodump_8c.html#06fc87d81c62e9abb8790b6e5713c55bf2cc6d0bdf89f64e022a1dd3ac9bf31e">ELEMSET</a>:
<a name="l01062"></a>01062       str = <span class="stringliteral">"ElemSet"</span>;
<a name="l01063"></a>01063       varinq = <span class="stringliteral">"t"</span>;
<a name="l01064"></a>01064       <span class="keywordflow">break</span>;
<a name="l01065"></a>01065     <span class="keywordflow">case</span> <a class="code" href="exodump_8c.html#06fc87d81c62e9abb8790b6e5713c55bf03e67951597561f7910379848050552">FACESET</a>:
<a name="l01066"></a>01066       str = <span class="stringliteral">"FaceSet"</span>;
<a name="l01067"></a>01067       varinq = <span class="stringliteral">"a"</span>;
<a name="l01068"></a>01068       <span class="keywordflow">break</span>;
<a name="l01069"></a>01069     <span class="keywordflow">case</span> <a class="code" href="exodump_8c.html#06fc87d81c62e9abb8790b6e5713c55b0f9cb4d6eb49d02851626be8b5b9bf01">EDGESET</a>:
<a name="l01070"></a>01070       str = <span class="stringliteral">"EdgeSet"</span>;
<a name="l01071"></a>01071       varinq = <span class="stringliteral">"d"</span>;
<a name="l01072"></a>01072       <span class="keywordflow">break</span>;
<a name="l01073"></a>01073     <span class="keywordflow">case</span> <a class="code" href="exodump_8c.html#06fc87d81c62e9abb8790b6e5713c55b86c05035d6a2fbc5762f39215d6a8a22">SIDESET</a>:
<a name="l01074"></a>01074       str = <span class="stringliteral">"SideSet"</span>;
<a name="l01075"></a>01075       varinq = <span class="stringliteral">"s"</span>;
<a name="l01076"></a>01076       <span class="keywordflow">break</span>;
<a name="l01077"></a>01077     <span class="keywordflow">default</span>:
<a name="l01078"></a>01078       fprintf(stderr, <span class="stringliteral">"Error: bad set type\n"</span>);
<a name="l01079"></a>01079       fflush(NULL);
<a name="l01080"></a>01080       exit(-1);
<a name="l01081"></a>01081     }
<a name="l01082"></a>01082   
<a name="l01083"></a>01083     <span class="comment">//vars</span>
<a name="l01084"></a>01084     <span class="keywordflow">if</span> (num_set_var[ii] &gt; 0) {
<a name="l01085"></a>01085       printf(<span class="stringliteral">"\n"</span>);
<a name="l01086"></a>01086       var_names = (<span class="keywordtype">char</span>**)malloc(num_set_var[ii]*<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>*));
<a name="l01087"></a>01087       <span class="keywordflow">for</span> (i = 0; i &lt; num_set_var[ii]; i++)
<a name="l01088"></a>01088      var_names[i] = (<span class="keywordtype">char</span>*)malloc((MAX_STR_LENGTH+1)*<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));
<a name="l01089"></a>01089       error = ex_get_var_names(exoid, varinq, num_set_var[ii], var_names);
<a name="l01090"></a>01090       <span class="keywordflow">if</span> (error != 0) {
<a name="l01091"></a>01091      fprintf(stderr, <span class="stringliteral">"Error: Failed to get set var names\n"</span>);
<a name="l01092"></a>01092      fflush(NULL);
<a name="l01093"></a>01093      exit(-1);
<a name="l01094"></a>01094       }
<a name="l01095"></a>01095       printf(<span class="stringliteral">"%s Variables:\n"</span>,str);
<a name="l01096"></a>01096       <span class="keywordflow">for</span> (i = 0; i &lt; num_set_var[ii]; i++)
<a name="l01097"></a>01097      printf(<span class="stringliteral">"  %d: %s\n"</span>, i, var_names[i]);
<a name="l01098"></a>01098       <span class="keywordflow">for</span> (i = 0; i &lt; num_set_var[ii]; i++)
<a name="l01099"></a>01099      free(var_names[i]);
<a name="l01100"></a>01100       free(var_names);
<a name="l01101"></a>01101       printf(<span class="stringliteral">"\n"</span>);
<a name="l01102"></a>01102       fflush(NULL);
<a name="l01103"></a>01103     }
<a name="l01104"></a>01104 
<a name="l01105"></a>01105 
<a name="l01106"></a>01106     <span class="comment">// truth table</span>
<a name="l01107"></a>01107     <span class="keywordflow">if</span> (num_set_var[ii] &gt; 0) {
<a name="l01108"></a>01108       truth_tab = (<span class="keywordtype">int</span>*)malloc(num_set[ii]*num_set_var[ii]*<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
<a name="l01109"></a>01109       error = ex_get_var_tab(exoid, varinq, num_set[ii], num_set_var[ii], truth_tab);
<a name="l01110"></a>01110       <span class="keywordflow">if</span> (error != 0) {
<a name="l01111"></a>01111      fprintf(stderr, <span class="stringliteral">"Error: Failed to get set truth table\n"</span>);
<a name="l01112"></a>01112      fflush(NULL);
<a name="l01113"></a>01113      exit(-1);
<a name="l01114"></a>01114       }
<a name="l01115"></a>01115       printf(<span class="stringliteral">"%s Variable Truth Table:\n"</span>,str);
<a name="l01116"></a>01116       printf(<span class="stringliteral">"  %11s"</span>,<span class="stringliteral">" "</span>);
<a name="l01117"></a>01117       <span class="keywordflow">for</span> (i = 0; i &lt; num_set[ii]; i++)
<a name="l01118"></a>01118      printf(<span class="stringliteral">" %6s#%d "</span>, str, i);
<a name="l01119"></a>01119       printf(<span class="stringliteral">"\n"</span>);
<a name="l01120"></a>01120       <span class="keywordflow">for</span> (i = 0; i &lt; num_set_var[ii]; i++) {
<a name="l01121"></a>01121      printf(<span class="stringliteral">"  %6s Var # %d "</span>, str, i);
<a name="l01122"></a>01122      <span class="keywordflow">for</span> (j = 0; j &lt; num_set[ii]; j++)
<a name="l01123"></a>01123        printf(<span class="stringliteral">" %3s%d%3s "</span>, <span class="stringliteral">" "</span>, truth_tab[j*num_set_var[ii]+i], <span class="stringliteral">" "</span>);
<a name="l01124"></a>01124      printf(<span class="stringliteral">"\n"</span>);
<a name="l01125"></a>01125       }
<a name="l01126"></a>01126       fflush(NULL);
<a name="l01127"></a>01127       free(truth_tab);
<a name="l01128"></a>01128     }
<a name="l01129"></a>01129   }
<a name="l01130"></a>01130 
<a name="l01131"></a>01131   exit(0);
<a name="l01132"></a>01132 }
</pre></div>
<p>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Mon Oct 27 13:26:09 2008 for FCLib by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
